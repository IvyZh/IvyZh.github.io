<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android源码分析——OKHttp | K的小屋</title><meta name="description" content="Android源码分析——OKHttp"><meta name="keywords" content="Android,OkHttp"><meta name="author" content="Kai"><meta name="copyright" content="Kai"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Android源码分析——OKHttp"><meta name="twitter:description" content="Android源码分析——OKHttp"><meta name="twitter:image" content="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=357267695,3859876688&amp;fm=26&amp;gp=0.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Android源码分析——OKHttp"><meta property="og:url" content="https://www.google.com/2020/05/15/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94OKHttp/"><meta property="og:site_name" content="K的小屋"><meta property="og:description" content="Android源码分析——OKHttp"><meta property="og:image" content="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=357267695,3859876688&amp;fm=26&amp;gp=0.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://www.google.com/2020/05/15/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94OKHttp/"><link rel="prev" title="【转】Base64编码详解" href="https://www.google.com/2020/05/18/%E3%80%90%E8%BD%AC%E3%80%91Base64%E7%BC%96%E7%A0%81%E8%AF%A6%E8%A7%A3/"><link rel="next" title="开发技能汇总" href="https://www.google.com/2020/05/13/%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD%E6%B1%87%E6%80%BB/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">21</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-number">1.</span> <span class="toc-text">参考文章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请求流程"><span class="toc-number">2.</span> <span class="toc-text">请求流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内容概括"><span class="toc-number">3.</span> <span class="toc-text">内容概括</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#okhttp同步请求流程和源码分析"><span class="toc-number">4.</span> <span class="toc-text">okhttp同步请求流程和源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#okhttp异步请求流程和源码分析"><span class="toc-number">5.</span> <span class="toc-text">okhttp异步请求流程和源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#okhttp任务调度核心类dispatcher解析"><span class="toc-number">6.</span> <span class="toc-text">okhttp任务调度核心类dispatcher解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回顾getResponseWithInterceptorChain"><span class="toc-number">7.</span> <span class="toc-text">回顾getResponseWithInterceptorChain()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RetryAndFollowUpInterceptor解析"><span class="toc-number">8.</span> <span class="toc-text">RetryAndFollowUpInterceptor解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BridgeInterceptor解析"><span class="toc-number">9.</span> <span class="toc-text">BridgeInterceptor解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CacheInterceptor解析"><span class="toc-number">10.</span> <span class="toc-text">CacheInterceptor解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConnectInterceptor解析"><span class="toc-number">11.</span> <span class="toc-text">ConnectInterceptor解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CallServerInterceptor解析"><span class="toc-number">12.</span> <span class="toc-text">CallServerInterceptor解析</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=357267695,3859876688&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">K的小屋</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Android源码分析——OKHttp</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-15 17:30:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-15</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-16 22:43:50"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-16</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">12.7k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 55 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<p><a href="https://www.jianshu.com/p/d98be38a6d3f" target="_blank" rel="noopener">https://www.jianshu.com/p/d98be38a6d3f</a></p>
<p><a href="https://blog.csdn.net/qq_29152241/article/details/82011539" target="_blank" rel="noopener">https://blog.csdn.net/qq_29152241/article/details/82011539</a></p>
</blockquote>
<h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>使用版本：’com.squareup.okhttp3:okhttp:3.9.0’</p>
<p><img src="/" class="lazyload" data-src="/img/okhttp_assets/OkHttp%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B%E5%9B%BE.png"  alt="OkHttp请求流程图"></p>
<h2 id="内容概括"><a href="#内容概括" class="headerlink" title="内容概括"></a>内容概括</h2><p>OKHttp源码需要关注的两点：</p>
<p>1、Dispatcher分发器</p>
<p>​    -  维护请求队列（同步&amp;异步），内部维护了一个线程池</p>
<p>2、拦截器</p>
<p>​    - 官网解释：拦截器是OkHttp中提供一种强大机制，它可以实现网络监听、请求以及响应重写、请求失败重试等功能，不区分同步和异步请求</p>
<p>拦截器：分为应用程序拦截器、OkHttp Core、网络拦截器</p>
<p>OkHttp Core又分为5个拦截器：</p>
<p>RetryAndFollowUpInterceptor–&gt;BridgeInterceptor–&gt;CacheInterceptor–&gt;ConnectIntercept–&gt;CallServerInterceptor</p>
<p><strong>RetryAndFollowUpInterceptor</strong>:重试和失败重定向拦截器,主要做一些初始化工作还要创建一个streamAllocation对象用来传递给后面的拦截器<br><strong>BridgeInterceptor</strong>:桥接和适配拦截器,补充用户在创建http请求中缺少的必须的http请求头和处理缓存的功能<br><strong>CacheInterceptor</strong>:缓存拦截器,补充用户在创建http请求中缺少的必须的http请求头和处理缓存的功能<br><strong>ConnectIntercept</strong>:连接拦截器,主要负责建立可用的链接，ConnectIntercept是CallServerInterceptor的基础。而前面创建的streamAllocation对象会一层层传递到这里。<br><strong>CallServerInterceptor</strong>:将Http请求写进网络的io流当中，并且从网络的io流当中读取服务端返回给客户端的数据</p>
<p>OkHttp中一次网络请求的大致过程：</p>
<ol>
<li>Call对象对请求的封装，Call call = client.newCall(request)</li>
<li>Dispatcher对请求的分发call.execute()或者call.enqueue()—&gt;dispatcher().executed()或者是dispatcher().enqueue()–&gt;最终都会走到getResponseWithInterceptors()方法中</li>
<li>getResponseWithInterceptors()</li>
</ol>
<ul>
<li>RetryAndFollowUpInterceptor：重试和重定向请求的</li>
<li>BridgeInterceptor：补充用户在创建http请求中缺少的必须的http请求头</li>
<li>CacheInterceptor：用来处理缓存的拦截器</li>
<li>ConnectIntercept：负责建立链接和流对象</li>
<li>CallServerInterceptor：负责最终的网络请求的，发送请求和读取响应</li>
</ul>
<h2 id="okhttp同步请求流程和源码分析"><a href="#okhttp同步请求流程和源码分析" class="headerlink" title="okhttp同步请求流程和源码分析"></a>okhttp同步请求流程和源码分析</h2><p>OkHttp同步请求,需要开子线程，同步请求就是执行请求的操作是阻塞式的，直到HTTP响应返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void synRequest(View v) &#123;</span><br><span class="line">    &#x2F;&#x2F;Step1. 创建一个OkHttpClient对象，有两种方式</span><br><span class="line">    &#x2F;&#x2F;方式①：直接new出来</span><br><span class="line">    &#x2F;&#x2F;OkHttpClient client &#x3D; new OkHttpClient();</span><br><span class="line">    &#x2F;&#x2F;方式②：使用Builder构建者模式创建，可以设置更多配置参数</span><br><span class="line">    OkHttpClient client &#x3D; new OkHttpClient.Builder().readTimeout(5, TimeUnit.SECONDS).build();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Step2: 构建携带请求信息的Request对象</span><br><span class="line">    String url &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&quot;;</span><br><span class="line">    Request request &#x3D; new Request.Builder().url(url).get().build();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Step3：通过OkHttpClient和Request对象构建我们实际Http请求的Call对象（注意：无论是同步还是异步都是通过 OkHttpClient.newCall(Request)方法创建Call对象的，即RealCall.newRealCall方法）</span><br><span class="line">    Call call &#x3D; client.newCall(request);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;需要开启子线程网络请求</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;Caused by: android.os.NetworkOnMainThreadException</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;Step4：通过call的execute方法完成同步请求</span><br><span class="line">            Response response &#x3D; call.execute();</span><br><span class="line">            &#x2F;&#x2F;realCall.execute--&gt; client.dispatcher().executed(this);this:realCall--&gt; runningSyncCalls.add(call);将请求加入到同步请求队列当中</span><br><span class="line"></span><br><span class="line">            String result &#x3D; response.body().string();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            &#x2F;&#x2F;回到主线程更新UI</span><br><span class="line">            runOnUiThread(() -&gt; mTvResult.setText(result));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看OkHttpClient的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Call</span>.<span class="title">Factory</span>, <span class="title">WebSocket</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Dispatcher dispatcher;<span class="comment">//调度器</span></span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">    Proxy proxy;<span class="comment">//代理</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Protocol&gt; protocols;<span class="comment">//协议</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;ConnectionSpec&gt; connectionSpecs;<span class="comment">//传输层版本和连接协议</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors;<span class="comment">//拦截器</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Interceptor&gt; networkInterceptors;<span class="comment">//网络拦截器</span></span><br><span class="line">    <span class="keyword">final</span> EventListener.Factory eventListenerFactory;</span><br><span class="line">    <span class="keyword">final</span> ProxySelector proxySelector;<span class="comment">//代理选择器</span></span><br><span class="line">    <span class="keyword">final</span> CookieJar cookieJar;<span class="comment">//cookie</span></span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">    Cache cache;<span class="comment">//cache 缓存</span></span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">    InternalCache internalCache;<span class="comment">//内部缓存</span></span><br><span class="line">    <span class="keyword">final</span> SocketFactory socketFactory;<span class="comment">//socket 工厂</span></span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">    SSLSocketFactory sslSocketFactory;<span class="comment">//安全套层socket工厂 用于https</span></span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">    CertificateChainCleaner certificateChainCleaner;<span class="comment">//验证确认响应书，适用HTTPS 请求连接的主机名</span></span><br><span class="line">    <span class="keyword">final</span> HostnameVerifier hostnameVerifier;<span class="comment">//主机名字确认</span></span><br><span class="line">    <span class="keyword">final</span> CertificatePinner certificatePinner;<span class="comment">//证书链</span></span><br><span class="line">    <span class="keyword">final</span> Authenticator proxyAuthenticator;<span class="comment">//代理身份验证</span></span><br><span class="line">    <span class="keyword">final</span> Authenticator authenticator;<span class="comment">//本地身份验证</span></span><br><span class="line">    <span class="keyword">final</span> ConnectionPool connectionPool;<span class="comment">//链接池 复用连接</span></span><br><span class="line">    <span class="keyword">final</span> Dns dns;<span class="comment">//域名</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> followSslRedirects;<span class="comment">//安全套接层重定向</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> followRedirects;<span class="comment">//本地重定向</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> retryOnConnectionFailure;<span class="comment">//重试连接失败</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> connectTimeout;<span class="comment">//连接超时</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> readTimeout;<span class="comment">//读取超时</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> writeTimeout;<span class="comment">//写入超时</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pingInterval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">	 </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//Dispatcher很重要，是OkHttp的请求分发器，由他决定异步请求是直接处理还是缓存等待；对于同步请求，没有做太多操作，只是把它的同步请求放到了同步请求队列执行</span></span><br><span class="line">            dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">            protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">            connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">            eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">            proxySelector = ProxySelector.getDefault();</span><br><span class="line">            cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">            socketFactory = SocketFactory.getDefault();</span><br><span class="line">            hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">            certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">            proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">            authenticator = Authenticator.NONE;</span><br><span class="line">            <span class="comment">//连接池，客户端和服务器每一个链接都可以理解为一个connection，而每一个connection我们都把它放到ConnectionPool中，由它统一管理。当请求的url相同的时候，就可以复用。</span></span><br><span class="line">            <span class="comment">//ConnectionPool还有一个作用就是它实现了哪一些链接可以保持连接，哪一些是可以保持复用的，这些策略的设置也是ConnectionPool来管理的。</span></span><br><span class="line">            connectionPool = <span class="keyword">new</span> ConnectionPool();</span><br><span class="line">            dns = Dns.SYSTEM;</span><br><span class="line">            followSslRedirects = <span class="keyword">true</span>;</span><br><span class="line">            followRedirects = <span class="keyword">true</span>;</span><br><span class="line">            retryOnConnectionFailure = <span class="keyword">true</span>;</span><br><span class="line">            connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">            readTimeout = <span class="number">10_000</span>;</span><br><span class="line">            writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">            pingInterval = <span class="number">0</span>;</span><br><span class="line">        &#125;	 </span><br><span class="line">	 </span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">//....</span></span><br><span class="line">   <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>代码解释：</p>
<ol>
<li><strong>OkHttpClient创建</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder().readTimeout(<span class="number">5</span>, TimeUnit.SECONDS).build();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建OkHttpClient有两种方式，直接new出来，或者通过Builder构建者模式</p>
</blockquote>
<ol start="2">
<li><strong>Request请求对象也是通过Builder模式创建出来的</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request request &#x3D; new Request.Builder().url(url).get().build();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>创建实际请求的Call对象</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call call &#x3D; client.newCall(request);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过OkHttpClient和Request对象构建我们实际Http请求的Call对象（注意：无论是同步还是异步都是通过 OkHttpClient.newCall(Request)方法创建Call对象的，即RealCall.newRealCall方法）</p>
</blockquote>
<p>RealCall的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">implements</span> <span class="title">Call</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line">    <span class="keyword">final</span> RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * There is a cycle between the &#123;<span class="doctag">@link</span> Call&#125; and &#123;<span class="doctag">@link</span> EventListener&#125; that makes this awkward.</span></span><br><span class="line"><span class="comment">     * This will be set after we create the call instance then create the event listener instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EventListener eventListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The application's original request unadulterated by redirects or auth headers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Request originalRequest;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> forWebSocket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Guarded by this.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> executed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RealCall持有了前两步骤创建的OkHttpClient和Request对象</span></span><br><span class="line"><span class="comment">     * 同时还赋值了重定向拦截器RetryAndFollowUpInterceptor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.originalRequest = originalRequest;</span><br><span class="line">        <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">        <span class="comment">//RetryAndFollowUpInterceptor:重定向拦截器</span></span><br><span class="line">        <span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法的功能就是创建了RealCall对象，并给RealCall赋值了Listener就返回了</span></span><br><span class="line"><span class="comment">     * 注意：无论是同步还是异步都是通过 OkHttpClient.newCall(Request)方法创建Call对象的，即RealCall.newRealCall方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">        RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">        call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">        <span class="keyword">return</span> call;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现在RealCall.newReallCall()方法的时候做了如下工作：</p>
<ul>
<li>给成员变量OkHttpClient client、Request originalRequest赋值</li>
<li>创建重试和重定向拦截器RetryAndFollowUpInterceptor</li>
</ul>
<ol start="4">
<li><p><strong>通过call的execute方法完成同步请求</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response response &#x3D; call.execute();</span><br></pre></td></tr></table></figure>

<p>这里实际上是会调用RealCall.excute()方法：</p>
</li>
</ol>
<p>RealCall的excute方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">implements</span> <span class="title">Call</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发起同步请求方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//同步代码块：同一个Http请求，只能执行一次</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">            executed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        captureCallStackTrace();<span class="comment">//捕捉一些Http请求异常的堆栈信息，和主流程关系不大，可以先不管</span></span><br><span class="line">        eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// client.dispatcher():返回之前new出来的分发器对象Dispatcher</span></span><br><span class="line">            <span class="comment">//dispatcher.executed(this):这个方法很重要！！！主要是把我们的请求放到同步请求队列当中，而这个请求队列runningSyncCalls是在Dispatcher类成员变量定义的</span></span><br><span class="line">            client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//getResponseWithInterceptorChain：其实是调用了拦截器链返回的</span></span><br><span class="line">            Response result = getResponseWithInterceptorChain();</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            eventListener.callFailed(<span class="keyword">this</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//finished很微妙：会主动的回收同步请求</span></span><br><span class="line">            client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要关注的内容有：</p>
<ul>
<li>同一个Http请求，只能执行一次，也就是一个call只能调用一遍execute方法，否则会报Already Executed异常，可以使用RealCall的clone方法复制一份</li>
<li>client.dispatcher().executed(this) :其实就是执行了Dispatcher里面的execute方法，注意Dispatcher其实在OkHttpClient的时候已经初始化好了的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final class Dispatcher &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 同步的请求，就是把call对象加入的runningSyncCalls队列当中</span><br><span class="line">     * runningSyncCalls：同步请求队列</span><br><span class="line">     * synchronized:锁住了</span><br><span class="line">     *&#x2F;</span><br><span class="line">    synchronized void executed(okhttp3.RealCall call) &#123;</span><br><span class="line">        runningSyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出同步请求的时候Dispatcher的作用很简单，就是将请求加入到同步执行队列当中</p>
<ul>
<li>Response result = getResponseWithInterceptorChain()：这句话就是通过责任链模式、异常调用拦截器来处理和返回数据，后面会详细讲</li>
<li>还有一个细节就是在finally代码块中client.dispatcher().finished(this);</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispather</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> promoteCalls 同步请求时，值为false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="keyword">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> runningCallsCount;</span><br><span class="line">        Runnable idleCallback;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//calls.remove(call)：从当前同步请求队列中移除此请求</span></span><br><span class="line">            <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">            <span class="comment">//同步的时候，promoteCalls为false，不会走到promoteCalls()方法里面，但是异步的时候会走到，到时候会具体分析。</span></span><br><span class="line">            <span class="keyword">if</span> (promoteCalls)</span><br><span class="line">                promoteCalls();<span class="comment">//检查是否为异步请求，检查等候的队列 readyAsyncCalls，如果存在等候队列，则将等候队列加入执行队列</span></span><br><span class="line">            <span class="comment">//runningCallsCount():计算目前还在运行的请求（runningAsyncCalls+runningSyncCalls）返回正在执行的同步请求和异步请求的总和</span></span><br><span class="line">            runningCallsCount = runningCallsCount();</span><br><span class="line">            idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有可运行的请求，会执行idleCallback.run();</span></span><br><span class="line">        <span class="comment">//闲置调用</span></span><br><span class="line">        <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            idleCallback.run();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小结：在同步请求中Dispatcher的作用就是保存同步请求、移除同步请求。异步请求Dispatcher做的工作就很多了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上就是同步请求的流程和源码浅析</p>
<h2 id="okhttp异步请求流程和源码分析"><a href="#okhttp异步请求流程和源码分析" class="headerlink" title="okhttp异步请求流程和源码分析"></a>okhttp异步请求流程和源码分析</h2><p>异步请求的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OkHttp异步请求,不需要开子线程</span></span><br><span class="line"><span class="comment"> * 异步清酒就类似于非阻塞式的请求，它的执行结果一般都是通过接口回调的方式告知调用者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyRequest</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端有两种方式</span></span><br><span class="line">    <span class="comment">//方式1：直接new出来</span></span><br><span class="line">    <span class="comment">//OkHttpClient client = new OkHttpClient();</span></span><br><span class="line">    <span class="comment">//方式2：使用Builder构建者模式创建，可以设置更多配置参数</span></span><br><span class="line">    OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder().readTimeout(<span class="number">5</span>, TimeUnit.SECONDS).build();</span><br><span class="line">    String url = <span class="string">"https://www.jd.com"</span>;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder().url(url).get().build();</span><br><span class="line">    Call call = client.newCall(request);</span><br><span class="line">    <span class="comment">//以上3步和同步请求一样，都只是创建了对象，并没有真正发起网络请求</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step4：把异步请求加入到Dispatcher调度器中,真正的网络请求是通过拦截器链来执行的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//realCall.enqueue--&gt; client.dispatcher().enqueue(new AsyncCall(responseCallback));//responseCallback:Callback对象,AsyncCall:Runnable对象，有request方法</span></span><br><span class="line">    <span class="comment">// --&gt; enqueue(AsyncCall call);</span></span><br><span class="line">    <span class="comment">// 条件判断：</span></span><br><span class="line">    <span class="comment">//  a.如果满足则将AsyncCall对象加入到异步执行队列中，然后通过线程池executorService执行AsyncCall中的run方法，也就是execute方法。</span></span><br><span class="line">    <span class="comment">//    在AsyncCall.execute方法中有正在的网络请求是通过拦截链实现的，后面再讲。Response response = getResponseWithInterceptorChain();</span></span><br><span class="line">    <span class="comment">//  b.条件不满足，则将请求加入到异步等待队列readyAsyncCalls当中</span></span><br><span class="line"></span><br><span class="line">    call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            String result = response.body().string();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            <span class="comment">//回到主线程更新UI</span></span><br><span class="line">            runOnUiThread(() -&gt; mTvResult.setText(result));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//enqueue方法总结：</span></span><br><span class="line">    <span class="comment">//1. 判断当前Call是否已经被执行过了（Call是子类RealCall里面持有OkHttpClient和Request对象）</span></span><br><span class="line">    <span class="comment">//2. 将传进来的Callback对象封装成AsyncCall对象（AsyncCall就是一个Runnable，里面有Callback对象）</span></span><br><span class="line">    <span class="comment">//3. client.dispatcher().enqueue(new AsyncCall(responseCallback))进行异步网络请求</span></span><br><span class="line">    <span class="comment">//3.1 通过判断条件，将请求加入到异步执行队列runningAsyncCalls或者异步等待队列中readyAsyncCalls</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>前三步和同步请求一样，我们重点关注call.enqueue(new Callback() {}这个方法：</p>
<p>CallBack.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>call.enqueue实际就是RealCall.enqueue()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">implements</span> <span class="title">Call</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方式是 realCall.enqueue(new Callback() )调用的，其中realCall持有了Client和Request</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> Callback：就是一个用于返回请求的接口，里面有两个方法，后面会将其封装进一个Runnable对象中，即AsyncCall</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同步代码块：同一个Http请求，只能执行一次，不能重复执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//synchronized (this) 确保每个call只能被执行一次不能重复执行，如果想要完全相同的call，可以调用如下方法RealCall.clone()进行克隆</span></span><br><span class="line">            <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">            executed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        captureCallStackTrace();<span class="comment">//捕捉一些Http请求异常的堆栈信息，和主流程关系不大，可以先不管</span></span><br><span class="line">        eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//交给 dispatcher调度器 进行调度</span></span><br><span class="line">        <span class="comment">//responseCallback：是一个接口，里面就定义了两个方法onFailure和onResponse</span></span><br><span class="line">        <span class="comment">//AsyncCall是继承了NamedRunnable，而NamedRunnable实际就是Runnable，AsyncCall里面有originalRequest的字段</span></span><br><span class="line">        client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的点有：</p>
<ul>
<li><p>Call请求只能执行一次，不能重复执行</p>
</li>
<li><p>client.dispatcher().enqueue(new AsyncCall(responseCallback))语句解释</p>
<ul>
<li>将传进来的Callback对象封装到AsyncCall对象里面，AsyncCall实际是一个Runnable，定义在了RealCall内部</li>
<li>实际就走到了Dispatcher.enqueue(AsyncCall)方法中了</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">implements</span> <span class="title">Call</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AsyncCall没有run方法，但是在它的父类NamedRunnable里面有run方法，包装了一个execute();抽象方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</span><br><span class="line"></span><br><span class="line">        AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl());</span><br><span class="line">            <span class="keyword">this</span>.responseCallback = responseCallback;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">host</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> originalRequest.url().host();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> originalRequest;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">RealCall <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> RealCall.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//责任链模式</span></span><br><span class="line">                <span class="comment">//getResponseWithInterceptorChain：拦截链，这是重点，后面会分析。现在只需要知道通过这个方法可以返回Response就行。</span></span><br><span class="line">                Response response = getResponseWithInterceptorChain();</span><br><span class="line">                <span class="comment">//retryAndFollowUpInterceptor:重定向和重试拦截器，属于拦截链中的一个拦截器</span></span><br><span class="line">                <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">                    signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//如果取消了就调用Callback的onFailure方法</span></span><br><span class="line">                    responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">                    responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//注意：回调方法onFailure和onResponse都是在子线程里面调用的</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                    <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">                    Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    eventListener.callFailed(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">                    responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 值得注意的finally 执行了client.dispatcher().finished(this); 通过调度器移除队列，并且判断是否存在等待队列，</span></span><br><span class="line"><span class="comment">                 * 如果存在，检查执行队列是否达到最大值，如果没有将等待队列变为执行队列。这样也就确保了等待队列被执行</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 1、将AsyncCall这个请求从runningAsyncCalls队列中移除（AsyncCall里面有Request方法返回request对象）</span></span><br><span class="line"><span class="comment">                 * 2、调用promoteCalls(),调整异步请求队列</span></span><br><span class="line"><span class="comment">                 * 3、重新计算请求数量，用作判断</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dispatcher源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;<span class="comment">//同时能进行的最大请求数，整个OkHttp的异步请求不会超过64个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;<span class="comment">//同时请求的相同HOST的最大个数 SCHEME :// HOST [ ":" PORT ] [ PATH [ "?" QUERY ]]</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池</span></span><br><span class="line"><span class="comment">     * Executes calls. Created lazily.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span></span><br><span class="line">    ExecutorService executorService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步的就绪队列：表示缓存请求的队列，当请求来了的时候，会先判断是否满足条件，如果不满足就会加到这个队列，后面会将其加到runningAsyncCalls中</span></span><br><span class="line"><span class="comment">     * 双端队列，支持首尾两端 双向开口可进可出，方便移除</span></span><br><span class="line"><span class="comment">     * okhttp 可以进行多个并发网络请求，并且可以设置最大的请求数</span></span><br><span class="line"><span class="comment">     * Ready async calls in the order they'll be run.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步执行的队列：代表正在运行的任务，主要作用是判断并发的数量</span></span><br><span class="line"><span class="comment">     * Running asynchronous calls. Includes canceled calls that haven't finished yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思考1：为什么异步请求需要两个队列？</span></span><br><span class="line">    <span class="comment">//Dispatcher可以理解为生产者（默认是在主线程执行），ExecutorService对应于消费者池，所以就需要两个队列，一个存放缓存，一个存放正在运行的任务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//思考2：异步请求Call执行完肯定需要在runningAsyncCalls队列中移除这个线程，那么readAsyncCalls队列中的线程在什么时候被执行呢？</span></span><br><span class="line">    <span class="comment">//这个时候就要看AsyncCall的源码了！主要是execute方法：当获取Response并调用接口返回之后在finally方法中有这样一句话： client.dispatcher().finished(this);</span></span><br><span class="line">    <span class="comment">//dispatcher.finished(this)--&gt; dispatcher.finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls)而这个方法有3个功能步骤：</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、将AsyncCall这个请求从runningAsyncCalls队列中移除（AsyncCall里面有Request方法返回request对象）</span></span><br><span class="line"><span class="comment">     * 2、调用promoteCalls(),调整异步请求队列****重点！！</span></span><br><span class="line"><span class="comment">     * 3、重新计算请求数量（异步+同步队列）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行异步请求</span></span><br><span class="line"><span class="comment">     * synchronized：加了同步锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> call 传进来的AsyncCall是一个Runnable对象，里面持有Callback对象，Callback对象有两个方法</span></span><br><span class="line"><span class="comment">     *             AsyncCall里面有 Request request() &#123; return originalRequest;&#125;方法，返回originalRequest对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//runningAsyncCalls:正在运行的异步请求队列，最大值为64,同时请求不能超过并发数(64,可配置调度器调整)</span></span><br><span class="line">        <span class="comment">//runningCallsForHost:正在运行的主机数，最大值为5,OkHttp会使用共享主机即 地址相同的会共享socket,同一个host最多允许5条线程通知执行请求</span></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">            runningAsyncCalls.add(call);<span class="comment">//满足添加则将传进来的AsyncCall对象，加入到异步运行队列runningAsyncCalls当中，加入运行队列 并交给线程池执行</span></span><br><span class="line">            <span class="comment">//executorService()：返回单例的线程池对象</span></span><br><span class="line">            <span class="comment">//execute(call)：通过线程池来管理Runnable对象，整个时候会执行AsyncCall call对象里面的run方法，去看AsyncCall的实现</span></span><br><span class="line">            executorService().execute(call);<span class="comment">//通过线程池执行这个请求，AsyncCall 是一个runnable，放到线程池中去执行，查看其execute实现</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            readyAsyncCalls.add(call);<span class="comment">//不满足条件则加入等待队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以总结一下对于异步请求Dispatcher的作用判断 runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost</p>
<p>满足：则将请求加入异步运行队列，通过线程池执行，而AsyncCall的execute方法里面有getResponseWithInterceptorChain方法，这就又回到和先前同步请求的时候一样了。</p>
<p>不满足：加入等待队列</p>
<h2 id="okhttp任务调度核心类dispatcher解析"><a href="#okhttp任务调度核心类dispatcher解析" class="headerlink" title="okhttp任务调度核心类dispatcher解析"></a>okhttp任务调度核心类dispatcher解析</h2><p>Dispatcher作用：</p>
<blockquote>
<p>维持Call请求发给他的状态，它内部也维护了一个线程池用于执行网络请<br>dispatcher就是维护请求队列，内部维护了一个线程池</p>
</blockquote>
<p>思考1：为什么异步请求需要两个队列？</p>
<blockquote>
<p>Dispatcher可以理解为生产者（默认是在主线程执行），ExecutorService对应于消费者池，所以就需要两个队列，一个存放缓存，一个存放正在运行的任务.</p>
</blockquote>
<p>思考2：异步请求Call执行完肯定需要在runningAsyncCalls队列中移除这个线程，那么readAsyncCalls队列中的线程在什么时候被执行呢？</p>
<blockquote>
<p>这个时候就要看AsyncCall的源码了！主要是execute方法：当获取Response并调用接口返回之后在finally方法中有这样一句话： client.dispatcher().finished(this);<br>dispatcher.finished(this)–&gt; dispatcher.finished(Deque<T> calls, T call, boolean promoteCalls)而这个方法有3个功能步骤：</p>
<p>1、将AsyncCall这个请求从runningAsyncCalls队列中移除（AsyncCall里面有Request方法返回request对象）<br>2、调用promoteCalls(),调整异步请求队列****重点！！<br>3、重新计算请求数量（异步+同步队列）</p>
</blockquote>
<p><strong>Dispatcher里面的线程池：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Diapatcher</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized 保证executorService对象是单例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回线程池对象 executorService</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//线程池的创建，参数类型是什么意思，后面会讲到</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 第一个参数：corePoolSize 核心线程数 设置为0的作用：表示如果空闲一段时间会将所有线程全部销毁</span></span><br><span class="line"><span class="comment">             * 第二个参数：maximumPoolSize 最大线程数，设置为Int的最大值，表示理论上可以存放多少线程，但是我们设置了限制maxRequests，表示存放最多存放64个</span></span><br><span class="line"><span class="comment">             * 第三个参数：keepAliveTime 表示当我们线程数大于核心线程数的时候，多余的空闲线程存活时间</span></span><br><span class="line"><span class="comment">             * 第四个参数：unit 时间单位</span></span><br><span class="line"><span class="comment">             * 第五个参数：workQueue</span></span><br><span class="line"><span class="comment">             * 第六个参数：threadFactory</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executorService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>promoteCalls方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法很重要！！promote：促进; 推动; 促销; 推销; 提升; 晋升;</span></span><br><span class="line"><span class="comment">     * 在这个方法中就是对等待缓存队列进行调度的！</span></span><br><span class="line"><span class="comment">     * 调度策略：取出最后一个缓存等待队列的AsyncCall加入到运行队列当中，然后通过线程池进行执行。AsyncCall本质是一个Runnable，是RealCall的内部类，包装了Callback，里面还有可以获取originalRequest的方法。</span></span><br><span class="line"><span class="comment">     * 而Call call = client.newCall(request);这里的call其实就是RealCall,RealCall里面持有OkHttpClient和Request对象的引用</span></span><br><span class="line"><span class="comment">     * 前提：正在执行的异步请求数量小于64,而且等待队列有任务才行。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">        <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">                i.remove();</span><br><span class="line">                runningAsyncCalls.add(call);</span><br><span class="line">                executorService().execute(call);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">runningCallsCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runningAsyncCalls.size() + runningSyncCalls.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="回顾getResponseWithInterceptorChain"><a href="#回顾getResponseWithInterceptorChain" class="headerlink" title="回顾getResponseWithInterceptorChain()"></a>回顾getResponseWithInterceptorChain()</h2><p>回顾一下getResponseWithInterceptorChain方法被调用的地方：</p>
<p>异步请求&amp;同步请求情况：</p>
<p>call.enqueue&amp;call.execute</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">implements</span> <span class="title">Call</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//异步情况：</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));<span class="comment">//最终是通过线程池来调用到AsyncCall的execute方法的</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    AsyncCall implement NamedRunnable&#123;</span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">//....</span></span><br><span class="line">             Response response = getResponseWithInterceptorChain();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同步情况：</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        Response result = getResponseWithInterceptorChain();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法功能概述：构成了一个方法链，然后依次执行每一个不同功能的拦截器来获取服务的响应返回；</span></span><br><span class="line"><span class="comment">     * 主要讲系统提供给我们的5个拦截器：retryAndFollowUpInterceptor、BridgeInterceptor、CacheInterceptor、ConnectInterceptor、CallServerInterceptor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">        <span class="comment">//Step1. 创建一系列拦截器，并将其放入到一个拦截器List中interceptors</span></span><br><span class="line">        List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">// 责任链</span></span><br><span class="line">        interceptors.addAll(client.interceptors());<span class="comment">//添加用户自定义拦截器，也就是应用程序拦截器,在配置okhttpClient 时设置的intercept 由用户自己设置</span></span><br><span class="line">        interceptors.add(retryAndFollowUpInterceptor);<span class="comment">// 负责处理失败后的重试与重定向</span></span><br><span class="line">        interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));<span class="comment">// 负责把用户构造的请求转换为发送到服务器的请求 、把服务器返回的响应转换为用户友好的响应 处理 配置请求头等信息; 从应用程序代码到网络代码的桥梁。首先，它根据用户请求构建网络请求。然后它继续呼叫网络。最后，它根据网络响应构建用户响应。</span></span><br><span class="line">        interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));<span class="comment">//处理 缓存配置 根据条件(存在响应缓存并被设置为不变的或者响应在有效期内)返回缓存响应,设置请求头(If-None-Match、If-Modified-Since等) 服务器可能返回304(未修改)，可配置用户自己设置的缓存拦截器</span></span><br><span class="line">        interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));<span class="comment">//连接服务器 负责和服务器建立连接 这里才是真正的请求网络</span></span><br><span class="line">        <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">            interceptors.addAll(client.networkInterceptors());<span class="comment">//网络拦截器， 配置okhttpClient 时设置的networkInterceptors,返回观察单个网络请求和响应的不可变拦截器列表。</span></span><br><span class="line">        &#125;</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));<span class="comment">// 执行流操作(写出请求体、获得响应数据) 负责向服务器发送请求数据、从服务器读取响应数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Step2. 创建一个拦截器链RealInterceptorChain，并执行拦截器链的proceed方法，chain.proceed核心就是创建下一个拦截链,依次调用下一个拦截器的intercept方法，而在intercept方法中,进行http请求报文的封装与请求报文的解析</span></span><br><span class="line">        <span class="comment">//又会创建下一个拦截器。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建责任链</span></span><br><span class="line">        <span class="comment">//将上面创建好的拦截通过RealInterceptorChain的构造函数传进去，并创建RealInterceptorChain对象，注意 这里的index是0</span></span><br><span class="line">        Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">                originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">                client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用RealInterceptorChain的proceed方法，传进去originalRequest对象</span></span><br><span class="line">        <span class="keyword">return</span> chain.proceed(originalRequest);<span class="comment">//执行责任链，着重分析一下，okhttp的设计实现，如何通过责任链来进行传递返回数据的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//补充：可以看出5个拦截器都实现了Interceptor接口，这是okhttp最核心的部分，采用责任链的模式来使每个功能分开，每个Interceptor自行完成自己的任务，并且将不属于自己的任务交给下一个，简化了各自的责任和逻辑</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们就看5个拦截器的intercept方法即可了</p>
<p>Interceptor源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the connection the request will be executed on. This is only available in the chains</span></span><br><span class="line"><span class="comment">     * of network interceptors; for application interceptors this is always null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span> <span class="function">Connection <span class="title">connection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Call <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">connectTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Chain <span class="title">withConnectTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">readTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Chain <span class="title">withReadTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">writeTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Chain <span class="title">withWriteTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>RealInterceptorChain:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Chain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StreamAllocation streamAllocation;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpCodec httpCodec;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RealConnection connection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Request request;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Call call;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener eventListener;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> connectTimeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> readTimeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> writeTimeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> calls;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealInterceptorChain</span><span class="params">(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                HttpCodec httpCodec, RealConnection connection, <span class="keyword">int</span> index, Request request, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">                                EventListener eventListener, <span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.interceptors = interceptors;</span><br><span class="line">        <span class="keyword">this</span>.connection = connection;</span><br><span class="line">        <span class="keyword">this</span>.streamAllocation = streamAllocation;</span><br><span class="line">        <span class="keyword">this</span>.httpCodec = httpCodec;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">        <span class="keyword">this</span>.call = call;</span><br><span class="line">        <span class="keyword">this</span>.eventListener = eventListener;</span><br><span class="line">        <span class="keyword">this</span>.connectTimeout = connectTimeout;</span><br><span class="line">        <span class="keyword">this</span>.readTimeout = readTimeout;</span><br><span class="line">        <span class="keyword">this</span>.writeTimeout = writeTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">connection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">connectTimeoutMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connectTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Interceptor.<span class="function">Chain <span class="title">withConnectTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> millis = checkDuration(<span class="string">"timeout"</span>, timeout, unit);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">                request, call, eventListener, millis, readTimeout, writeTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readTimeoutMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Interceptor.<span class="function">Chain <span class="title">withReadTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> millis = checkDuration(<span class="string">"timeout"</span>, timeout, unit);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">                request, call, eventListener, connectTimeout, millis, writeTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeTimeoutMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> writeTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Interceptor.<span class="function">Chain <span class="title">withWriteTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> millis = checkDuration(<span class="string">"timeout"</span>, timeout, unit);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">                request, call, eventListener, connectTimeout, readTimeout, millis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StreamAllocation <span class="title">streamAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> streamAllocation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpCodec <span class="title">httpStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> httpCodec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Call <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> call;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventListener <span class="title">eventListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eventListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以看出interceptors，是传递到了RealInterceptorChain该类实现了Interceptor.Chain，并且执行了chain.proceed(originalRequest)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这样设计的一个好处就是，责任链中每个拦截器都会执行chain.proceed()方法之前的代码，等责任链最后一个拦截器执行完毕后会返回最终的响应数据，</span></span><br><span class="line"><span class="comment">     * 而chain.proceed() 方法会得到最终的响应数据，这时就会执行每个拦截器的chain.proceed()方法之后的代码，其实就是对响应数据的一些操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">        calls++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">                    + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">                    + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">        <span class="comment">// 创建新的拦截链，链中的拦截器集合index+1</span></span><br><span class="line">        <span class="comment">//关键代码：创建一个新的拦截器链next，注意这里的传参index=index+1</span></span><br><span class="line">        RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">                connection, index + <span class="number">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">                writeTimeout);</span><br><span class="line">        <span class="comment">//执行当前的拦截器-如果在配置OkHttpClient时没有设置intercept默认是先执行：retryAndFollowUpInterceptor 拦截器</span></span><br><span class="line">        Interceptor interceptor = interceptors.get(index);<span class="comment">//第一次index=0，获取的是RetryAndFollowUpInterceptor拦截器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行拦截器</span></span><br><span class="line">        Response response = interceptor.intercept(next);<span class="comment">//调用RetryAndFollowUpInterceptor的intercept方法，并将新创建的拦截器链next作为参数传进去</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在RetryAndFollowUpInterceptor.intercept(next)方法中有这样一段代码：</span></span><br><span class="line">        <span class="comment">// response = realChain.proceed(request, streamAllocation, null, null); 这里的realChain其实就是next对象，也就是新创建出来的index=index+1的拦截器对象</span></span><br><span class="line">        <span class="comment">//也就是说又回到了这个RealInterceptorChain中，执行了proceed方法，回顾proceed方法的作用！</span></span><br><span class="line">        <span class="comment">//作用就是创建一个新的拦截器next2,这里传的index=index+1</span></span><br><span class="line">        <span class="comment">//Interceptor interceptor = interceptors.get(index):获取BridgeInterceptor拦截器</span></span><br><span class="line">        <span class="comment">// Response response = interceptor.intercept(next)//调用BridgeInterceptor的intercept方法，并将新创建的拦截器链next2作为参数传进去</span></span><br><span class="line">        <span class="comment">//在BridgeInterceptor.intercept(next)方法中有这样一段代码：</span></span><br><span class="line">        <span class="comment">//Response networkResponse = chain.proceed(requestBuilder.build());这里的chain其实就是新创建的next2对象，也就是新创建出来的index=index+1的拦截器对象</span></span><br><span class="line">        <span class="comment">//也就是说又回到了这个RealInterceptorChain中，执行了proceed方法，回顾proceed方法的作用.......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">        <span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">                    + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line">        <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="RetryAndFollowUpInterceptor解析"><a href="#RetryAndFollowUpInterceptor解析" class="headerlink" title="RetryAndFollowUpInterceptor解析"></a>RetryAndFollowUpInterceptor解析</h2><p>提要：</p>
<blockquote>
<p>第一个需要掌握的拦截器！！<br>这个拦截器的主要功能就是负责失败重连的，可以在OkHttpClient进行配置的<br>这里需要注意的一点是并不是所有的请求都能进行失败重连的，是有一定的限制的<br>功能小结：</p>
<ol>
<li>创建StreamAllocation对象，该对象主要功能：是用来建立、执行HTTP请求所需要的网络组件，就是用来分配Stream</li>
<li>调用RealInterceptorChain.proceed(…)进行网络请</li>
<li>根据异常结果或者响应结果判断是否进行重新请求</li>
<li>调用下一个拦截，对response进行处理，返回给上一个拦截器</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryAndFollowUpInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,</span></span><br><span class="line"><span class="comment">     * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FOLLOW_UPS = <span class="number">20</span>;<span class="comment">//重试最大次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> forWebSocket;</span><br><span class="line">    <span class="keyword">private</span> StreamAllocation streamAllocation;</span><br><span class="line">    <span class="keyword">private</span> Object callStackTrace;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RetryAndFollowUpInterceptor</span><span class="params">(OkHttpClient client, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        canceled = <span class="keyword">true</span>;</span><br><span class="line">        StreamAllocation streamAllocation = <span class="keyword">this</span>.streamAllocation;</span><br><span class="line">        <span class="keyword">if</span> (streamAllocation != <span class="keyword">null</span>) streamAllocation.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canceled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallStackTrace</span><span class="params">(Object callStackTrace)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callStackTrace = callStackTrace;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StreamAllocation <span class="title">streamAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> streamAllocation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关键代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Call call = realChain.call();</span><br><span class="line">        EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建了StreamAllocation对象，StreamAllocation主要是用来建立、执行HTTP请求所需要的网络组件，StreamAllocation是在RetryAndFollowUpInterceptor拦截器创建，但是并没有真正使用</span></span><br><span class="line">        <span class="comment">//而是在ConnectInterceptor拦截器中用到。主要是用于获取连接服务端Connection连接和用于服务端数据传输的输入输出流。</span></span><br><span class="line">        streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">        Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// while (true)语句是处理重试和失败重连的核心逻辑***</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Response response;</span><br><span class="line">            <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行拦截器链的proceed方法，而RealInterceptorChain中proceed后有两个操作1.创建新的拦截器对象，2.调用下一个拦截器的intercept方法</span></span><br><span class="line">                <span class="comment">//这样找整个拦截器就完整的交替运行，最终就会把所有拦截器的功能都给完成</span></span><br><span class="line">                response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">                <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">                <span class="keyword">if</span> (!recover(e.getLastConnectException(), <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">                &#125;</span><br><span class="line">                releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">                <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">                <span class="keyword">if</span> (!recover(e, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">                releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></span><br><span class="line">                <span class="keyword">if</span> (releaseConnection) &#123;</span><br><span class="line">                    streamAllocation.streamFailed(<span class="keyword">null</span>);</span><br><span class="line">                    streamAllocation.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">            <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                response = response.newBuilder()</span><br><span class="line">                        .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                                .body(<span class="keyword">null</span>)</span><br><span class="line">                                .build())</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Request followUp = followUpRequest(response);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">                    streamAllocation.release();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//最大重连次数 20，如果超过20则会释放streamAllocation，并抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (followUp.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>, response.code());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">                        createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</span><br><span class="line">                        + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request = followUp;</span><br><span class="line">            priorResponse = response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BridgeInterceptor解析"><a href="#BridgeInterceptor解析" class="headerlink" title="BridgeInterceptor解析"></a>BridgeInterceptor解析</h2><p>提要：</p>
<blockquote>
<p>第二个拦截器<br>主要功能：设置内容长度Content-Length、编码方式、压缩、Cookie、User-Agent等请求头信息，其中Keep-Alive是复用的关键<br>小结：BridgeInterceptor核心过程</p>
<ol>
<li>是负责将用户构建的一个Request请求转化为能够进行网络访问的请求</li>
<li>将这个符合网络请求的Request进行网络请求</li>
<li>将网络请求返回来的响应Response转化为用户可以用的Response</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CookieJar cookieJar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BridgeInterceptor</span><span class="params">(CookieJar cookieJar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cookieJar = cookieJar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request userRequest = chain.request();</span><br><span class="line">        Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">        RequestBody body = userRequest.body();</span><br><span class="line">        <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">            MediaType contentType = body.contentType();</span><br><span class="line">            <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">            <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">                requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">                requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">                requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></span><br><span class="line">        <span class="comment">// the transfer stream.</span></span><br><span class="line">        <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">            requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">        <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">        <span class="comment">//转化成用户可以使用的Response</span></span><br><span class="line">        HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">        Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">                .request(userRequest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断处理</span></span><br><span class="line">        <span class="keyword">if</span> (transparentGzip</span><br><span class="line">                &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">                &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">            <span class="comment">//将Response body体的输入流转换为GzipSource，目的是调用者直接使用解压之后的数据</span></span><br><span class="line">            GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">            Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">                    .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">                    .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            responseBuilder.headers(strippedHeaders);</span><br><span class="line">            String contentType = networkResponse.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">            responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a 'Cookie' HTTP request header with all cookies, like &#123;<span class="doctag">@code</span> a=b; c=d&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">cookieHeader</span><span class="params">(List&lt;Cookie&gt; cookies)</span> </span>&#123;</span><br><span class="line">        StringBuilder cookieHeader = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = cookies.size(); i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cookieHeader.append(<span class="string">"; "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Cookie cookie = cookies.get(i);</span><br><span class="line">            cookieHeader.append(cookie.name()).append(<span class="string">'='</span>).append(cookie.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cookieHeader.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="CacheInterceptor解析"><a href="#CacheInterceptor解析" class="headerlink" title="CacheInterceptor解析"></a>CacheInterceptor解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> InternalCache cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheInterceptor</span><span class="params">(InternalCache cache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//尝试获取缓存信息,获取request对应缓存的Response 如果用户没有配置缓存拦截器 cacheCandidate == null</span></span><br><span class="line">        Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">                ? cache.get(chain.request())</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行响应缓存策略</span></span><br><span class="line">        <span class="comment">//CacheStrategy:缓存策略，是通过工厂类来获取缓存策略的</span></span><br><span class="line">        CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">        <span class="comment">//如果networkRequest == null 则说明不使用网络请求</span></span><br><span class="line">        Request networkRequest = strategy.networkRequest;</span><br><span class="line">        <span class="comment">//获取缓存中（CacheStrategy）的Response</span></span><br><span class="line">        Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果InternalCache cache不为null，</span></span><br><span class="line">            cache.trackResponse(strategy);<span class="comment">//如果有缓存的情况下，会更新一些缓存指标，主要是缓存的命中率</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缓存无效 关闭资源</span></span><br><span class="line">        <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当这个缓存不符合要的时候，我们就要把这个关掉</span></span><br><span class="line">            closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">        <span class="comment">//如果不能使用网络的时候，而且没有这个到缓存</span></span><br><span class="line">        <span class="comment">//networkRequest == null 不使用网路请求 且没有缓存 cacheResponse == null  返回失败</span></span><br><span class="line">        <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">                    .request(chain.request())</span><br><span class="line">                    .protocol(Protocol.HTTP_1_1)</span><br><span class="line">                    .code(<span class="number">504</span>)</span><br><span class="line">                    .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">                    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we don't need the network, we're done.</span></span><br><span class="line">        <span class="comment">//不使用网络请求 且存在缓存 直接返回响应</span></span><br><span class="line">        <span class="comment">//判断如果有缓存，但是不能使用网络的时候，直接返回缓存结果</span></span><br><span class="line">        <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">                    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         上述的代码，主要做了几件事：</span></span><br><span class="line"><span class="comment">         1. 如果用户自己配置了缓存拦截器，cacheCandidate = cache.Response 获取用户自己存储的Response,否则 cacheCandidate = null;同时从CacheStrategy 获取cacheResponse 和 networkRequest</span></span><br><span class="line"><span class="comment">         2. 如果cacheCandidate ！= null 而 cacheResponse == null 说明缓存无效清除cacheCandidate缓存。</span></span><br><span class="line"><span class="comment">         3. 如果networkRequest == null 说明没有网络，cacheResponse == null 没有缓存，返回失败的信息，责任链此时也就终止，不会在往下继续执行。</span></span><br><span class="line"><span class="comment">         4. 如果networkRequest == null 说明没有网络，cacheResponse != null 有缓存，返回缓存的信息，责任链此时也就终止，不会在往下继续执行。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//----------------------------------------上部分代码，其实就是没有网络的时候的处理----------------------------------------</span></span><br><span class="line">        <span class="comment">//----------------------------------------那么下部分代码肯定是，有网络的时候处理----------------------------------------</span></span><br><span class="line"></span><br><span class="line">        Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//执行下一个拦截器</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用proceed方法进行网络数据的获取</span></span><br><span class="line">            networkResponse = chain.proceed(networkRequest);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">            <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                closeQuietly(cacheCandidate.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//网络请求 回来 更新缓存</span></span><br><span class="line">        <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class="line">        <span class="comment">// 如果存在缓存 更新</span></span><br><span class="line">        <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断响应码是否是304,自从上次请求后，请求需要响应的内容未发生改变</span></span><br><span class="line">            <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">                Response response = cacheResponse.newBuilder()</span><br><span class="line">                        .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                        .networkResponse(stripBody(networkResponse))</span><br><span class="line">                        .build();</span><br><span class="line">                networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">                <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">                cache.trackConditionalCacheHit();</span><br><span class="line">                cache.update(cacheResponse, response);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                closeQuietly(cacheResponse.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缓存Response</span></span><br><span class="line">        Response response = networkResponse.newBuilder()</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .networkResponse(stripBody(networkResponse))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断Http头部有没有响应体，并且缓存策略是可以被缓存的</span></span><br><span class="line">            <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">                <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">                CacheRequest cacheRequest = cache.put(response);<span class="comment">//将网络响应返回写入到缓存当中</span></span><br><span class="line">                <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断这个Request是否是一个无效的缓存方法</span></span><br><span class="line">            <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cache.remove(networkRequest);<span class="comment">//移除这个无效的缓存方法</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                    <span class="comment">// The cache cannot be written.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          下部分代码主要做了这几件事：</span></span><br><span class="line"><span class="comment">          1. 执行下一个拦截器，也就是请求网络</span></span><br><span class="line"><span class="comment">          2. 责任链执行完毕后，会返回最终响应数据，如果缓存存在更新缓存，如果缓存不存在加入到缓存中去。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          这样就体现出了，责任链这样实现的好处了，当责任链执行完毕，如果拦截器想要拿到最终的数据做其他的逻辑处理等，这样就不用在做其他的调用方法逻辑了，直接在当前的拦截器就可以拿到最终的数据。</span></span><br><span class="line"><span class="comment">          这也是okhttp设计的最优雅最核心的功能</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>CacheStrategy内部维护了一个Request和Response，可以指定是使用Request还是Response，到底是通过网络呢，还是通过缓存来获取我们的Response</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheStrategy</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//这里就是时间创建CacheStrategy对象的地方</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// No cached response.</span></span><br><span class="line">      <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Drop the cached response if it's missing a required handshake.</span></span><br><span class="line">      <span class="comment">//判断是否是https请求，并且这个缓存响应中有没有经过handshake握手操作了</span></span><br><span class="line">      <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If this response shouldn't have been stored, it should never be used</span></span><br><span class="line">      <span class="comment">// as a response source. This check should be redundant as long as the</span></span><br><span class="line">      <span class="comment">// persistence store is well-behaved and the rules are constant.</span></span><br><span class="line">      <span class="comment">//判断这个响应该不该被存储</span></span><br><span class="line">      <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      CacheControl requestCaching = request.cacheControl();</span><br><span class="line">      <span class="comment">//判断是不是需要缓存</span></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line">      <span class="comment">//判断这个是不是受影响的</span></span><br><span class="line">      <span class="keyword">if</span> (responseCaching.immutable()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, cacheResponse);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">      <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//添加一些请求头的操作</span></span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"110 HttpURLConnection \"Response is stale\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"113 HttpURLConnection \"Heuristic expiration\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Find a condition to add to the request. If the condition is satisfied, the response body</span></span><br><span class="line">      <span class="comment">// will not be transmitted.</span></span><br><span class="line">      String conditionName;</span><br><span class="line">      String conditionValue;</span><br><span class="line">      <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">"If-None-Match"</span>;</span><br><span class="line">        conditionValue = etag;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">"If-Modified-Since"</span>;</span><br><span class="line">        conditionValue = lastModifiedString;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">"If-Modified-Since"</span>;</span><br><span class="line">        conditionValue = servedDateString;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>); <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</span><br><span class="line">      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line"></span><br><span class="line">      Request conditionalRequest = request.newBuilder()</span><br><span class="line">          .headers(conditionalRequestHeaders.build())</span><br><span class="line">          .build();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConnectInterceptor解析"><a href="#ConnectInterceptor解析" class="headerlink" title="ConnectInterceptor解析"></a>ConnectInterceptor解析</h2><p>提要：</p>
<blockquote>
<p>ConnectInterceptor作用：打开与服务器的链接，正式开启OkHttp网络请求<br>小结：</p>
<ol>
<li>ConnectInterceptor获取Interceptor传过来的StreamAllocation，</li>
<li>HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</li>
<li>RealConnection connection = streamAllocation.connection();</li>
<li>将上述创建的用于网络IO的RealConnection对象以及对于与服务器最为关键的HttpCodec等对象传递给后面的拦截器</li>
</ol>
<hr>
<ol>
<li>弄一个RealConnection对象</li>
<li>选择不同的链接方式：隧道和Socket</li>
<li>最后调用最后一个拦截器CallServerInterceptor（前提是在这中间没有设置NetWorkInterceptor）</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectInterceptor</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        <span class="comment">//streamAllocation其实是在第一个拦截器RetryAndFollowUpInterceptor创建的</span></span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">        <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">        <span class="comment">//HttpCodec作用：编码Request解码Response，着重分析一下newStream方法</span></span><br><span class="line">        HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">        <span class="comment">//RealConnection :这个很重要，就是实际进行网络IO传输的</span></span><br><span class="line">        RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将httpCodec connection传递给后面的拦截器</span></span><br><span class="line">        <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里涉及到了StreamAllocation，我们来看下他的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAllocation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> RouteSelector.Selection routeSelection;</span><br><span class="line">    <span class="keyword">private</span> Route route;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConnectionPool connectionPool;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Call call;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> EventListener eventListener;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object callStackTrace;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// State guarded by connectionPool.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteSelector routeSelector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> refusedStreamCount;</span><br><span class="line">    <span class="keyword">private</span> RealConnection connection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> reportedAcquired;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> released;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> canceled;</span><br><span class="line">    <span class="keyword">private</span> HttpCodec codec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StreamAllocation</span><span class="params">(ConnectionPool connectionPool, Address address, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EventListener eventListener, Object callStackTrace)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionPool = connectionPool;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.call = call;</span><br><span class="line">        <span class="keyword">this</span>.eventListener = eventListener;</span><br><span class="line">        <span class="keyword">this</span>.routeSelector = <span class="keyword">new</span> RouteSelector(address, routeDatabase(), call, eventListener);</span><br><span class="line">        <span class="keyword">this</span>.callStackTrace = callStackTrace;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 调用findHealthyConnection方法生成RealConnection对象</span></span><br><span class="line"><span class="comment">     * 2. 通过获取的RealConnection对象来生成HttpCodec，并在同步代码块中返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> connectTimeout = chain.connectTimeoutMillis();</span><br><span class="line">        <span class="keyword">int</span> readTimeout = chain.readTimeoutMillis();</span><br><span class="line">        <span class="keyword">int</span> writeTimeout = chain.writeTimeoutMillis();</span><br><span class="line">        <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">                    writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">            HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">                codec = resultCodec;</span><br><span class="line">                <span class="keyword">return</span> resultCodec;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated</span></span><br><span class="line"><span class="comment">     * until a healthy connection is found.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">int</span> writeTimeout, <span class="keyword">boolean</span> connectionRetryEnabled, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">                    connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">                <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;<span class="comment">//这句话表示整个网络连接结束了</span></span><br><span class="line">                    <span class="keyword">return</span> candidate;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span></span><br><span class="line">            <span class="comment">// isn't, take it out of the pool and start again.</span></span><br><span class="line">            <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">                noNewStreams();<span class="comment">//如果是不健康的，则就会调用销毁工作</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a connection to host a new stream. This prefers the existing connection if it exists,</span></span><br><span class="line"><span class="comment">     * then the pool, finally building a new connection.</span></span><br><span class="line"><span class="comment">     * 1. 尝试获取connection，如果能复用则复用，不能则会在连接池中获取新的realConnection进行连接</span></span><br><span class="line"><span class="comment">     * 2. 最后要将新的connection放回到连接池中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> foundPooledConnection = <span class="keyword">false</span>;</span><br><span class="line">        RealConnection result = <span class="keyword">null</span>;</span><br><span class="line">        Route selectedRoute = <span class="keyword">null</span>;</span><br><span class="line">        Connection releasedConnection;</span><br><span class="line">        Socket toClose;</span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            <span class="keyword">if</span> (released) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"released"</span>);</span><br><span class="line">            <span class="keyword">if</span> (codec != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"codec != null"</span>);</span><br><span class="line">            <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Attempt to use an already-allocated connection. We need to be careful here because our</span></span><br><span class="line">            <span class="comment">// already-allocated connection may have been restricted from creating new streams.</span></span><br><span class="line">            releasedConnection = <span class="keyword">this</span>.connection;<span class="comment">//尝试复用整个connection</span></span><br><span class="line">            toClose = releaseIfNoNewStreams();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// We had an already-allocated connection and it's good.</span></span><br><span class="line">                result = <span class="keyword">this</span>.connection;</span><br><span class="line">                releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!reportedAcquired) &#123;</span><br><span class="line">                <span class="comment">// If the connection was never reported acquired, don't report it as released!</span></span><br><span class="line">                releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;<span class="comment">//如果不能复用，则需要在连接池里面获取一个连接</span></span><br><span class="line">                <span class="comment">// Attempt to get a connection from the pool.</span></span><br><span class="line">                Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">                    result = connection;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    selectedRoute = route;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        closeQuietly(toClose);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (releasedConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventListener.connectionReleased(call, releasedConnection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">            eventListener.connectionAcquired(call, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we found an already-allocated or pooled connection, we're done.</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we need a route selection, make one. This is a blocking operation.</span></span><br><span class="line">        <span class="keyword">boolean</span> newRouteSelection = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span> &amp;&amp; (routeSelection == <span class="keyword">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">            newRouteSelection = <span class="keyword">true</span>;</span><br><span class="line">            routeSelection = routeSelector.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">                <span class="comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class="line">                <span class="comment">// the pool. This could match due to connection coalescing.</span></span><br><span class="line">                List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class="line">                    Route route = routes.get(i);</span><br><span class="line">                    Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, route);</span><br><span class="line">                    <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">                        result = connection;</span><br><span class="line">                        <span class="keyword">this</span>.route = route;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    selectedRoute = routeSelection.next();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class="line">                <span class="comment">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span></span><br><span class="line">                route = selectedRoute;</span><br><span class="line">                refusedStreamCount = <span class="number">0</span>;</span><br><span class="line">                result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">                acquire(result, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we found a pooled connection on the 2nd time around, we're done.</span></span><br><span class="line">        <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">            eventListener.connectionAcquired(call, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class="line">        <span class="comment">//获取了connection之后，调用connect进行实际的网络连接</span></span><br><span class="line">        result.connect(</span><br><span class="line">                connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);</span><br><span class="line">        routeDatabase().connected(result.route());</span><br><span class="line"></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            reportedAcquired = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Pool the connection.</span></span><br><span class="line">            Internal.instance.put(connectionPool, result);<span class="comment">//获取完之后将，connection放入到连接池中</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// If another multiplexed connection to the same address was created concurrently, then</span></span><br><span class="line">            <span class="comment">// release this connection and acquire that one.</span></span><br><span class="line">            <span class="keyword">if</span> (result.isMultiplexed()) &#123;</span><br><span class="line">                socket = Internal.instance.deduplicate(connectionPool, address, <span class="keyword">this</span>);</span><br><span class="line">                result = connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        closeQuietly(socket);</span><br><span class="line"></span><br><span class="line">        eventListener.connectionAcquired(call, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Forbid new streams from being created on the connection that hosts this allocation.</span></span><br><span class="line"><span class="comment">     * 禁止新的流创建，里面的操作就是关闭socket流、关闭Connection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noNewStreams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Socket socket;</span><br><span class="line">        Connection releasedConnection;</span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            releasedConnection = connection;</span><br><span class="line">            socket = deallocate(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        closeQuietly(socket);</span><br><span class="line">        <span class="keyword">if</span> (releasedConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventListener.connectionReleased(call, releasedConnection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use this allocation to hold &#123;<span class="doctag">@code</span> connection&#125;. Each call to this must be paired with a call to</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #release&#125; on the same connection.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(RealConnection connection, <span class="keyword">boolean</span> reportedAcquired)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.connection = connection;<span class="comment">//把在ConnectionPool连接池中获取可用的RealConnection赋值给StreamAllocation的成员变量connection</span></span><br><span class="line">        <span class="keyword">this</span>.reportedAcquired = reportedAcquired;</span><br><span class="line">        connection.allocations.add(<span class="keyword">new</span> StreamAllocationReference(<span class="keyword">this</span>, callStackTrace));</span><br><span class="line">        <span class="comment">//将StreamAllocation的弱引用加入到RealConnection对象中有一个allocations集合当中</span></span><br><span class="line">        <span class="comment">//为什么这么做？就是为了根据RealConnection对象的allocations集合能判断当前链接对象所持有StreamAllocation的数量</span></span><br><span class="line">        <span class="comment">//通过集合的大小来判定一个网络链接的负载量是否超过最大值</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>RealConnection:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealConnection</span> <span class="keyword">extends</span> <span class="title">Http2Connection</span>.<span class="title">Listener</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BufferedSource source;</span><br><span class="line">    <span class="keyword">private</span> BufferedSink sink;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行实际的网络连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">boolean</span> connectionRetryEnabled, Call call, EventListener eventListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"already connected"</span>);<span class="comment">//检查这个连接是否已经建立了，如果建立了则会抛出异常</span></span><br><span class="line"></span><br><span class="line">        RouteException routeException = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;ConnectionSpec&gt; connectionSpecs = route.address().connectionSpecs();</span><br><span class="line">        <span class="comment">//ConnectionSpecSelector：用于创建选择连接的。在OkHttp中有两种，隧道连接和Socket连接，区别在高级课中会讲解</span></span><br><span class="line">        ConnectionSpecSelector connectionSpecSelector = <span class="keyword">new</span> ConnectionSpecSelector(connectionSpecs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (route.address().sslSocketFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</span><br><span class="line">                        <span class="string">"CLEARTEXT communication not enabled for client"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            String host = route.address().url().host();</span><br><span class="line">            <span class="keyword">if</span> (!Platform.get().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</span><br><span class="line">                        <span class="string">"CLEARTEXT communication to "</span> + host + <span class="string">" not permitted by network security policy"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (route.requiresTunnel()) &#123;<span class="comment">//while循环判断是否创建tunnel这个隧道来进行连接</span></span><br><span class="line">                    connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);</span><br><span class="line">                    <span class="keyword">if</span> (rawSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// We were unable to connect the tunnel but properly closed down our resources.</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">                &#125;</span><br><span class="line">                establishProtocol(connectionSpecSelector, call, eventListener);</span><br><span class="line">                eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                closeQuietly(socket);</span><br><span class="line">                closeQuietly(rawSocket);</span><br><span class="line">                socket = <span class="keyword">null</span>;</span><br><span class="line">                rawSocket = <span class="keyword">null</span>;</span><br><span class="line">                source = <span class="keyword">null</span>;</span><br><span class="line">                sink = <span class="keyword">null</span>;</span><br><span class="line">                handshake = <span class="keyword">null</span>;</span><br><span class="line">                protocol = <span class="keyword">null</span>;</span><br><span class="line">                http2Connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                eventListener.connectFailed(call, route.socketAddress(), route.proxy(), <span class="keyword">null</span>, e);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (routeException == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    routeException = <span class="keyword">new</span> RouteException(e);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    routeException.addConnectException(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> routeException;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (route.requiresTunnel() &amp;&amp; rawSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ProtocolException exception = <span class="keyword">new</span> ProtocolException(<span class="string">"Too many tunnel connections attempted: "</span></span><br><span class="line">                    + MAX_TUNNEL_ATTEMPTS);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(exception);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (http2Connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">                allocationLimit = http2Connection.maxConcurrentStreams();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="CallServerInterceptor解析"><a href="#CallServerInterceptor解析" class="headerlink" title="CallServerInterceptor解析"></a>CallServerInterceptor解析</h2><p>提要：</p>
<blockquote>
<p>两个作用</p>
<ol>
<li>发起真正的网络请求</li>
<li>接受服务端给我们的响应</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallServerInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> forWebSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallServerInterceptor</span><span class="params">(<span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. httpCodec.writeRequestHeaders(request);//向socket流当中写入请求头部信息</span></span><br><span class="line"><span class="comment">     * 2. request.body().writeTo(bufferedRequestBody);//向socket写入body信息</span></span><br><span class="line"><span class="comment">     * 3. httpCodec.finishRequest();//表示整个网络请求的写入工作已经完成了，接下里就可以读取了</span></span><br><span class="line"><span class="comment">     * 4. responseBuilder = httpCodec.readResponseHeaders(false);//读取网络响应的头部信息</span></span><br><span class="line"><span class="comment">     * 5. response = response.newBuilder().body(httpCodec.openResponseBody(response)).build();//读取网络响应的body信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;<span class="comment">//OkHttp的拦截器链</span></span><br><span class="line">        HttpCodec httpCodec = realChain.httpStream();<span class="comment">//所有的流对象都封装成了HttpCodec对象，有两个实现类Http1Codec和Http2Codec</span></span><br><span class="line">        <span class="comment">//Http1Codec有两个重要的成员变量BufferedSource source和BufferedSink sink分别代表了socket的输入和输出，而CallServerInterceptor就是通过Http1Codec当中的socket流来完成操作的</span></span><br><span class="line">        <span class="comment">//HttpCodec简单理解一下就是编码Request和解码Response</span></span><br><span class="line"></span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">        <span class="comment">//streamAllocation:分配Stream,建立Http请求所需要的其他网络组件</span></span><br><span class="line"></span><br><span class="line">        RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">        <span class="comment">//我们将客户端和服务器的链接抽象成了Connection，而RealConnection就是Connection的具体实现</span></span><br><span class="line"></span><br><span class="line">        Request request = realChain.request();<span class="comment">//代表网络请求</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class="line">        httpCodec.writeRequestHeaders(request);<span class="comment">//向socket流当中写入请求头部信息</span></span><br><span class="line">        realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class="line"></span><br><span class="line">        Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span></span><br><span class="line">            <span class="comment">// Continue" response before transmitting the request body. If we don't get that, return</span></span><br><span class="line">            <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">            <span class="comment">//这是一个特殊的请求判断，正常情况下不一定会到这一步</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">                httpCodec.flushRequest();</span><br><span class="line">                realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">                responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">                realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">                <span class="keyword">long</span> contentLength = request.body().contentLength();</span><br><span class="line">                CountingSink requestBodyOut =</span><br><span class="line">                        <span class="keyword">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line"></span><br><span class="line">                request.body().writeTo(bufferedRequestBody);<span class="comment">//向socket写入body信息</span></span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">                realChain.eventListener()</span><br><span class="line">                        .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">                <span class="comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class="line">                <span class="comment">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class="line">                <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">                streamAllocation.noNewStreams();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        httpCodec.finishRequest();<span class="comment">//表明了整个网络工作的写入工作已经完成了，接下里就可以读取了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);<span class="comment">//读取网络响应的头部信息</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response response = responseBuilder</span><br><span class="line">                .request(request)</span><br><span class="line">                .handshake(streamAllocation.connection().handshake())</span><br><span class="line">                .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        realChain.eventListener()</span><br><span class="line">                .responseHeadersEnd(realChain.call(), response);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> code = response.code();</span><br><span class="line">        <span class="comment">//读取网络响应的body信息，分情况</span></span><br><span class="line">        <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">            <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个response体</span></span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(httpCodec.openResponseBody(response))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">                || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">            streamAllocation.noNewStreams();<span class="comment">//为什么会调用noNewStreams方法，禁止新的流创建，里面的操作就是关闭socket流、关闭Connection</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">                    <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSink</span> <span class="keyword">extends</span> <span class="title">ForwardingSink</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> successfulCount;</span><br><span class="line"></span><br><span class="line">        CountingSink(Sink delegate) &#123;</span><br><span class="line">            <span class="keyword">super</span>(delegate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Buffer source, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.write(source, byteCount);</span><br><span class="line">            successfulCount += byteCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>END.</p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/OkHttp/">OkHttp</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/vxo/img/raw/master/blog/20200622205247.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/18/%E3%80%90%E8%BD%AC%E3%80%91Base64%E7%BC%96%E7%A0%81%E8%AF%A6%E8%A7%A3/"><img class="prev_cover lazyload" data-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1589776334778&amp;di=5e91c48c19fd81567d2ec819db194fe8&amp;imgtype=0&amp;src=http%3A%2F%2Fp0.ssl.cdn.btime.com%2Ft012a10b4a17e01d14d.jpg%3Fsize%3D512x512" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【转】Base64编码详解</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/13/%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD%E6%B1%87%E6%80%BB/"><img class="next_cover lazyload" data-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1589358596541&amp;di=ec2608777052785cb20f0d366f2d82b7&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170830%2F544fed872efd40a5acf7ebcec0067fc1.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">开发技能汇总</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/25/Android源码分析——Dagger2（未完）/" title="Android源码分析——Dagger2（未完）"><img class="relatedPosts_cover lazyload"data-src="https://img.cniao5.com/o_1b3rl8h6mk8d162i1i0p1ha6p989.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-25</div><div class="relatedPosts_title">Android源码分析——Dagger2（未完）</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/18/Android源码分析——Retrofit/" title="Android源码分析——Retrofit"><img class="relatedPosts_cover lazyload"data-src="https://img.cniao5.com/o_1avp1uvsgh7irrvv158jn7mf9.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-18</div><div class="relatedPosts_title">Android源码分析——Retrofit</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/21/Android源码分析——Glide/" title="Android源码分析——Glide"><img class="relatedPosts_cover lazyload"data-src="http://inthecheesefactory.com/uploads/source/glidepicasso/cover.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-21</div><div class="relatedPosts_title">Android源码分析——Glide</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/21/博文地址推荐/" title="博文地址推荐"><img class="relatedPosts_cover lazyload"data-src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1591889554697&di=6cd48317171455e6e367313f3430a2e2&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20180717%2Fab8a30734c7f45ad847ca089864e25e4.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-21</div><div class="relatedPosts_title">博文地址推荐</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/13/开发技能汇总/" title="开发技能汇总"><img class="relatedPosts_cover lazyload"data-src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1589358596541&di=ec2608777052785cb20f0d366f2d82b7&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170830%2F544fed872efd40a5acf7ebcec0067fc1.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-13</div><div class="relatedPosts_title">开发技能汇总</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/25/Android源码分析——EventBus/" title="Android源码分析——EventBus"><img class="relatedPosts_cover lazyload"data-src="https://img-blog.csdnimg.cn/20181208105518324.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-25</div><div class="relatedPosts_title">Android源码分析——EventBus</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Kai</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>