<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android源码分析——EventBus | K的小屋</title><meta name="description" content="Android源码分析——EventBus"><meta name="keywords" content="Android,EventBus"><meta name="author" content="Kai"><meta name="copyright" content="Kai"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Android源码分析——EventBus"><meta name="twitter:description" content="Android源码分析——EventBus"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/20181208105518324.png"><meta property="og:type" content="article"><meta property="og:title" content="Android源码分析——EventBus"><meta property="og:url" content="https://www.google.com/2020/05/25/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94EventBus/"><meta property="og:site_name" content="K的小屋"><meta property="og:description" content="Android源码分析——EventBus"><meta property="og:image" content="https://img-blog.csdnimg.cn/20181208105518324.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://www.google.com/2020/05/25/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94EventBus/"><link rel="prev" title="Android源码分析——Dagger2（未完）" href="https://www.google.com/2020/05/25/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Dagger2%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/"><link rel="next" title="Git的基本使用" href="https://www.google.com/2020/05/21/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-number">1.</span> <span class="toc-text">参考文章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请求流程"><span class="toc-number">2.</span> <span class="toc-text">请求流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventBus简介"><span class="toc-number">3.</span> <span class="toc-text">EventBus简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础概念"><span class="toc-number">4.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler通信"><span class="toc-number">5.</span> <span class="toc-text">Handler通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#两个案例"><span class="toc-number">5.1.</span> <span class="toc-text">两个案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventBus简单使用"><span class="toc-number">6.</span> <span class="toc-text">EventBus简单使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventBus源码分析"><span class="toc-number">7.</span> <span class="toc-text">EventBus源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#整体类关系图"><span class="toc-number">7.1.</span> <span class="toc-text">整体类关系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getDefault"><span class="toc-number">7.2.</span> <span class="toc-text">getDefault()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus-java"><span class="toc-number">7.2.1.</span> <span class="toc-text">EventBus.java</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBusBuilder-java"><span class="toc-number">7.2.2.</span> <span class="toc-text">EventBusBuilder.java</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#register"><span class="toc-number">7.3.</span> <span class="toc-text">register()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Subscribe-java注解"><span class="toc-number">7.3.1.</span> <span class="toc-text">Subscribe.java注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SubscriberMethodFinder-java"><span class="toc-number">7.3.2.</span> <span class="toc-text">SubscriberMethodFinder.java</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SubscriberMethod-java"><span class="toc-number">7.3.3.</span> <span class="toc-text">SubscriberMethod.java</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#subscribe"><span class="toc-number">7.3.4.</span> <span class="toc-text">subscribe()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Subscription-java"><span class="toc-number">7.3.5.</span> <span class="toc-text">Subscription.java</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unregister"><span class="toc-number">7.4.</span> <span class="toc-text">unregister()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#post"><span class="toc-number">7.5.</span> <span class="toc-text">post()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadMode-java"><span class="toc-number">7.5.1.</span> <span class="toc-text">ThreadMode.java</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#粘性事件发布"><span class="toc-number">7.6.</span> <span class="toc-text">粘性事件发布</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://img-blog.csdnimg.cn/20181208105518324.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">K的小屋</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Android源码分析——EventBus</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-25 15:48:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-25</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-26 15:34:55"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-26</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">14k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 53 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<p><a href="https://www.jianshu.com/p/f057c460c77e" target="_blank" rel="noopener">https://www.jianshu.com/p/f057c460c77e</a></p>
<p><a href="https://kymjs.com/code/2015/12/12/01/" target="_blank" rel="noopener">https://kymjs.com/code/2015/12/12/01/</a></p>
<p><a href="https://www.jianshu.com/p/aced2b292cf9" target="_blank" rel="noopener">https://www.jianshu.com/p/aced2b292cf9</a></p>
<p><a href="https://github.com/wangzhengyi/EventBusAnalysis" target="_blank" rel="noopener">https://github.com/wangzhengyi/EventBusAnalysis</a></p>
<p><a href="https://blog.csdn.net/linh0911111026/article/details/78922425" target="_blank" rel="noopener">https://blog.csdn.net/linh0911111026/article/details/78922425</a></p>
<p><a href="https://www.cmonbaby.com/posts/netease_eventbus.html" target="_blank" rel="noopener">https://www.cmonbaby.com/posts/netease_eventbus.html</a></p>
</blockquote>
<h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>使用版本：’org.greenrobot:eventbus:3.0.0’</p>
<h2 id="EventBus简介"><a href="#EventBus简介" class="headerlink" title="EventBus简介"></a>EventBus简介</h2><p>EventBus是一种用于Android的事件发布-订阅总线，由GreenRobot开发，Gihub地址是：<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus</a>。它简化了应用程序内各个组件之间进行通信的复杂度，尤其是碎片之间进行通信的问题，可以避免由于使用广播通信而带来的诸多不便。</p>
<ol>
<li>EventBus是Android时间发布/订阅框架</li>
<li>时间传递既可以用于四大组件间的通信，也可以线程间通信</li>
<li>EventBus的有点是代码简介，使用简单，并将事件发布和订阅充分解耦</li>
</ol>
<blockquote>
<p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus</a> 是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent, Handler, BroadCast 在 Fragment，Activity，Service，线程之间传递消息.优点是开销小，使用方便,可以很大程度上降低它们之间的耦合，使得我们的代码更加简洁，耦合性更低，提升我们的代码质量。<br>类似的库还有 <a href="https://github.com/square/otto" target="_blank" rel="noopener">Otto</a> ,今天就带大家一起研读 EventBus 的源码.</p>
</blockquote>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>EventBus是一个Android<strong>事件发布/订阅</strong>框架，通过解耦发布者和订阅者简化Android事件传递。事件传递既可以用于Android四大组件间的通讯，也可以用于用户异步线程和主线程间通讯等。 传统的事件传递方法包括：Handler，BroadCastReceiver，interface回调。但是EventBus的代码更加简洁，代码简单，而且事件发布和订阅充分解耦。</p>
<p> 基本概念如下:</p>
<ul>
<li><strong>事件(Event)</strong>: 可以称为消息,其实就是一个对象.<strong>事件类型(EventType)</strong>指事件所属的Class.</li>
<li><strong>订阅者(Subscriber)</strong>: 订阅某种事件类型的对象.当有发布者发布这类事件后,EventBus会执行订阅者的被Subscribe注解修饰的函数,这个函数叫<strong>事件响应函数</strong>.订阅者通过register接口订阅某个事件类型,unregister接口退订.订阅者存在优先级,优先级高的订阅者可以取消事件继续向优先级低的订阅者分发,默认所有订阅者优先级都为0.</li>
<li><strong>发布者(Publisher)</strong>: 发布某事件的对象,通过EventBus.getDefault.post方法发布事件.</li>
</ul>
<h2 id="Handler通信"><a href="#Handler通信" class="headerlink" title="Handler通信"></a>Handler通信</h2><p>回顾Handler机制：</p>
<p><img src="/" class="lazyload" data-src="/img/eventbus_assets/1590374429884.png"  alt="1590374429884"></p>
<h3 id="两个案例"><a href="#两个案例" class="headerlink" title="两个案例"></a>两个案例</h3><p>UI线程给子线程发送消息&amp;子线程给UI线程发送消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示Handler发送消息的两种情况</span></span><br><span class="line"><span class="comment"> * ①：UI--&gt;Work线程</span></span><br><span class="line"><span class="comment"> * ②：Work--&gt;UI线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String TAG = <span class="string">"HandlerActivity"</span>;</span><br><span class="line">    <span class="meta">@BindView</span>(R.id.tv_result)</span><br><span class="line">    TextView textView;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler threadHandler;</span><br><span class="line">    <span class="keyword">private</span> Handler uiHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"收到消息--&gt;"</span> + msg.arg1 + <span class="string">","</span> + msg.obj + <span class="string">"，线程："</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main_eventbus_handler);</span><br><span class="line">        ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * UI线程--&gt;子线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ui</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Message msg = threadHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = <span class="number">1</span>;</span><br><span class="line">        msg.obj = <span class="string">"ui线程发送给work线程的消息"</span>;</span><br><span class="line">        threadHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子线程--&gt;UI线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thread</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Message msg = uiHandler.obtainMessage();</span><br><span class="line">                msg.arg1 = <span class="number">2</span>;</span><br><span class="line">                msg.obj = <span class="string">"work线程发送给ui线程的消息"</span>;</span><br><span class="line">                uiHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Looper.prepare();</span><br><span class="line">            threadHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">                    String str = <span class="string">"收到消息--&gt;"</span> + msg.arg1 + <span class="string">","</span> + msg.obj + <span class="string">"，线程："</span> + Thread.currentThread().getName();</span><br><span class="line">                    Log.d(TAG, str);</span><br><span class="line">                    <span class="comment">//textView.setText(str);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Looper.loop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="EventBus简单使用"><a href="#EventBus简单使用" class="headerlink" title="EventBus简单使用"></a>EventBus简单使用</h2><p><img src="/" class="lazyload" data-src="/img/eventbus_assets/1590374975875.png"  alt="1590374975875"></p>
<p>EventBus用法：</p>
<ol>
<li>定义事件</li>
<li>准备订阅者，使用注解@Subscribe</li>
<li>订阅者同时需要在总线上注册和注销自己<ol>
<li>EventBus.getDefault().register(this);</li>
</ol>
</li>
<li>发送事件，任何地方，无论是主线程还是子线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EventBus用法：</span></span><br><span class="line"><span class="comment"> * 1. 定义事件</span></span><br><span class="line"><span class="comment"> * 2. 准备订阅者，使用注解<span class="doctag">@Subscribe</span></span></span><br><span class="line"><span class="comment"> * 3. 订阅者同时需要在总线上注册和注销自己</span></span><br><span class="line"><span class="comment"> * 4. 发送事件，任何地方，无论是主线程还是子线程</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 思考：</span></span><br><span class="line"><span class="comment"> * 1. 在EventBus中，使用<span class="doctag">@Subscribe</span>注解的时候指定的ThreadMode是如何实现在不同线程间传递数据的？</span></span><br><span class="line"><span class="comment"> * 2. 使用注解和反射的时候的效率问题，是否会像Guava的EventBus一样有缓存优化？</span></span><br><span class="line"><span class="comment"> * 3. 黏性事件是否是通过内部维护了之前发布的数据来实现的，是否使用了缓存？</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 回答：</span></span><br><span class="line"><span class="comment"> * 1.要求主线程中的事件通过Handler来实现在主线程中执行，非主线程的方法会使用EventBus内部的ExecutorService来执行。</span></span><br><span class="line"><span class="comment"> * 实际在触发方法的时候会根据当前线程的状态和订阅方法的ThreadMode指定的线程状态来决定何时触发方法。</span></span><br><span class="line"><span class="comment"> * 非主线程的逻辑会在post的时候加入到一个队列中被随后执行。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 2. 内部使用了缓存，确切来说就是维护了一些映射的关系。但是它的缓存没有像Guava一样使用软引用之类方式进行优化，即一直是强引用类型的。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 3. 黏性事件会通过EventBus内部维护的一个[事件类型-黏性事件]的哈希表存储，当注册一个观察者的时候，如果发现了它内部有黏性事件监听，</span></span><br><span class="line"><span class="comment"> * 会执行post类似的逻辑将事件立即发送给该观察者。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 注册流程：</span></span><br><span class="line"><span class="comment"> * 订阅者向EventBus注册时,自身首先需要完成两件事情:</span></span><br><span class="line"><span class="comment"> * 1. 订阅者本身需要声明只有一个参数的public方法,并且使用Subscribe进行注解.</span></span><br><span class="line"><span class="comment"> * 2. 订阅者需要调用EventBus的register方法进行注册.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    String TAG = <span class="string">"EVENT BUS"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindView</span>(R.id.tv_result)</span><br><span class="line">    TextView mTvResult;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main_eventbus);</span><br><span class="line">        ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        <span class="comment">/* 注册当前订阅者类. */</span></span><br><span class="line">        EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        <span class="comment">//取消注册其实就是为了从订阅者-订阅事件这两个双向集合[subscriptionsByEventType,typesBySubscriber]中删除相应的对象,可以避免内存泄露.</span></span><br><span class="line">        EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClick</span>(R.id.send_msg)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventBus.getDefault().post(<span class="keyword">new</span> MyBusEvent(<span class="string">"这是一个通过EventBus发送的消息"</span>));</span><br><span class="line">        <span class="comment">//当调用上述代码之后,所有订阅MessageEvent的方法均会在其声明的线程中得到执行.乍看起来很神奇,但是有了之前注册流程的分析,</span></span><br><span class="line">        <span class="comment">// 我们已经知道： EventBus的单例中已经存储了 订阅事件-订阅者 信息集合的映射关系,我们只要遍历其订阅者信息集合,再其规定的线程中执行即可.</span></span><br><span class="line">        <span class="comment">// 知道了上述原理,我们先来看一下post方法的具体实现.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClick</span>(R.id.send_child_msg)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendChildMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//父类MyBusEvent也会收到这个消息</span></span><br><span class="line">        EventBus.getDefault().post(<span class="keyword">new</span> MyBusEventChild(<span class="string">"发送MyBusEventChild消息"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明订阅函数.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiver</span><span class="params">(MyBusEvent busEvent)</span> </span>&#123;</span><br><span class="line">        mTvResult.setText(busEvent.message);</span><br><span class="line">        Log.d(TAG, <span class="string">"receiver---"</span> + busEvent.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiverChild</span><span class="params">(MyBusEventChild busEvent)</span> </span>&#123;</span><br><span class="line">        mTvResult.setText(busEvent.message);</span><br><span class="line">        Log.d(TAG, <span class="string">"receiverChild---"</span> + busEvent.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>MyBusEvent:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBusEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBusEvent</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="EventBus源码分析"><a href="#EventBus源码分析" class="headerlink" title="EventBus源码分析"></a>EventBus源码分析</h2><h3 id="整体类关系图"><a href="#整体类关系图" class="headerlink" title="整体类关系图"></a>整体类关系图</h3><p><img src="/" class="lazyload" data-src="/img/eventbus_assets/1485091-c3a3b1949867212c.png"  alt="img"></p>
<p>虽然更新了3.0,但是整体上的设计还是可以用上面的类图来分析,从类图上我们可以看到大部分类都是依赖于EventBus的,上部分主要是订阅者相关信息，中间是 EventBus 类，下面是发布者发布事件后的调用。</p>
<h3 id="getDefault"><a href="#getDefault" class="headerlink" title="getDefault()"></a>getDefault()</h3><h4 id="EventBus-java"><a href="#EventBus-java" class="headerlink" title="EventBus.java"></a>EventBus.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过volatile保证每个线程获取的都是最新的EventBus.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventBusBuilder DEFAULT_BUILDER = <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Map&lt;订阅事件, 订阅该事件的订阅者集合&gt;</span></span><br><span class="line"><span class="comment">     * 如：MyBusEvent.class--&gt;List:MainActivity、SecondActivity...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Map&lt;订阅者, 订阅事件集合&gt;</span></span><br><span class="line"><span class="comment">     * 如：MainActivity--&gt;List:MyBusEvent.class、MyBusEventChild.class...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Map&lt;订阅事件类类型,订阅事件实例对象&gt;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储当前线程的PostingThreadState对象.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//ThreadLocal：线程内部的数据存储类，通过它可以在指定的线程进行存储数据，只有在指定的线程中才能获取到数据</span></span><br><span class="line">    <span class="comment">//ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，</span></span><br><span class="line">    <span class="comment">//而这段数据是不会与其他线程共享的。其内部原理是通过生成一个它包裹的泛型对象的数组，在不同的线程会有不同的数组索引值，通过这样就可以做到每个线程通过get() 方法获取的时候，取到的只能是自己线程所对应的数据。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//可以看到,currentPostingThreadState是通过ThreadLocal来实现对PostingThreadState对象的存储.ThreadLocal是一个线程内部的数据存储类,通过它可以在指定的线程中存储数据,而这段数据是不会与其他线程共享的.</span></span><br><span class="line">    <span class="comment">// ThreadLocal的内部原理是:通过生成一个包裹的泛型对象的数组,在不同的线程会有不同的数组索引值.通过这样就可以做到每个线程通过get()方法获取的时候,取到的是自己线程对应的数据.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//三个Poster，需要说明的一点就是：Poster只负责处理粘滞事件,每个Poster中都有一个发送任务队列,PendingPostQueue queue;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主线程Handler实现类.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HandlerPoster mainThreadPoster;<span class="comment">//前台发送者</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承Runnable的异步线程处理类,将订阅函数的执行通过Executor和队列机制在后台一个一个的执行.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BackgroundPoster backgroundPoster;<span class="comment">//后台发送者</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承Runnable的异步线程处理类, 与BackgroundPoster不同的是,订阅函数的执行是并发进行的.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AsyncPoster asyncPoster;<span class="comment">//后台发送者(只让队列第一个待订阅者去响应)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅者响应函数信息存储和查找类.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SubscriberMethodFinder subscriberMethodFinder;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于订阅函数后台执行的线程池.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * EventBusBuilder构造器中的同一成员.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> throwSubscriberException;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> logSubscriberExceptions;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> logNoSubscriberMessages;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> sendSubscriberExceptionEvent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> sendNoSubscriberEvent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> eventInheritance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> indexCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convenience singleton for apps using a process-wide EventBus instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 懒汉的单例模式构造EventBus.</span></span><br><span class="line"><span class="comment">     * 单例，目的是为了保证getDefault()得到的都是同一个实例。如果不存在实例,就调用了EventBus的构造方法,实际上使用了DCL双检锁机制</span></span><br><span class="line"><span class="comment">     * 在创建EventBus实例的时候，一种方式是按照我们上面的形式，通过EventBus的静态方法getDefault来获取一个实例。</span></span><br><span class="line"><span class="comment">     * getDefault本身会调用其内部的构造方法，通过传入一个默认的EventBusBuilder来创建EventBus。</span></span><br><span class="line"><span class="comment">     * 此外，我们还可以直接通过EventBus的builder()方法获取一个EventBusBuilder的实例，然后通过该构建者模式来个性化地定制自己的EventBus</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (EventBus<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以使用下面的方法获取一个构建者，然后使用它来个性化定制EventBus</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBusBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//思考既然EventBus是单例的，为什么它的构造函数还要设置成public的？</span></span><br><span class="line">    <span class="comment">//因为EventBus不仅仅有一条总线，不同的EventBus发送的数据是相互隔离的，订阅者只会收到订阅在该线程上的事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以看出是通过初始化了一个EventBusBuilder()对象来分别初始化EventBus的一些配置,当我们在写一个需要自定义配置的框架的时候,</span></span><br><span class="line"><span class="comment">     * 这种实现方法非常普遍,将配置解耦出去,使我们的代码结构更清晰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">        <span class="comment">//key:订阅的事件,value:订阅这个事件的所有订阅者集合</span></span><br><span class="line">        <span class="comment">//private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span></span><br><span class="line">        subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//以Event为key，subscription为value的map，通过这个map可以找到我们的订阅者。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//key:订阅者对象,value:这个订阅者订阅的事件集合</span></span><br><span class="line">        <span class="comment">//private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span></span><br><span class="line">        typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//以Subscriber为key，Event为value,当注册和反注册的之后会用到这个集合</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//粘性事件 key:粘性事件的class对象, value:事件对象</span></span><br><span class="line">        <span class="comment">//private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span></span><br><span class="line">        stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();<span class="comment">//维护粘性事件，并发的HaspMap</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Poster:就是用作线程之间调度的</span></span><br><span class="line">        <span class="comment">//事件主线程处理</span></span><br><span class="line">        mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//事件 Background 处理</span></span><br><span class="line">        backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);<span class="comment">//BackgroundPoster:后台做了一些操作</span></span><br><span class="line">        <span class="comment">//事件异步线程处理</span></span><br><span class="line">        asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注解找寻器，找到被注解@Subscriber注解的方法，订阅者响应函数信息存储和查找类</span></span><br><span class="line">        subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">        <span class="comment">//以下都是各种标志位了</span></span><br><span class="line">        logSubscriberExceptions = builder.logSubscriberExceptions;<span class="comment">//异常信息打印的标志位</span></span><br><span class="line">        logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">        throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">        <span class="comment">//是否支持事件继承</span></span><br><span class="line">        eventInheritance = builder.eventInheritance;</span><br><span class="line">        <span class="comment">//线程池</span></span><br><span class="line">        executorService = builder.executorService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="EventBusBuilder-java"><a href="#EventBusBuilder-java" class="headerlink" title="EventBusBuilder.java"></a>EventBusBuilder.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates EventBus instances with custom parameters and also allows to install a custom default EventBus instance.</span></span><br><span class="line"><span class="comment"> * Create a new builder using &#123;<span class="doctag">@link</span> EventBus#builder()&#125;.</span></span><br><span class="line"><span class="comment"> * 构建器模式</span></span><br><span class="line"><span class="comment"> * Effective Java : 遇到多个构造器参数时要考虑用构造器.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBusBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> logSubscriberExceptions = <span class="keyword">true</span>;<span class="comment">//是否监听异常日志</span></span><br><span class="line">    <span class="keyword">boolean</span> logNoSubscriberMessages = <span class="keyword">true</span>;<span class="comment">//如果没有订阅者，显示log信息</span></span><br><span class="line">    <span class="keyword">boolean</span> sendSubscriberExceptionEvent = <span class="keyword">true</span>;<span class="comment">//是否发送监听到的异常</span></span><br><span class="line">    <span class="keyword">boolean</span> sendNoSubscriberEvent = <span class="keyword">true</span>;<span class="comment">//如果没有订阅者，发送一条默认事件</span></span><br><span class="line">    <span class="keyword">boolean</span> throwSubscriberException;<span class="comment">//如果失败，则抛出异常</span></span><br><span class="line">    <span class="keyword">boolean</span> eventInheritance = <span class="keyword">true</span>;<span class="comment">//event的子类是否也能响应订阅，是否响应订阅事件的父类事件</span></span><br><span class="line">    <span class="keyword">boolean</span> ignoreGeneratedIndex;</span><br><span class="line">    <span class="keyword">boolean</span> strictMethodVerification;<span class="comment">//是否为严格模式.值为true时,当Subscribe注解描述的响应函数不符合要求时,会抛出相应的异常.</span></span><br><span class="line">    ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;<span class="comment">//线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从命名来看,含义是不遍历的Method响应函数集合,但是没啥软用,EventBus3.0版本也没有遍历这个集合</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; skipMethodVerificationForClasses;</span><br><span class="line">    List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes;</span><br><span class="line"></span><br><span class="line">    EventBusBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//....</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Installs the default EventBus returned by &#123;<span class="doctag">@link</span> EventBus#getDefault()&#125; using this builders' values. Must be</span></span><br><span class="line"><span class="comment">     * done only once before the first usage of the default EventBus.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> EventBusException if there's already a default EventBus instance in place</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventBus <span class="title">installDefaultEventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (EventBus<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (EventBus.defaultInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Default instance already exists."</span> +</span><br><span class="line">                        <span class="string">" It may be only set once before it's used the first time to ensure consistent behavior."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            EventBus.defaultInstance = build();</span><br><span class="line">            <span class="keyword">return</span> EventBus.defaultInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Builds an EventBus based on the current configuration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventBus <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EventBus(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="register"><a href="#register" class="headerlink" title="register()"></a>register()</h3><p><img src="/" class="lazyload" data-src="/img/eventbus_assets/1485091-8bf39ad48834f39c.png"  alt="img"></p>
<p>订阅者向EventBus注册时,自身首先需要完成两件事情:</p>
<ol>
<li>订阅者本身需要声明只有一个参数的public方法,并且使用Subscribe进行注解.</li>
<li>订阅者需要调用EventBus的register方法进行注册.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//注册订阅的步骤：</span></span><br><span class="line">    <span class="comment">//第一步：找到订阅方法的集合，通过findSubscriberMethods方法</span></span><br><span class="line">    <span class="comment">//第二步：就是遍历上面的集合，给每个方法做订阅工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅事件</span></span><br><span class="line"><span class="comment">     * register方法通过subscriberMethodFinder实例的findSubscriberMethods方法来</span></span><br><span class="line"><span class="comment">     * 获取该观察者(Activity)类型中的所有订阅方法，然后将所有的订阅方法分别进行订阅</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 订阅函数的实现稍微复杂一些,这也是EventBus的核心所在,我们逐步分析每一个函数的具体实现.</span></span><br><span class="line"><span class="comment">     * 第一步,获取订阅者的类类型,没啥好说的,获取类类型之后,就能通过Java的反射机制来充分获取这个类的具体信息.</span></span><br><span class="line"><span class="comment">     * 第二步,通过SubscriberMethodFinder类来解析订阅者类,获取所有的订阅函数集合.</span></span><br><span class="line"><span class="comment">     * 第三步,遍历订阅函数,构造订阅函数与订阅事件的双重映射.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过反射获取订阅者class对象</span></span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">        <span class="comment">//通过subscriberMethodFinder返回订阅方法集合,通过反射机制获取订阅者全部的响应函数信息.</span></span><br><span class="line">        <span class="comment">//通过subscriberMethodFinder来找到订阅者订阅了哪些事件.返回一个SubscriberMethod对象的List,SubscriberMethod</span></span><br><span class="line">        <span class="comment">//里包含了这个方法的Method对象,以及将来响应订阅是在哪个线程的ThreadMode,以及订阅的事件类型eventType,以及订阅的优</span></span><br><span class="line">        <span class="comment">//先级priority,以及是否接收粘性sticky事件的boolean值.</span></span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">        <span class="comment">//回到EventBus类的register方法中,当通过EventBusMethodFinder获取到订阅函数集合后,下一步就是通过subscribe方法对订阅函数和订阅事件做双重映射.</span></span><br><span class="line">        <span class="comment">// 构造订阅函数-订阅事件(method-event)集合 与 订阅事件-订阅函数(event-method)集合</span></span><br><span class="line">        <span class="comment">//必须在同步代码块里调用</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//就是遍历上面的集合，给每个方法做订阅工作</span></span><br><span class="line">            <span class="comment">//SubscriberMethod:封装了订阅方法（使用@Subscribe注解的方法）类型的信息</span></span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">                subscribe(subscriber, subscriberMethod);<span class="comment">//注册订阅方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Subscribe-java注解"><a href="#Subscribe-java注解" class="headerlink" title="Subscribe.java注解"></a>Subscribe.java注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subscribe注解是EventBus3.0版本之后添加的,用来标识当前订阅者类中的订阅函数.</span></span><br><span class="line"><span class="comment"> * 之前EventBus的版本是遍历onEvent事件开头的函数来作为订阅函数,</span></span><br><span class="line"><span class="comment"> * 有很多局限性(例如函数命名等),使用注解更加规范而且更加灵活一些.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解的生命周期是:RUNTIME,注解对象是:Method,并且可以被javadoc等工具文档化.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记订阅方法所在线程的模型.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadMode <span class="title">threadMode</span><span class="params">()</span> <span class="keyword">default</span> ThreadMode.POSTING</span>;<span class="comment">//线程模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If true, delivers the most recent sticky event (posted with</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> EventBus#postSticky(Object)&#125;) to this subscriber (if event available).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记订阅方法是否为sticky类型.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sticky</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;<span class="comment">//是否为粘性事件：事件消费者在事件发布之后才注册的也能接收到该事件的特殊类型</span></span><br><span class="line">    <span class="comment">//类比，stick BroadCast，在广播发送结束后会保存刚刚发送的广播</span></span><br><span class="line">    <span class="comment">//AndroidEventBus会存储所有的Sticky事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Subscriber priority to influence the order of event delivery.</span></span><br><span class="line"><span class="comment">     * Within the same delivery thread (&#123;<span class="doctag">@link</span> ThreadMode&#125;), higher priority subscribers will receive events before</span></span><br><span class="line"><span class="comment">     * others with a lower priority. The default priority is 0. Note: the priority does *NOT* affect the order of</span></span><br><span class="line"><span class="comment">     * delivery among subscribers with different &#123;<span class="doctag">@link</span> ThreadMode&#125;s!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记订阅方法的优先级.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;<span class="comment">//优先级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SubscriberMethodFinder-java"><a href="#SubscriberMethodFinder-java" class="headerlink" title="SubscriberMethodFinder.java"></a>SubscriberMethodFinder.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订阅者响应函数发现类.</span></span><br><span class="line"><span class="comment"> * 一句话来描述SubscriberMethodFinder类就是用来查找和缓存订阅者响应函数的信息的类。</span></span><br><span class="line"><span class="comment"> * 所以我们首先要知道怎么能获得订阅者响应函数的相关信息。在3.0版本中,EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取<span class="doctag">@Subscribe</span>()注解并解析,</span></span><br><span class="line"><span class="comment"> * 处理其中所包含的信息,然后生成java类来保存所有订阅者关于订阅的信息,这样就比在运行时使用反射来获得这些订阅者的信息速度要快.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 在介绍SubscriberMethodFinder源码之前,需要说明一下,EventBus3.0版本提供了EventBusAnnotationProcessor这个类,</span></span><br><span class="line"><span class="comment"> * 用于在编译期获取并缓存<span class="doctag">@Subscribe</span>注解的方法.这里由于篇幅和介绍EventBus主要功能的关系,省略这部分代码的讲解.</span></span><br><span class="line"><span class="comment"> * 只介绍SubscriberMethodFinder在运行时是如何通过反射获取订阅者类中的订阅函数信息的.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethodFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * In newer class files, compilers may add methods. Those are called bridge or synthetic methods.</span></span><br><span class="line"><span class="comment">     * EventBus must ignore both. There modifiers are not public but defined in the Java class file format:</span></span><br><span class="line"><span class="comment">     * http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6-200-A.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这两种是编译器添加的方法,因为需要忽略.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BRIDGE = <span class="number">0x40</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNTHETIC = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义需要忽略方法的修饰符.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程安全的缓存Map,存储的键值对为&lt;订阅者类类型,订阅者方法信息集合&gt;.</span></span><br><span class="line"><span class="comment">     * 如：MainActivity.class--&gt;List:receiver、receiverChild...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ignoreGeneratedIndex为true时,subscriberInfoIndexes为空集合.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> strictMethodVerification;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里我们只介绍ignoreGeneratedIndex为true的情况,即只在运行时分析订阅者类的订阅函数信息.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ignoreGeneratedIndex;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象缓冲池的默认大小.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POOL_SIZE = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FindState对象缓冲池.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FindState[] FIND_STATE_POOL = <span class="keyword">new</span> FindState[POOL_SIZE];</span><br><span class="line"></span><br><span class="line">    SubscriberMethodFinder(List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes, <span class="keyword">boolean</span> strictMethodVerification,</span><br><span class="line">                           <span class="keyword">boolean</span> ignoreGeneratedIndex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subscriberInfoIndexes = subscriberInfoIndexes;</span><br><span class="line">        <span class="keyword">this</span>.strictMethodVerification = strictMethodVerification;</span><br><span class="line">        <span class="keyword">this</span>.ignoreGeneratedIndex = ignoreGeneratedIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取某个观察者中的所有订阅方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取某个观察者中的所有订阅方法，如果没有可用缓存的话就从该类中查找订阅方法，并在返回结果之前将这些方法信息放置到缓存当中。</span></span><br><span class="line"><span class="comment">     * 这里的ignoreGeneratedIndex参数表示是否忽略注解器生成的MyEventBusIndex，该值默认为false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先从METHOD_CACHE取看是否有缓存,key:保存订阅类的类名,value:保存类中订阅的方法数据,</span></span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">        <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当缓存中没有找到该观察者的订阅方法的时候使用下面的两种方法获取方法信息</span></span><br><span class="line">        <span class="comment">//是否忽略注解器生成的MyEventBusIndex类</span></span><br><span class="line">        <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">            <span class="comment">//利用反射来读取订阅类中的订阅方法信息</span></span><br><span class="line">            subscriberMethods = findUsingReflection(subscriberClass);<span class="comment">//我们来分析这个方式来获取subscriberMethods</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法信息</span></span><br><span class="line">            <span class="comment">//findUsingInfo()方法,其无非就是通过查找我们上面所说的MyEventBusIndex类中的信息,来转换成List&lt;SubscriberMethod&gt;从而获得订阅类的相关订阅函数的各种信息</span></span><br><span class="line">            subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</span><br><span class="line">                    + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//保存进METHOD_CACHE缓存</span></span><br><span class="line">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">            <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//FindState:找到被我们注解的方法的状态,这里通过FindState对象来存储找到的方法信息</span></span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line">        findState.initForSubscriber(subscriberClass);<span class="comment">//这个方法主要是做赋值操作的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是一个循环操作，会从当前类开始遍历该类的所有父类</span></span><br><span class="line">        <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取订阅者信息</span></span><br><span class="line">            findState.subscriberInfo = getSubscriberInfo(findState);<span class="comment">//获取findState中订阅者信息  1</span></span><br><span class="line">            <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;<span class="comment">//如果不为null</span></span><br><span class="line">                <span class="comment">// 如果使用了MyEventBusIndex，将会进入到这里并获取订阅方法信息</span></span><br><span class="line">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();<span class="comment">//获取订阅方法集合</span></span><br><span class="line">                <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;<span class="comment">//订阅方法过滤</span></span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);<span class="comment">//将符合标准的方法放入到集合subscriberMethods中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 未使用MyEventBusIndex将会进入这里使用反射获取方法信息   2</span></span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将findState.clazz设置为当前的findState.clazz的父类</span></span><br><span class="line">            findState.moveToSuperclass();<span class="comment">//进行下一次循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 会从当前订阅者类开始直到它最顶层的父类进行遍历来获取订阅方法信息。这里在循环的内部会根据我们是否使用了MyEventBusIndex走两条路线，</span></span><br><span class="line">        <span class="comment">// 对于我们没有使用它的，会直接使用反射来获取订阅方法信息，即进入2处</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getMethodsAndRelease(findState);<span class="comment">//返回和释放资源的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回订阅函数List,并释放FindState到对象缓冲池中.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">getMethodsAndRelease</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">        findState.recycle();</span><br><span class="line">        <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (FIND_STATE_POOL[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    FIND_STATE_POOL[i] = findState;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象池,复用FindState对象,防止对象被多次new或者gc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> FindState <span class="title">prepareFindState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">                FindState state = FIND_STATE_POOL[i];</span><br><span class="line">                <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    FIND_STATE_POOL[i] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明对象池中没有被new出的FindState对象,所以需要手动new一个出来,返回给调用者.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FindState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">            <span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">                <span class="keyword">return</span> superclassInfo;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">                SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">                <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> info;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里通过FindState类来做订阅方法的校验和保存,并通过FIND_STATE_POOL静态数组来保存FindState对象,可以使FindState复用,</span></span><br><span class="line"><span class="comment">     * 避免重复创建过多的对象.最终是通过findUsingReflectionInSingleClass()来具体获得相关订阅方法的信息的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subscriberClass 相当于MainActivity.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//FindState 用来做订阅方法的校验和保存</span></span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line">        <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//通过反射来获得订阅方法信息</span></span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">            <span class="comment">// 检查订阅者类的父类中是否有符合条件的订阅函数.</span></span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取findState中的SubscriberMethod(也就是订阅方法List)并返回</span></span><br><span class="line">        <span class="comment">//返回订阅函数List,并释放FindState到对象缓冲池中</span></span><br><span class="line">        <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射来解析订阅者类获取订阅函数信息</span></span><br><span class="line"><span class="comment">     * 通过这个方法可以找到哪个是我们订阅者订阅好的方法</span></span><br><span class="line"><span class="comment">     * 这里走完,我们订阅类的所有SubscriberMethod都已经被保存了,最后再通过getMethodsAndRelease()返回List&lt;SubscriberMethod&gt;至此,</span></span><br><span class="line"><span class="comment">     * 所有关于如何获得订阅类的订阅方法信息即:SubscriberMethod对象就已经完全分析完了</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 这里会对当前类中声明的所有方法进行校验，并将符合要求的方法的信息封装成一个SubscriberMethod对象塞到列表中</span></span><br><span class="line"><span class="comment">     * findState.subscriberMethods.add---&gt;subscriberMethods:List&lt;SubscriberMethod&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">        Method[] methods;<span class="comment">//通过反射得到方法数组</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class="line">            <span class="comment">// 获取该类中声明的所有方法</span></span><br><span class="line">            methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">            methods = findState.clazz.getMethods();</span><br><span class="line">            findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对方法进行遍历判断</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">// 获取当前方法的语言修饰符</span></span><br><span class="line">            <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">            <span class="comment">// 这里会对方法的修饰符进行校验：订阅方法必须是public而且不能在被忽略的修饰符集合中[abstract,static,bridge,synthetic].</span></span><br><span class="line">            <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这里对方法的输入参数进行校验，获取指定方法的形参类型集合</span></span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">                <span class="comment">//EventBus从3.0版本之后,订阅函数的标准改为有Subscribe注解修饰,并且只有一个参数,参数类型作为订阅事件的参数类型.</span></span><br><span class="line">                <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;<span class="comment">//只允许订阅方法的订阅事件为1个,保证必须只有一个事件参数</span></span><br><span class="line">                    <span class="comment">//得到注解,获取方法的注解，用来从注解中获取注解的声明信息</span></span><br><span class="line">                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 获取该方法的第一个参数</span></span><br><span class="line">                        Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                        <span class="comment">//校验是否添加该方法</span></span><br><span class="line">                        <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                            <span class="comment">// 封装订阅函数到FindState的subscriberMethods数组中.</span></span><br><span class="line">                            ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                            <span class="comment">// 实例化SubscriberMethod对象并添加, 最终将封装之后的方法塞入到列表中</span></span><br><span class="line">                            findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    <span class="comment">// 订阅函数的参数必须只有一个,也就说一个订阅函数只能订阅一个事件</span></span><br><span class="line">                    String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                            <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="comment">// 订阅函数必须是public的,而且不能有[abstract,static,bridge,synthetic]修饰符.</span></span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                        <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        METHOD_CACHE.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来对订阅方法进行校验和保存.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FindState</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//保存所有被注解的方法集合</span></span><br><span class="line">        <span class="keyword">final</span> Map&lt;Class, Object&gt; anyMethodByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//Key:事件类型为，Value:方法</span></span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, Class&gt; subscriberClassByMethodKey = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//Key:Method方法,Value:订阅者Class对象</span></span><br><span class="line">        <span class="keyword">final</span> StringBuilder methodKeyBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; subscriberClass;</span><br><span class="line">        Class&lt;?&gt; clazz;</span><br><span class="line">        <span class="keyword">boolean</span> skipSuperClasses;</span><br><span class="line">        SubscriberInfo subscriberInfo;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">initForSubscriber</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.subscriberClass = clazz = subscriberClass;</span><br><span class="line">            skipSuperClasses = <span class="keyword">false</span>;</span><br><span class="line">            subscriberInfo = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            subscriberMethods.clear();</span><br><span class="line">            anyMethodByEventType.clear();</span><br><span class="line">            subscriberClassByMethodKey.clear();</span><br><span class="line">            methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">            subscriberClass = <span class="keyword">null</span>;</span><br><span class="line">            clazz = <span class="keyword">null</span>;</span><br><span class="line">            skipSuperClasses = <span class="keyword">false</span>;</span><br><span class="line">            subscriberInfo = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">checkAdd</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.</span></span><br><span class="line">            <span class="comment">// Usually a subscriber doesn't have methods listening to the same event type.</span></span><br><span class="line">            Object existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">            <span class="keyword">if</span> (existing == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType)) &#123;</span><br><span class="line">                        <span class="comment">// Paranoia check</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Put any non-Method object to "consume" the existing Method</span></span><br><span class="line">                    anyMethodByEventType.put(eventType, <span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);<span class="comment">//可能会出现这样一种情况：子类会订阅该事件、同时父类也会订阅该事件，当这种情况出现的时候，EventBus是如何处理的呢？</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAddWithMethodSignature</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">            methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">            methodKeyBuilder.append(method.getName());</span><br><span class="line">            methodKeyBuilder.append(<span class="string">'&gt;'</span>).append(eventType.getName());</span><br><span class="line"></span><br><span class="line">            String methodKey = methodKeyBuilder.toString();</span><br><span class="line">            Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">            Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">            <span class="keyword">if</span> (methodClassOld == <span class="keyword">null</span> || methodClassOld.isAssignableFrom(methodClass)) &#123;</span><br><span class="line">                <span class="comment">// Only add if not already found in a sub class</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Revert the put, old class is further down the class hierarchy</span></span><br><span class="line">                subscriberClassByMethodKey.put(methodKey, methodClassOld);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取clazz父类的类类型.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">moveToSuperclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (skipSuperClasses) &#123;</span><br><span class="line">                clazz = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                clazz = clazz.getSuperclass();</span><br><span class="line">                String clazzName = clazz.getName();</span><br><span class="line">                <span class="comment">/** Skip system classes, this just degrades performance. */</span></span><br><span class="line">                <span class="keyword">if</span> (clazzName.startsWith(<span class="string">"java."</span>) || clazzName.startsWith(<span class="string">"javax."</span>) || clazzName.startsWith(<span class="string">"android."</span>)) &#123;</span><br><span class="line">                    clazz = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SubscriberMethod-java"><a href="#SubscriberMethod-java" class="headerlink" title="SubscriberMethod.java"></a>SubscriberMethod.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订阅者事件响应函数信息</span></span><br><span class="line"><span class="comment"> * Used internally by EventBus and generated subscriber indexes.</span></span><br><span class="line"><span class="comment"> * 通过SubscriberMethodFinder类的findSubscriberMethods方法,获取了当前订阅者的所有订阅函数信息集合. 而SubscriberMethod类就是对订阅函数的抽象</span></span><br><span class="line"><span class="comment"> * 这个抽象很简单,而且和Subscriber注解其实是一一对应的,只是多了一个eventType成员属性和equals比较方法. 其中:</span></span><br><span class="line"><span class="comment"> * 1. eventType:是该订阅函数唯一的参数的类类型,也就是订阅函数对应的订阅事件的类型.</span></span><br><span class="line"><span class="comment"> * 2. equals: 该方法通过构造$&#123;methodClassName&#125;#$&#123;methodName&#125;字符串来比较两个订阅函数是否相同.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应函数方法的类类型,可通过invoke方法对该方法进行调用.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Method method;<span class="comment">//订阅的方法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数运行所在的线程的线程类型.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ThreadMode threadMode;<span class="comment">//线程模型</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅事件的类型,也是订阅函数第一个形参的参数类型. MyBusEvent.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; eventType;<span class="comment">//事件类型</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应函数的优先级.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> priority;<span class="comment">//优先级</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为sticky响应函数.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> sticky;<span class="comment">//是否是粘性事件</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Used for efficient comparison</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String methodString;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubscriberMethod</span><span class="params">(Method method, Class&lt;?&gt; eventType, ThreadMode threadMode, <span class="keyword">int</span> priority, <span class="keyword">boolean</span> sticky)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.threadMode = threadMode;</span><br><span class="line">        <span class="keyword">this</span>.eventType = eventType;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">        <span class="keyword">this</span>.sticky = sticky;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (other <span class="keyword">instanceof</span> SubscriberMethod) &#123;</span><br><span class="line">            checkMethodString();</span><br><span class="line">            SubscriberMethod otherSubscriberMethod = (SubscriberMethod) other;</span><br><span class="line">            otherSubscriberMethod.checkMethodString();</span><br><span class="line">            <span class="comment">// Don't use method.equals because of http://code.google.com/p/android/issues/detail?id=7811#c6</span></span><br><span class="line">            <span class="keyword">return</span> methodString.equals(otherSubscriberMethod.methodString);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造methodString,构造方法:$&#123;methodClassName&#125;#$&#123;methodName&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">checkMethodString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (methodString == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Method.toString has more overhead, just take relevant parts of the method</span></span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">64</span>);</span><br><span class="line">            builder.append(method.getDeclaringClass().getName());</span><br><span class="line">            builder.append(<span class="string">'#'</span>).append(method.getName());</span><br><span class="line">            builder.append(<span class="string">'('</span>).append(eventType.getName());</span><br><span class="line">            methodString = builder.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe()"></a>subscribe()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法的目的：构造两个集合.</span></span><br><span class="line"><span class="comment">     * 1. 订阅事件-&gt;订阅者集合.</span></span><br><span class="line"><span class="comment">     * 2. 订阅者-&gt;订阅事件集合.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 方法说明：必须在同步代码块里调用</span></span><br><span class="line"><span class="comment">     * 1. 首先判断是否有注册过该事件</span></span><br><span class="line"><span class="comment">     * 2. 然后再按照优先级加入到subscriptionsByEventType的value的List中</span></span><br><span class="line"><span class="comment">     * 3. 添加到typesBySubscriber的value的List中</span></span><br><span class="line"><span class="comment">     * 4. 分发事件：checkPostStickyEventToSubscription</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 这里涉及到了几个集合，它们是用来做缓存的，还有就是来维护观察者、事件类型和订阅方法之间的关系的。注册观察的方法比较长，我们可以一点一点来看。</span></span><br><span class="line"><span class="comment">     * 首先，会在代码1处将观察者和订阅方法封装成一个Subscription对象。然后，在2处用到了CopyOnWriteArrayList这个集合，它是一种适用于多读写少场景的数据结构，</span></span><br><span class="line"><span class="comment">     * 是一种线程安全的数组型的数据结构，主要用来存储一个事件类型所对应的全部的Subscription对象。</span></span><br><span class="line"><span class="comment">     * EventBus在这里通过一个Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt;类型的哈希表来维护这个映射关系。</span></span><br><span class="line"><span class="comment">     * 然后，我们的程序执行到2处，在这里会对Subscription对象的列表进行遍历，并根据订阅方法的优先级，为当前的Subscription对象寻找一个合适的位置。</span></span><br><span class="line"><span class="comment">     * 3的地方主要的逻辑是获取指定的观察者对应的全部的观察事件类型，这里也是通过一个哈希表来维护这种映射关系的。</span></span><br><span class="line"><span class="comment">     * 然后，在代码4处，程序会根据当前的订阅方法是否是黏性的，来决定是否将当前缓存中的信息发送给新订阅的方法。这里会通过checkPostStickyEventToSubscription方法来发送信息，</span></span><br><span class="line"><span class="comment">     * 它内部的实现的逻辑和post方法类似，我们不再进行说明。</span></span><br><span class="line"><span class="comment">     * 取消注册的逻辑比较比较简单，基本上就是注册操作反过来——将当前订阅方法的信息从缓存中踢出来，我们不再进行分分析。下面我们分析另一个比较重要的地方，即发送事件相关的逻辑。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subscriber       订阅者 Activity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subscriberMethod 订阅者中的响应函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取订阅的事件类型</span></span><br><span class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">        <span class="comment">//创建Subscription对象</span></span><br><span class="line">        <span class="comment">//Subscription：更大的一个封装类，封装了subscriber和subscriberMethod</span></span><br><span class="line">        <span class="comment">// 将所有的观察者和订阅方法封装成一个Subscription对象</span></span><br><span class="line">        Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);<span class="comment">// 1</span></span><br><span class="line">        <span class="comment">//subscriptions:可并发读写的list</span></span><br><span class="line">        <span class="comment">//从subscriptionsByEventType里检查是否已经添加过该Subscription,如果添加过就抛出异常</span></span><br><span class="line">        <span class="comment">// 尝试从缓存中根据事件类型来获取所有的Subscription对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个Event事件可能会被多个订阅者订阅,因此这里使用Map结构,存储Event事件对应的订阅者集合.</span></span><br><span class="line">        <span class="comment">// 此外,一个订阅者类中可能会有多个订阅函数,有几个订阅函数这里就解析成有几个订阅者.</span></span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">        <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 指定的事件类型没有对应的观察对象的时候</span></span><br><span class="line">            subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                        + eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据优先级priority来添加Subscription对象</span></span><br><span class="line">        <span class="comment">// 这里会根据新加入的方法的优先级决定插入到队列中的位置</span></span><br><span class="line">        <span class="comment">// 按照方法优先级从高到低的顺序将订阅者加入到订阅者集合中.</span></span><br><span class="line">        <span class="keyword">int</span> size = subscriptions.size();<span class="comment">//  2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);<span class="comment">//根据优先级重新添加到list当中</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前订阅者订阅了哪些事件集合.</span></span><br><span class="line">        <span class="comment">//将订阅者对象以及订阅的事件保存到typesBySubscriber里</span></span><br><span class="line">        <span class="comment">// 这里又会从“订阅者-事件类型”列表中尝试获取该订阅者对应的所有事件类型</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);<span class="comment">//3</span></span><br><span class="line">        <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是黏性事件还要进行如下的处理</span></span><br><span class="line">        <span class="comment">//如果接收sticky事件,立即分发sticky事件</span></span><br><span class="line">        <span class="keyword">if</span> (subscriberMethod.sticky) &#123;<span class="comment">//4</span></span><br><span class="line">            <span class="comment">//eventInheritance 表示是否分发订阅了响应事件类父类事件的方法</span></span><br><span class="line">            <span class="keyword">if</span> (eventInheritance) &#123;<span class="comment">//是否支持继承关系</span></span><br><span class="line">                <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">                <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">                <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">                <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                    <span class="comment">//isAssignableFrom:是否有继承关系</span></span><br><span class="line">                    <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        Object stickyEvent = entry.getValue();</span><br><span class="line">                        <span class="comment">// 这里会向该观察者通知所有的黏性事件</span></span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);<span class="comment">//进行分发时间</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="Subscription-java"><a href="#Subscription-java" class="headerlink" title="Subscription.java"></a>Subscription.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订阅者信息,包含订阅者对象,订阅者中一个订阅函数.</span></span><br><span class="line"><span class="comment"> * 一个订阅者可能会有多个订阅函数,每个订阅函数对应着订阅事件.Subscription类是对&lt;订阅者-其中一个订阅函数&gt;的抽象.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅者的实例化对象.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object subscriber;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅者的订阅函数信息.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> SubscriberMethod subscriberMethod;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Becomes false as soon as &#123;<span class="doctag">@link</span> EventBus#unregister(Object)&#125; is called, which is checked by queued event delivery</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> EventBus#invokeSubscriber(PendingPost)&#125; to prevent race conditions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> active;</span><br><span class="line"></span><br><span class="line">    Subscription(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subscriber = subscriber;</span><br><span class="line">        <span class="keyword">this</span>.subscriberMethod = subscriberMethod;</span><br><span class="line">        active = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> Subscription) &#123;</span><br><span class="line">            Subscription otherSubscription = (Subscription) other;</span><br><span class="line">            <span class="keyword">return</span> subscriber == otherSubscription.subscriber</span><br><span class="line">                    &amp;&amp; subscriberMethod.equals(otherSubscription.subscriberMethod);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subscriber.hashCode() + subscriberMethod.methodString.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/" class="lazyload" data-src="/img/eventbus_assets/register.png"  alt="register"></p>
<h3 id="unregister"><a href="#unregister" class="headerlink" title="unregister()"></a>unregister()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消订阅.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过typesBySubscriber来取出这个subscriber订阅者订阅的事件类型,</span></span><br><span class="line">        <span class="comment">// 获取该订阅者所有的订阅事件类类型集合.</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">        <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//分别解除每个订阅了的事件类型</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">                <span class="comment">//从订阅事件对应的订阅者集合subscriptionsByEventType中删除取消注册的订阅者.</span></span><br><span class="line">                unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从typesBySubscriber删除该&lt;订阅者对象,订阅事件类类型集合&gt;</span></span><br><span class="line">            typesBySubscriber.remove(subscriber);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber.</span></span><br><span class="line"><span class="comment">     * 最终分别从typesBySubscriber和subscriptions里分别移除订阅者以及相关信息即可.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从订阅事件对应的订阅者集合中删除取消注册的订阅者.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//subscriptionsByEventType里拿出这个事件类型的订阅者列表.</span></span><br><span class="line">        <span class="comment">// 获取订阅事件对应的订阅者信息集合.</span></span><br><span class="line">        List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">        <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">            <span class="comment">//取消订阅</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Subscription subscription = subscriptions.get(i);</span><br><span class="line">                <span class="comment">// 从订阅者集合中删除特定的订阅者,因为一个订阅事件可以对应多个订阅者</span></span><br><span class="line">                <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                    subscription.active = <span class="keyword">false</span>;</span><br><span class="line">                    subscriptions.remove(i);</span><br><span class="line">                    i--;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h3><p><img src="/" class="lazyload" data-src="/img/eventbus_assets/1485091-b7b63f83d65903d1.png"  alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首先是通过currentPostingThreadState.get()方法来得到当前线程PostingThreadState的对象,为什么是说当前线程我们来看看currentPostingThreadState的实现:</span></span><br><span class="line"><span class="comment">     * 这里的currentPostingThreadState是一个ThreadLocal类型的变量，其中存储了对应于当前线程的PostingThreadState对象，</span></span><br><span class="line"><span class="comment">     * 该对象中存储了当前线程对应的事件列表和线程的状态信息等。从上面的代码中可以看出，post方法会在1处不断从当前线程对应的队列中取出事件并进行发布.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件分发.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里从线程局部变量中取出当前线程的状态信息,通过ThreadLocal获取一个PostingThreadState,得到当前线程的Posting状态.</span></span><br><span class="line">        <span class="comment">//post()方法首先从currentPostingThreadState对象中获取当前线程的PostingThreadState对象.为什么说是当前线程的PostingThreadState对象呢,</span></span><br><span class="line">        <span class="comment">// 这就需要看一下currentPostingThreadState对象的构造函数了.</span></span><br><span class="line">        PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">        <span class="comment">//获取当前线程的事件队列</span></span><br><span class="line">        <span class="comment">// 这里是以上线程局部变量内部维护的一个事件队列</span></span><br><span class="line">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">        eventQueue.add(event);<span class="comment">//将事件添加到事件队列当中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Post方法取出当前线程的PostingThreadState对象之后,将需要入队的Event事件入队,然后调用了postSingleEvent方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">            postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">            postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 循环处理当前线程eventQueue中的每一个event对象.</span></span><br><span class="line">                <span class="comment">//  不断循环来发送事件</span></span><br><span class="line">                <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//发送单个事件</span></span><br><span class="line">                    postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);<span class="comment">//1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//状态清零</span></span><br><span class="line">                <span class="comment">// 恢复当前线程的信息</span></span><br><span class="line">                <span class="comment">// 处理完重置postingState一些标识信息.</span></span><br><span class="line">                postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">                postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从源码中可以看出,postSingleEvent方法主要是调用了postSingleEventForEventType来对订阅事件进行分发.</span></span><br><span class="line"><span class="comment">     * 区别是,当EventBus的eventInheritance成员属性为true时,订阅了当前事件父类事件或者实现接口的事件的订阅函数也会响应这个订阅事件.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 我们会根据eventInheritance的值决定是否要同时遍历当前事件的所有父类的事件信息并进行分发。</span></span><br><span class="line"><span class="comment">     * 如果设置为true就将执行这一操作，并最终使用postSingleEventForEventType对每个事件类型进行处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">        Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">        <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//是否触发订阅了该事件(eventClass)的父类,以及接口的类的响应方法.</span></span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">            <span class="comment">// 这里向上查找该事件的所有父类</span></span><br><span class="line">            <span class="comment">//lookupAllEventTypes:查找所有继承关系的事件类型</span></span><br><span class="line">            <span class="comment">//查找eventClass类所有的父类以及接口</span></span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">            <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">            <span class="comment">//循环postSingleEventForEventType</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">                <span class="comment">// 对上面的事件进行处理</span></span><br><span class="line">                <span class="comment">//只要右边有一个为true,subscriptionFound就为true</span></span><br><span class="line">                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//post单个,在postSingleEventForEventType()方法里去进行事件的分发</span></span><br><span class="line">            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找不到该事件的异常处理</span></span><br><span class="line">        <span class="comment">// 如果没发现</span></span><br><span class="line">        <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent<span class="class">.<span class="keyword">class</span> &amp;&amp;</span></span><br><span class="line"><span class="class">                    <span class="title">eventClass</span> !</span>= SubscriberExceptionEvent<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//发送一个NoSubscriberEvent事件,如果我们需要处理这种状态,接收这个事件就可以了</span></span><br><span class="line">                post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));<span class="comment">//没有订阅者订阅该事件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首先从subscriptionsByEventType里获得所有订阅了这个事件的Subscription列表,然后在通过postToSubscription()方法来分发</span></span><br><span class="line"><span class="comment">     * 事件,在postToSubscription()通过不同的threadMode在不同的线程里invoke()订阅者的方法,ThreadMode共有四类.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 我们会通过传入的事件类型到缓存中取寻找它对应的全部的Subscription，然后对得到的Subscription列表进行遍历，并依次调用postToSubscription方法执行事件的发布操作。</span></span><br><span class="line"><span class="comment">     * 下面是postToSubscription方法的代码，这里我们会根据订阅方法指定的threadMode信息来执行不同的发布策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取指定的事件对应的所有的观察对象</span></span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//获取订阅了这个事件的Subscription列表.</span></span><br><span class="line">            <span class="comment">// 获取订阅事件类类型对应的订阅者信息集合.(register函数时构造的集合)</span></span><br><span class="line">            subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 遍历观察对象，并最终执行事件的分发操作</span></span><br><span class="line">            <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">                postingState.event = event;</span><br><span class="line">                postingState.subscription = subscription;</span><br><span class="line">                <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;<span class="comment">//是否被中断</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 发布订阅事件给订阅函数</span></span><br><span class="line">                    postToSubscription(subscription, event, postingState.isMainThread);<span class="comment">//依次完成订阅</span></span><br><span class="line">                    <span class="comment">//postSingleEventForEventType的作用是:找出所有订阅event事件的订阅函数集合,然后调用postToSubscription方法进行事件分发.</span></span><br><span class="line">                    aborted = postingState.canceled;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                    postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                    postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从源码中可以看出,postToSubscription方法主要是根据订阅方法指定的ThreadMode进行相应的处理.</span></span><br><span class="line"><span class="comment">     * 会根据当前的线程状态和订阅方法指定的threadMode信息来决定合适触发方法。</span></span><br><span class="line"><span class="comment">     * 这里的invokeSubscriber会在当前线程中立即调用反射来触发指定的观察者的订阅方法。否则会根据具体的情况将事件加入到不同的队列中进行处理。</span></span><br><span class="line"><span class="comment">     * 这里的mainThreadPoster最终继承自Handler，当调用它的enqueue方法的时候，它会发送一个事件并在它自身的handleMessage方法中从队列中取值并进行处理，</span></span><br><span class="line"><span class="comment">     * 从而达到在主线程中分发事件的目的。这里的backgroundPoster实现了Runnable接口，它会在调用enqueue方法的时候，拿到EventBus的ExecutorService实例，</span></span><br><span class="line"><span class="comment">     * 并使用它来执行自己。在它的run方法中会从队列中不断取值来进行执行。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> POSTING:<span class="comment">//POSTING的含义是订阅函数可以直接运行在发送当前Event事件的线程中.而post方法又是发布订阅事件线程调用的,所以直接执行订阅方法即可.EventBus中订阅方法的执行是通过反射机制.</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MAIN:<span class="comment">//MAIN的含义表示订阅函数需要运行在主线程中,例如一些UI的操作. 如何判断当前发布订阅事件的线程是否为UI线程,可以通过如下方法:Looper.getMainLooper() == Looper.myLooper();</span></span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                    <span class="comment">//如果当前发布订阅事件的线程是UI线程,则直接反射调用订阅函数即可.如果不是,则通过mainThreadPoster来执行</span></span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//mainThreadPoster:就是HandlerPoster类型，内部使用Handler实现的</span></span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BACKGROUND:<span class="comment">//BACKGROUND的意思是订阅函数必须运行在子线程中,而且是顺序执行.这个实现很简单,通过队列机制+线程池就可以实现该功能.</span></span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                    backgroundPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ASYNC:<span class="comment">//ASYNC意思是订阅函数运行在子线程中,而且可以并发执行.这个实现就更简单了,直接线程池+Runnable即可.EventBus具体实现如下:</span></span><br><span class="line">                asyncPoster.enqueue(subscription, event);<span class="comment">//不管是否在主线程都开一个新线程</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Looks up all Class objects including super classes and interfaces. Should also work for interfaces.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出当前订阅事件类类型eventClass的所有父类的类类型和其实现的接口的类类型.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (eventTypesCache) &#123;</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</span><br><span class="line">            <span class="keyword">if</span> (eventTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                eventTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                Class&lt;?&gt; clazz = eventClass;</span><br><span class="line">                <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    eventTypes.add(clazz);</span><br><span class="line">                    addInterfaces(eventTypes, clazz.getInterfaces());</span><br><span class="line">                    clazz = clazz.getSuperclass();</span><br><span class="line">                &#125;</span><br><span class="line">                eventTypesCache.put(eventClass, eventTypes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> eventTypes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recurses through super interfaces.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归获取指定接口的所有父类接口.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInterfaces</span><span class="params">(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; interfaceClass : interfaces) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!eventTypes.contains(interfaceClass)) &#123;</span><br><span class="line">                eventTypes.add(interfaceClass);</span><br><span class="line">                addInterfaces(eventTypes, interfaceClass.getInterfaces());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//通过反射完成,实际上就是通过反射调用了订阅者的订阅函数并把event对象作为参数传入.至此post()流程就结束了</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射来执行订阅函数.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="ThreadMode-java"><a href="#ThreadMode-java" class="headerlink" title="ThreadMode.java"></a>ThreadMode.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Each event handler method has a thread mode, which determines in which thread the method is to be called by EventBus.</span></span><br><span class="line"><span class="comment"> * EventBus takes care of threading independently from the posting thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Markus</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * POSTING：默认的线程模式，表示事件处理函数的线程跟发布事件的线程在同一个线程。</span></span><br><span class="line"><span class="comment"> * MAIN：表示在主线程中执行这个方法，表示事件处理函数的线程在主线程(UI)线程，因此在这里不能进行耗时操作。</span></span><br><span class="line"><span class="comment"> * BACKGROUND：表示在后台线程执行响应的方法，表示事件处理函数的线程在后台线程，因此不能进行UI操作。</span></span><br><span class="line"><span class="comment"> * 如果发布事件的线程是主线程(UI线程)，那么事件处理函数将会开启一个后台线程，如果果发布事件的线程是在后台线程，那么事件处理函数就使用该线程。</span></span><br><span class="line"><span class="comment"> * ASYNC：表示无论事件发布的线程是哪一个，事件处理函数始终会新建一个子线程运行，同样不能进行UI操作。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EventBus#register(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应函数执行时所在线程的类型.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ThreadMode &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Subscriber will be called in the same thread, which is posting the event. This is the default. Event delivery</span></span><br><span class="line"><span class="comment">     * implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for</span></span><br><span class="line"><span class="comment">     * simple tasks that are known to complete is a very short time without requiring the main thread. Event handlers</span></span><br><span class="line"><span class="comment">     * using this mode must return quickly to avoid blocking the posting thread, which may be the main thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 订阅者将在发布事件的同一线程中调用。这是默认值。事件传递是同步完成的，一旦发布完成，所有订阅者都将被调用。</span></span><br><span class="line"><span class="comment">     * 此ThreadMode意味着开销最小，因为它完全避免了线程切换。因此，这是已知完成的简单任务的推荐模式，是一个非常短的时间而不需要主线程。</span></span><br><span class="line"><span class="comment">     * 使用此模式的事件处理程序应该快速返回以避免阻止发布线程，这可能是主线程。</span></span><br><span class="line"><span class="comment">     * 默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI 线程）。</span></span><br><span class="line"><span class="comment">     * 当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：对于是否在主线程执行无要求，</span></span><br><span class="line"><span class="comment">     * 但若 Post 线程为主线程，不能耗时的操作；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应函数需要运行的线程和发送响应事件的线程为同一线程.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    POSTING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Subscriber will be called in Android's main thread (sometimes referred to as UI thread). If the posting thread is</span></span><br><span class="line"><span class="comment">     * the main thread, event handler methods will be called directly. Event handlers using this mode must return</span></span><br><span class="line"><span class="comment">     * quickly to avoid blocking the main thread.</span></span><br><span class="line"><span class="comment">     * 订阅者将在Android的主线程（有时称为UI线程）中调用。如果发布线程是主线程，则将直接调用事件处理程序方法（与ThreadMode.POSTING所描述的同步）。</span></span><br><span class="line"><span class="comment">     * 使用此模式的事件处理程序必须快速返回以避免阻塞主线程。</span></span><br><span class="line"><span class="comment">     * 在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理——调用订阅者的事件响应函数。</span></span><br><span class="line"><span class="comment">     * 显然，MainThread类的方法也不能有耗时操作，以避免卡主线程。适用场景：必须在主线程执行的操作；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应函数需要运行在主线程.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MAIN,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Subscriber will be called in a background thread. If posting thread is not the main thread, event handler methods</span></span><br><span class="line"><span class="comment">     * will be called directly in the posting thread. If the posting thread is the main thread, EventBus uses a single</span></span><br><span class="line"><span class="comment">     * background thread, that will deliver all its events sequentially. Event handlers using this mode should try to</span></span><br><span class="line"><span class="comment">     * return quickly to avoid blocking the background thread.</span></span><br><span class="line"><span class="comment">     * 订阅者将在后台线程中调用。如果发布线程不是主线程，则将在发布线程中直接调用事件处理程序方法。</span></span><br><span class="line"><span class="comment">     * 如果发布线程是主线程，则EventBus使用单个后台线程，该线程将按顺序传递其所有事件。</span></span><br><span class="line"><span class="comment">     * 使用此模式的事件处理程序应尝试快速返回以避免阻塞后台线程。</span></span><br><span class="line"><span class="comment">     * 在后台线程中执行响应方法。如果发布线程不是主线程，则直接调用订阅者的事件响应函数，否则启动唯一的后台线程去处理。由于后台线程是唯一的，</span></span><br><span class="line"><span class="comment">     * 当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有PostThread类和MainThread类方法对性能敏感，但最好不要有重度耗时的操作或太频繁的轻度耗时操作，</span></span><br><span class="line"><span class="comment">     * 以造成其他操作等待。适用场景：操作轻微耗时且不会过于频繁，即一般的耗时操作都可以放在这里；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应函数需要运行的线程为后台线程,且根据优先级等进行排队,后台顺序执行.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BACKGROUND,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Event handler methods are called in a separate thread. This is always independent from the posting thread and the</span></span><br><span class="line"><span class="comment">     * main thread. Posting events never wait for event handler methods using this mode. Event handler methods should</span></span><br><span class="line"><span class="comment">     * use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number</span></span><br><span class="line"><span class="comment">     * of long running asynchronous handler methods at the same time to limit the number of concurrent threads. EventBus</span></span><br><span class="line"><span class="comment">     * uses a thread pool to efficiently reuse threads from completed asynchronous event handler notifications.</span></span><br><span class="line"><span class="comment">     * 事件处理程序方法在单独的线程中调用。这始终独立于发布线程和主线程。发布事件永远不会等待使用此模式的事件处理程序方法。</span></span><br><span class="line"><span class="comment">     * 如果事件处理程序的执行可能需要一些时间，例如用于网络访问，则应使用此模式。避免同时触发大量长时间运行的异步处理程序方法来限制并发线程数。</span></span><br><span class="line"><span class="comment">     * EventBus使用线程池从已完成的异步事件处理程序通知中有效地重用线程。</span></span><br><span class="line"><span class="comment">     * 不论发布线程是否为主线程，都使用一个空闲线程来处理。和BackgroundThread不同的是，Async类的所有线程是相互独立的，因此不会出现卡线程的问题。</span></span><br><span class="line"><span class="comment">     * 适用场景：长耗时操作，例如网络访问。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应函数需要运行的线程为后台线程,可并发执行.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ASYNC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/" class="lazyload" data-src="/img/eventbus_assets/post.png"  alt="post"></p>
<h3 id="粘性事件发布"><a href="#粘性事件发布" class="headerlink" title="粘性事件发布"></a>粘性事件发布</h3><blockquote>
<p>粘性事件是指：发布者发送事件的动作发生在订阅者订阅该事件的动作之前，订阅者在订阅之后，仍然可以处理该事件。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(event);</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSticky</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">            stickyEvents.put(event.getClass(), event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Should be posted after it is putted, in case the subscriber wants to remove immediately</span></span><br><span class="line">        post(event);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postSticky的逻辑简单明了，首先将事件存入stickyEvents里，然后调用普通事件的post方法，执行与普通post相同的逻辑。</p>
<p>思考：</p>
<blockquote>
<ol>
<li>粘性事件的发布和普通事件的发布好像没什么区别，它是怎么做到粘性的效果呢？</li>
<li>在register的时候，有调用了checkPostStickyEventToSubscription方法，该方法和postSticky里的post方法最终都调用了postToSubscription，这样不就重复了吗？</li>
</ol>
</blockquote>
<p>读者请仔细观察，在postSticky方法里，是有把事件缓存到stickyEvents中的。postSticky里的post方法，是订阅者的订阅事件的动作发生在粘性事件发布之前，此时粘性事件相当于普通事件，所以直接调用post处理即可。但如果订阅者的订阅事件的动作发生在粘性事件发布之后呢？</p>
<p>此时就轮到stickyEvents起作用了，在注册方法里，会取出所有未处理的缓存的粘性事件，发送到checkPostStickyEventToSubscription处理，这样不就达到粘性事件的处理效果了吗？</p>
<p>其实这种场景在实际开发中是很常见的。比如我们在某个非UI线程发布一个事件，在订阅该事件的订阅方法里去启动某个Activity，此时，由于事件发布和Activity启动不在同一个线程，且Activity启动的速度和事件发布的速度也不可知，就有可能出现两种情况（发布普通事件的场景）：</p>
<blockquote>
<ol>
<li>Activity先起来，事件后发送，此时没有添加sticky=true的订阅方法可以处理到该事件</li>
<li>Activity后起来，事件先发送，此时没有添加sticky=true的订阅方法就处理不到该事件了</li>
</ol>
</blockquote>
<p>而粘性事件正好可以处理场景2的需求。</p>
<p>那么，有聪明的读者就会说了：那直接把应用中的所有事件都以粘性事件发布，这样不就可以高枕无忧了？</p>
<p>其实不然。首先，粘性事件是以Map缓存的，事件越多，越占内存；其次，每次注册执行register时，都会将所有缓存的粘性事件调用订阅方法处理，如果处理过的粘性事件没有清除，对于应用功能可能是有影响的。建议读者不要图省事而种下祸根。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上述EventBus的源码分析,我们应该了解到EventBus通过反射机制实现了订阅者和发布者的解耦和订阅发布功能.与传统的观察者模型相比,不需要写冗余的interface接口,而且支持自定义要执行的线程,感觉还是很不错的.</p>
<p>END.</p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/EventBus/">EventBus</a></div><div class="post_share"><div class="social-share" data-image="https://pic4.zhimg.com/v2-eb05d8524374771337ecde8cca28cfff_1440w.jpg?source=172ae18b" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/25/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Dagger2%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/"><img class="prev_cover lazyload" data-src="https://img.cniao5.com/o_1b3rl8h6mk8d162i1i0p1ha6p989.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android源码分析——Dagger2（未完）</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/21/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"><img class="next_cover lazyload" data-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1591889468237&amp;di=a79e1dc7a3c1340077899e5ad15a57d3&amp;imgtype=0&amp;src=http%3A%2F%2Fupload.mnw.cn%2F2018%2F0531%2F1527730758557.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Git的基本使用</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/25/Android源码分析——Dagger2（未完）/" title="Android源码分析——Dagger2（未完）"><img class="relatedPosts_cover lazyload"data-src="https://img.cniao5.com/o_1b3rl8h6mk8d162i1i0p1ha6p989.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-25</div><div class="relatedPosts_title">Android源码分析——Dagger2（未完）</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/18/Android源码分析——Retrofit/" title="Android源码分析——Retrofit"><img class="relatedPosts_cover lazyload"data-src="https://img.cniao5.com/o_1avp1uvsgh7irrvv158jn7mf9.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-18</div><div class="relatedPosts_title">Android源码分析——Retrofit</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/21/Android源码分析——Glide/" title="Android源码分析——Glide"><img class="relatedPosts_cover lazyload"data-src="http://inthecheesefactory.com/uploads/source/glidepicasso/cover.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-21</div><div class="relatedPosts_title">Android源码分析——Glide</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/21/博文地址推荐/" title="博文地址推荐"><img class="relatedPosts_cover lazyload"data-src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1591889554697&di=6cd48317171455e6e367313f3430a2e2&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20180717%2Fab8a30734c7f45ad847ca089864e25e4.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-21</div><div class="relatedPosts_title">博文地址推荐</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/13/开发技能汇总/" title="开发技能汇总"><img class="relatedPosts_cover lazyload"data-src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1589358596541&di=ec2608777052785cb20f0d366f2d82b7&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20170830%2F544fed872efd40a5acf7ebcec0067fc1.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-13</div><div class="relatedPosts_title">开发技能汇总</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/15/Android源码分析——OKHttp/" title="Android源码分析——OKHttp"><img class="relatedPosts_cover lazyload"data-src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=357267695,3859876688&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-15</div><div class="relatedPosts_title">Android源码分析——OKHttp</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Kai</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>