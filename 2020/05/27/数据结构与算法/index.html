<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构与算法 | K的小屋</title><meta name="description" content="数据结构与算法"><meta name="keywords" content="算法,数据结构"><meta name="author" content="Kai"><meta name="copyright" content="Kai"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据结构与算法"><meta name="twitter:description" content="数据结构与算法"><meta name="twitter:image" content="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1590562175309&amp;di=0ef43267d5571b2520bff72d0120bdab&amp;imgtype=0&amp;src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-3b53822f82f3099fcd26bde1ea9bb995_1200x500.jpg"><meta property="og:type" content="article"><meta property="og:title" content="数据结构与算法"><meta property="og:url" content="https://www.google.com/2020/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="K的小屋"><meta property="og:description" content="数据结构与算法"><meta property="og:image" content="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1590562175309&amp;di=0ef43267d5571b2520bff72d0120bdab&amp;imgtype=0&amp;src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-3b53822f82f3099fcd26bde1ea9bb995_1200x500.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://www.google.com/2020/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><link rel="prev" title="《深入理解计算机系统》读书笔记" href="https://www.google.com/2020/06/11/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><link rel="next" title="Android源码分析——Dagger2（未完）" href="https://www.google.com/2020/05/25/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Dagger2%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Algorithm"><span class="toc-number">1.</span> <span class="toc-text">Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#排序算法"><span class="toc-number">1.1.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单排序"><span class="toc-number">1.1.1.</span> <span class="toc-text">简单排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#冒泡排序"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择排序"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入排序"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">插入排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂排序"><span class="toc-number">1.1.2.</span> <span class="toc-text">复杂排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#希尔排序"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#归并排序"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#快速排序"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">快速排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找算法（暂略）"><span class="toc-number">1.2.</span> <span class="toc-text">查找算法（暂略）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线性表"><span class="toc-number">1.3.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#顺序表"><span class="toc-number">1.3.1.</span> <span class="toc-text">顺序表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表"><span class="toc-number">1.3.2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单链表"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双链表"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">双链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#练习题"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#单链表的反转"><span class="toc-number">1.3.2.3.1.</span> <span class="toc-text">单链表的反转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#求链表的中间节点"><span class="toc-number">1.3.2.3.2.</span> <span class="toc-text">求链表的中间节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#链表中环的检测"><span class="toc-number">1.3.2.3.3.</span> <span class="toc-text">链表中环的检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#找出有环单链表的入口"><span class="toc-number">1.3.2.3.4.</span> <span class="toc-text">找出有环单链表的入口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#两个有序链表的合并"><span class="toc-number">1.3.2.3.5.</span> <span class="toc-text">两个有序链表的合并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#删除链表倒数第n个节点"><span class="toc-number">1.3.2.3.6.</span> <span class="toc-text">删除链表倒数第n个节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#约瑟夫问题"><span class="toc-number">1.3.2.3.7.</span> <span class="toc-text">约瑟夫问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈"><span class="toc-number">1.3.3.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#栈的基本使用"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">栈的基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈的练习"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">栈的练习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#括号匹配问题"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">括号匹配问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#逆波兰表达式"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">逆波兰表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列"><span class="toc-number">1.3.4.</span> <span class="toc-text">队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#符号表"><span class="toc-number">1.4.</span> <span class="toc-text">符号表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无序符号表"><span class="toc-number">1.4.1.</span> <span class="toc-text">无序符号表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序符号表"><span class="toc-number">1.4.2.</span> <span class="toc-text">有序符号表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树"><span class="toc-number">1.5.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#树的基本概念和分类"><span class="toc-number">1.5.1.</span> <span class="toc-text">树的基本概念和分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉查找树"><span class="toc-number">1.5.2.</span> <span class="toc-text">二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#增删改"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">增删改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#前中后序遍历"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">前中后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#层序遍历"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#求树的深度问题"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">求树的深度问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆"><span class="toc-number">1.5.3.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆操作（插入-删除）"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">堆操作（插入&#x2F;删除）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆排序"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优先队列"><span class="toc-number">1.5.4.</span> <span class="toc-text">优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#最大优先队列"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">最大优先队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最小优先队列"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">最小优先队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#索引最小优先队列-暂略"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">索引最小优先队列(暂略)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#索引最大优先队列-暂略"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">索引最大优先队列(暂略)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3查找树"><span class="toc-number">1.5.5.</span> <span class="toc-text">2-3查找树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#红黑树"><span class="toc-number">1.5.6.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B树"><span class="toc-number">1.5.7.</span> <span class="toc-text">B树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树"><span class="toc-number">1.5.8.</span> <span class="toc-text">B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并查集"><span class="toc-number">1.5.9.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第一个版本"><span class="toc-number">1.5.9.1.</span> <span class="toc-text">第一个版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化版本"><span class="toc-number">1.5.9.2.</span> <span class="toc-text">优化版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并查集案例：畅通工程"><span class="toc-number">1.5.9.3.</span> <span class="toc-text">并查集案例：畅通工程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图"><span class="toc-number">1.6.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无向图"><span class="toc-number">1.6.1.</span> <span class="toc-text">无向图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#深度优先遍历"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">深度优先遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#广度优先遍历"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">广度优先遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#畅通工程"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">畅通工程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#路径查找"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">路径查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有向图"><span class="toc-number">1.6.2.</span> <span class="toc-text">有向图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#拓扑排序"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">拓扑排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加权无向图"><span class="toc-number">1.6.3.</span> <span class="toc-text">加权无向图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小生成树"><span class="toc-number">1.6.4.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#贪心算法"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#prim算法"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">prim算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kruskal算法"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">kruskal算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加权有向图"><span class="toc-number">1.6.5.</span> <span class="toc-text">加权有向图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最短路径-Dijkstra算法"><span class="toc-number">1.6.6.</span> <span class="toc-text">最短路径-Dijkstra算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#最小生成树和最短路径的区别"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">最小生成树和最短路径的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1590562175309&amp;di=0ef43267d5571b2520bff72d0120bdab&amp;imgtype=0&amp;src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-3b53822f82f3099fcd26bde1ea9bb995_1200x500.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">K的小屋</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">数据结构与算法</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-27 12:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-27</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-18 14:49:02"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-18</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">24.1k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 110 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>时间复杂度：O(n^2)</p>
<p>稳定排序：是</p>
<p>排序原理：</p>
<blockquote>
<ol>
<li><p>比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。</p>
</li>
<li><p>对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。</p>
</li>
</ol>
</blockquote>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内元素进行排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (greater(a[j], a[j + <span class="number">1</span>])) &#123;</span><br><span class="line">                    exchange(a, j, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，所以i和索引j处的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>时间复杂度：O(n^2)</p>
<p>是否稳定排序：否</p>
<p>排序原理：</p>
<blockquote>
<p>1.每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引</p>
<p>2.交换第一个索引处和最小值所在的索引处的值</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内元素进行排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (greater(a[minIndex], a[j])) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exchange(a, minIndex, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，所以i和索引j处的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>时间复杂度：O(n^2)</p>
<p>稳定排序：是</p>
<p>排序原理：</p>
<blockquote>
<p>1.把所有的元素分为两组，已经排序的和未排序的；</p>
<p>2.找到未排序的组中的第一个元素，向已经排序的组中进行插入；</p>
<p>3.<strong>倒序遍历</strong>已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位；</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内元素进行排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">//比较索引j和索引j-1的值，如果j-1处的值更大，则交换</span></span><br><span class="line">                <span class="keyword">if</span> (greater(a[j - <span class="number">1</span>], a[j])) &#123;</span><br><span class="line">                    exchange(a, j, j - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//这一句很重要！！！用作优化，不用继续往下面比较了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"c:"</span> + count);<span class="comment">//加break：16，不加break：28</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，所以i和索引j处的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂排序"><a href="#复杂排序" class="headerlink" title="复杂排序"></a>复杂排序</h3><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>排序说明：</p>
<blockquote>
<p>希尔排序是<strong>插入排序</strong>的一种，又称“缩小增量排序”，是插入排序算法的一种更高效的改进版本。</p>
</blockquote>
<p>时间复杂度：不确定</p>
<blockquote>
<p>在希尔排序中，增长量h并没有固定的规则，有很多论文研究了各种不同的递增序列，但都无法证明某个序列是最好的，对于希尔排序的时间复杂度分析，已经超出了我们课程设计的范畴，所以在这里就不做分析了。<br>我们可以使用事后分析法对希尔排序和插入排序做性能比较。</p>
</blockquote>
<p>稳定排序：否</p>
<p>排序原理：</p>
<blockquote>
<p>1.选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；</p>
<p>2.对分好组的每一组数据完成插入排序；</p>
<p>3.减小增长量，最小减为1，重复第二步操作。</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内元素进行排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//增长量 h的确定：增长量h的值没有一个固定的规则，我们这里采用以下规则</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; a.length / <span class="number">2</span>) &#123;</span><br><span class="line">            h = <span class="number">2</span> * h + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//真正的排序</span></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//1. 找到待插入的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; a.length; i++) &#123;</span><br><span class="line">                <span class="comment">//2. 把待插入的元素插入到有序数列中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h  <span class="comment">/*j &gt; 0*/</span>; j -= h) &#123;<span class="comment">// j &gt;= h与j &gt; 0的区别，必须是j&gt;=h，否则下面j-h有可能为负数</span></span><br><span class="line">                    <span class="keyword">if</span> (greater(a[j - h], a[j])) &#123;</span><br><span class="line">                        exchange(a, j, j - h);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">//这一句很重要！！！用作优化，不用继续往下面比较了</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，所以i和索引j处的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>希尔排序与插入排序对比</strong></p>
<p>10W个逆序的数组进行耗时判断</p>
<p>希尔排序：31毫秒</p>
<p>插入排序：31397毫秒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortCompare</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        InputStream inputStream = SortCompare.class.getClassLoader().getResourceAsStream("com/github/algorithm/reverse_arr.txt");</span><br><span class="line">        System.out.println(<span class="string">"inputStream:"</span> + inputStream);</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(Integer.parseInt(line));</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        System.out.println(<span class="string">"line:"</span> + list.size());</span><br><span class="line">        Integer[] arr = <span class="keyword">new</span> Integer[list.size()];</span><br><span class="line">        list.toArray(arr);</span><br><span class="line"></span><br><span class="line">        testShell(arr);<span class="comment">//测试希尔排序，31毫秒</span></span><br><span class="line"></span><br><span class="line">        testInsertion(arr);<span class="comment">//测试插入排序，31397毫秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInsertion</span><span class="params">(Integer[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Insertion.sort(a);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"插入排序执行时间："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testShell</span><span class="params">(Integer[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Shell.sort(a);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"希尔排序执行时间："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>排序说明：</p>
<blockquote>
<p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
</blockquote>
<p>时间复杂度：O(nlogn)</p>
<p>稳定排序：是</p>
<p>排序原理：</p>
<blockquote>
<p>1.尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。</p>
<p>2.将相邻的两个子组进行合并成一个有序的大组；</p>
<p>3.不断的重复步骤2，直到最终只有一个组为止。</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line">    <span class="comment">//完成归并操作所需要的辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] assist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内元素进行排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        assist = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组a从索引low到索引high之间的元素进行排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//分组</span></span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//分别对每一组数据进行排序</span></span><br><span class="line">        sort(a, low, mid);</span><br><span class="line">        sort(a, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">//再把两组中的数据进行合并</span></span><br><span class="line">        merge(a, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从索引low到索引mid为一个子组，从索引mid+1到索引high为另一个子组，把数组a中的两个子数组的数据合并成一个有序的大组（从low到high）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 定义三个指针</span></span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> p1 = low;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//2. 循环遍历</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[p1], a[p2])) &#123;</span><br><span class="line">                assist[i++] = a[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                assist[i++] = a[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 将没走完的数据填充到辅助数组中,下面连个while循环只会走一个</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">            assist[i++] = a[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= high) &#123;</span><br><span class="line">            assist[i++] = a[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4. 把辅助数组中的元素拷贝到原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = low; j &lt;= high; j++) &#123;</span><br><span class="line">            a[j] = assist[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否小于w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，所以i和索引j处的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>希尔排序、插入排序、归并排序对比</strong></p>
<p>10W个逆序的数组进行耗时判断</p>
<p>希尔排序：31毫秒</p>
<p>插入排序：31397毫秒</p>
<p>归并排序：39毫秒</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>排序说明：</p>
<blockquote>
<p>快速排序是对<strong>冒泡排序</strong>的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
</blockquote>
<p>时间复杂度：O(nlogn)</p>
<p>稳定排序：否</p>
<p>排序原理：</p>
<blockquote>
<p>1.首先设定一个分界值，通过该分界值将数组分成左右两部分；</p>
<p>2.将大于或等于分界值的数据放到到数组右边，小于分界值的数据放到数组的左边。此时左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值；</p>
<p>3.然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</p>
<p>4.重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。</p>
</blockquote>
<p>切分原理：</p>
<blockquote>
<p>把一个数组切分成两个子数组的基本思想：</p>
<p>1.找一个基准值，用两个指针分别指向数组的头部和尾部；</p>
<p>2.先从尾部向头部开始搜索一个比基准值小的元素，搜索到即停止，并记录指针的位置；</p>
<p>3.再从头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置；</p>
<p>4.交换当前左边指针位置和右边指针位置的元素；</p>
<p>5.重复2,3,4步骤，直到左边指针的值大于右边指针的值停止。</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line">    <span class="comment">//完成归并操作所需要的辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] assist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内元素进行排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        assist = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组a从索引low到索引high之间的元素进行排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> partition = partition(a, low, high);</span><br><span class="line">        <span class="comment">//让左子组有序</span></span><br><span class="line">        sort(a, low, partition - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//让右子组有序</span></span><br><span class="line">        sort(a, partition + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组a，从索引low到索引high进行分组，并返回分组界限对应的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//确定分界值</span></span><br><span class="line">        Comparable key = a[low];</span><br><span class="line">        <span class="keyword">int</span> left = low;</span><br><span class="line">        <span class="keyword">int</span> right = high + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//先从右往左扫描，移动right指针，直到找到一个比key小的元素</span></span><br><span class="line">            <span class="keyword">while</span> (less(key, a[--right])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right == low) &#123;<span class="comment">//要加上判断条件</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再从左往右扫描，移动left指针，直到找到一个比key大的元素</span></span><br><span class="line">            <span class="keyword">while</span> (less(a[++left], key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left == high) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//走到这里表示已经找到了left和right，然后将其交换</span></span><br><span class="line">            <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//元素交换位置</span></span><br><span class="line">                exchange(a, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换分界值</span></span><br><span class="line">        exchange(a, low, right);<span class="comment">//或者exchange(a,low,left)</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否小于w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，所以i和索引j处的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试10W数据的时候报错：java.lang.StackOverflowError</p>
<h2 id="查找算法（暂略）"><a href="#查找算法（暂略）" class="headerlink" title="查找算法（暂略）"></a>查找算法（暂略）</h2><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><blockquote>
<p>线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为<strong>顺序表</strong>和<strong>链表</strong>。</p>
</blockquote>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><blockquote>
<p>顺序表是在计算机内存中以<strong>数组</strong>的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] eles;<span class="comment">//存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//当前顺序表的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建容量为capacity的SequenceList对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SequenceList</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        eles = (T[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eles[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == eles.length) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * eles.length);</span><br><span class="line">        &#125;</span><br><span class="line">        eles[N++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !!!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; N) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"插入位置不能超过最大length："</span> + N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (N == eles.length) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * eles.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---移位后前数据---"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(eles));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N; j &gt; i; j--) &#123;<span class="comment">//是j&gt;=i还是j&gt;i?，是j&gt;i</span></span><br><span class="line">            eles[j] = eles[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"---移位后数据---"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(eles));</span><br><span class="line"></span><br><span class="line">        eles[i] = t;</span><br><span class="line">        N++;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---插入后数据---"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(eles));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        T ele = eles[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            eles[j] = eles[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">if</span> (eles.length / <span class="number">4</span> &gt; N) &#123;</span><br><span class="line">            resize(eles.length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ele;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eles[i].equals(t)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整顺序表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        T[] ts = (T[]) <span class="keyword">new</span> Object[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            ts[i] = eles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        eles = ts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> eles[index++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SequenceList&lt;String&gt; list = <span class="keyword">new</span> SequenceList&lt;String&gt;(<span class="number">5</span>);</span><br><span class="line">        list.insert(<span class="string">"AA"</span>);</span><br><span class="line">        list.insert(<span class="string">"BB"</span>);</span><br><span class="line">        list.insert(<span class="string">"CC"</span>);</span><br><span class="line">        list.insert(<span class="string">"DD"</span>);</span><br><span class="line">        list.insert(<span class="string">"EE"</span>);</span><br><span class="line">        list.insert(<span class="number">2</span>, <span class="string">"FF"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list.get(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        System.out.println(list.remove(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        System.out.println(list.length());</span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        System.out.println(list.length());</span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小结：</p>
<blockquote>
<p>get(i):不难看出，不论数据元素量N有多大，只需要一次eles[i]就可以获取到对应的元素，所以时间复杂度为O(1);</p>
<p>insert(int i,T t):每一次插入，都需要把i位置后面的元素移动一次，随着元素数量N的增大，移动的元素也越多，时间复杂为O(n);</p>
<p>remove(int i):每一次删除，都需要把i位置后面的元素移动一次，随着数据量N的增大,移动的元素也越多，时间复杂度为O(n);</p>
<p>由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题越明显。</p>
</blockquote>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><blockquote>
<p>单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; head;<span class="comment">//我们假定头结点是不可以存放数据，即data和null都为空</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//链表长度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node&lt;T&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        head.data = <span class="keyword">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        Node&lt;T&gt; node = head.next;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; i) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(t, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.next = newNode;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt; node = head;</span><br><span class="line">        <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, T t)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(t, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        Node&lt;T&gt; pre = head;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; i) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"index-&gt;"</span> + index + <span class="string">",pre--&gt;"</span> + pre.data);</span><br><span class="line">        newNode.next = pre.next;</span><br><span class="line">        pre.next = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        Node&lt;T&gt; pre = head;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; i) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; removeNode = pre.next;</span><br><span class="line">        pre.next = removeNode.next;</span><br><span class="line">        <span class="keyword">return</span> removeNode.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; node.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">if</span> (node.data.equals(t)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T data;</span><br><span class="line">        Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">return</span> node.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkList&lt;String&gt; list = <span class="keyword">new</span> LinkList&lt;String&gt;();</span><br><span class="line">        list.insert(<span class="string">"AA"</span>);</span><br><span class="line">        list.insert(<span class="string">"BB"</span>);</span><br><span class="line">        list.insert(<span class="string">"CC"</span>);</span><br><span class="line">        list.insert(<span class="string">"DD"</span>);</span><br><span class="line">        list.insert(<span class="string">"EE"</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(list.get(<span class="number">2</span>));</span><br><span class="line">        System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line">        System.out.println(list.get(<span class="number">4</span>));</span><br><span class="line">        <span class="comment">//System.out.println(list.get(5));</span></span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.insert(<span class="number">2</span>, <span class="string">"GG"</span>);</span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        list.remove(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        System.out.println(list.indexOf(<span class="string">"DD"</span>));</span><br><span class="line">        System.out.println(list.indexOf(<span class="string">"ABC"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><blockquote>
<p>双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoWayLinkList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; head;<span class="comment">//记录首节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; last;<span class="comment">//记录尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//链表长度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoWayLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node&lt;T&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        head.pre = <span class="keyword">null</span>;</span><br><span class="line">        head.data = <span class="keyword">null</span>;</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            Node&lt;T&gt; newNode = <span class="keyword">new</span> Node&lt;T&gt;(t, head, <span class="keyword">null</span>);</span><br><span class="line">            head.next = newNode;</span><br><span class="line">            last = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            Node&lt;T&gt; oldLast = last;</span><br><span class="line">            Node&lt;T&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(t, oldLast, <span class="keyword">null</span>);</span><br><span class="line">            oldLast.next = newNode;</span><br><span class="line">            last = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, T t)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; pre = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; i; index++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(t, pre, pre.next);</span><br><span class="line">        pre.next = newNode;</span><br><span class="line">        pre.next.pre = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; i; index++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; node.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">if</span> (node.data.equals(t)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; pre = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; i; index++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; returnNode = pre.next;</span><br><span class="line">        pre.next = returnNode.next;</span><br><span class="line">        returnNode.next.pre = pre;</span><br><span class="line">        <span class="keyword">return</span> returnNode.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T data;</span><br><span class="line">        Node&lt;T&gt; next;</span><br><span class="line">        Node&lt;T&gt; pre;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; pre, Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.pre = pre;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">return</span> node.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>测试：</p>
<ul>
<li>和单链表的测试类一样，这里就不贴出来了。</li>
</ul>
<p>小结：</p>
<blockquote>
<p>get(int i):每一次查询，都需要从链表的头部开始，依次向后查找，随着数据元素N的增多，比较的元素越多，时间复杂度为O(n)</p>
<p>insert(int i,T t):每一次插入，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂度为O(n);</p>
<p>remove(int i):每一次移除，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂度为O(n)；</p>
<p>相比较顺序表，链表插入和删除的时间复杂度虽然一样，但仍然有很大的优势，因为链表的物理地址是不连续的，它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作,同时它并没有涉及的元素的交换。</p>
<p>相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。</p>
</blockquote>
<h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><h5 id="单链表的反转"><a href="#单链表的反转" class="headerlink" title="单链表的反转"></a>单链表的反转</h5><p>单链表的反转，是面试中的一个高频题目。<br>需求：<br>原链表中数据为：1-&gt;2-&gt;3&gt;4<br>反转后链表中数据为： 4-&gt;3-&gt;2-&gt;1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseLinkList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; head;<span class="comment">//我们假定头结点是不可以存放数据，即data和null都为空</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//链表长度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReverseLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node&lt;T&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        head.data = <span class="keyword">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        Node&lt;T&gt; node = head.next;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; i) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(t, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.next = newNode;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt; node = head;</span><br><span class="line">        <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, T t)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(t, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        Node&lt;T&gt; pre = head;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; i) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"index-&gt;"</span> + index + <span class="string">",pre--&gt;"</span> + pre.data);</span><br><span class="line">        newNode.next = pre.next;</span><br><span class="line">        pre.next = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        Node&lt;T&gt; pre = head;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; i) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; removeNode = pre.next;</span><br><span class="line">        pre.next = removeNode.next;</span><br><span class="line">        <span class="keyword">return</span> removeNode.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; node.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">if</span> (node.data.equals(t)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对整个链表进行翻转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        reverse(head.next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻转链表中的某个节点curr，并把翻转后的curr节点返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> curr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;T&gt; <span class="title">reverse</span><span class="params">(Node&lt;T&gt; curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.next = curr;</span><br><span class="line">            <span class="keyword">return</span> curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归的翻转当前节点curr的下一个节点，返回值就是链表翻转后，当前节点的上一个节点</span></span><br><span class="line">        Node&lt;T&gt; pre = reverse(curr.next);</span><br><span class="line">        <span class="comment">//让返回的节点的下一个节点为当期节点</span></span><br><span class="line">        pre.next = curr;</span><br><span class="line">        <span class="comment">//当前节点的下一个节点返回为null</span></span><br><span class="line">        curr.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T data;</span><br><span class="line">        Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">return</span> node.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseLinkListTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReverseLinkList&lt;Integer&gt; list = <span class="keyword">new</span> ReverseLinkList&lt;&gt;();</span><br><span class="line">        list.insert(<span class="number">1</span>);</span><br><span class="line">        list.insert(<span class="number">2</span>);</span><br><span class="line">        list.insert(<span class="number">3</span>);</span><br><span class="line">        list.insert(<span class="number">4</span>);</span><br><span class="line">        list.insert(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"------反转之前------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            System.out.print(integer + <span class="string">"-&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------反转之后------"</span>);</span><br><span class="line">        list.reverse();</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            System.out.print(integer + <span class="string">"-&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出：</p>
<blockquote>
<p>——反转之前——<br>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;<br>——反转之后——<br>5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;</p>
</blockquote>
<h5 id="求链表的中间节点"><a href="#求链表的中间节点" class="headerlink" title="求链表的中间节点"></a>求链表的中间节点</h5><blockquote>
<p>快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以让我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找出单链表中的中间值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkListMidValueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Node&lt;String&gt; first = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"aa"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; second = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"bb"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; third = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"cc"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; fourth = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"dd"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; fifth = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"ee"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; six = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"ff"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; seven = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"gg"</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//完成结点之间的指向</span></span><br><span class="line">        first.next = second;</span><br><span class="line">        second.next = third;</span><br><span class="line">        third.next = fourth;</span><br><span class="line">        fourth.next = fifth;</span><br><span class="line">        fifth.next = six;</span><br><span class="line">        six.next = seven;</span><br><span class="line">        <span class="comment">//查找中间值</span></span><br><span class="line">        String mid = getMid(first);</span><br><span class="line">        System.out.println(<span class="string">"中间值为："</span> + mid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> first 链表的首结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表的中间结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMid</span><span class="params">(Node&lt;String&gt; first)</span> </span>&#123;</span><br><span class="line">        Node&lt;String&gt; p1 = first;</span><br><span class="line">        Node&lt;String&gt; p2 = first;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//存储数据</span></span><br><span class="line">        T item;</span><br><span class="line">        <span class="comment">//下一个结点</span></span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T item, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="链表中环的检测"><a href="#链表中环的检测" class="headerlink" title="链表中环的检测"></a>链表中环的检测</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表是否有环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkListIsCircleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Node&lt;String&gt; first = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"aa"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; second = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"bb"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; third = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"cc"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; fourth = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"dd"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; fifth = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"ee"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; six = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"ff"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; seven = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"gg"</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//完成结点之间的指向</span></span><br><span class="line">        first.next = second;</span><br><span class="line">        second.next = third;</span><br><span class="line">        third.next = fourth;</span><br><span class="line">        fourth.next = fifth;</span><br><span class="line">        fifth.next = six;</span><br><span class="line">        six.next = seven;</span><br><span class="line">        <span class="comment">//产生环</span></span><br><span class="line">        seven.next = third;</span><br><span class="line">        <span class="comment">//判断链表是否有环</span></span><br><span class="line">        <span class="keyword">boolean</span> circle = isCircle(first);</span><br><span class="line">        System.out.println(<span class="string">"链表中是否有环："</span> + circle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断链表中是否有环</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> first 链表首结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ture为有环，false为无环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCircle</span><span class="params">(Node&lt;String&gt; first)</span> </span>&#123;</span><br><span class="line">        Node&lt;String&gt; fast = first;</span><br><span class="line">        Node&lt;String&gt; slow = first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法1：</span></span><br><span class="line">        <span class="comment">/*while (true) &#123;</span></span><br><span class="line"><span class="comment">            if (slow.next == null) &#123;</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            fast = fast.next;</span></span><br><span class="line"><span class="comment">            slow = slow.next.next;</span></span><br><span class="line"><span class="comment">            if (fast.equals(slow)) &#123;</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">//方法2：</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast.equals(slow)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//存储数据</span></span><br><span class="line">        T item;</span><br><span class="line">        <span class="comment">//下一个结点</span></span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T item, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="找出有环单链表的入口"><a href="#找出有环单链表的入口" class="headerlink" title="找出有环单链表的入口"></a>找出有环单链表的入口</h5><blockquote>
<p>当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样为1，则慢指针与“新”指针相遇的地方就是环的入口。证明这一结论牵涉到数论的知识，这里略，只讲实现。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有环链表入口问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkListCircleEnterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Node&lt;String&gt; first = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"aa"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; second = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"bb"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; third = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"cc"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; fourth = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"dd"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; fifth = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"ee"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; six = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"ff"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node&lt;String&gt; seven = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">"gg"</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//完成结点之间的指向</span></span><br><span class="line">        first.next = second;</span><br><span class="line">        second.next = third;</span><br><span class="line">        third.next = fourth;</span><br><span class="line">        fourth.next = fifth;</span><br><span class="line">        fifth.next = six;</span><br><span class="line">        six.next = seven;</span><br><span class="line">        <span class="comment">//产生环</span></span><br><span class="line">        seven.next = fourth;</span><br><span class="line">        <span class="comment">//查找环的入口结点</span></span><br><span class="line">        Node&lt;String&gt; entrance = getEntrance(first);</span><br><span class="line">        <span class="keyword">if</span> (entrance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表中环的入口结点元素为："</span> + entrance.item);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表没有环"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找有环链表中环的入口结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> first 链表首结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 环的入口结点, 返回null表示没有环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getEntrance</span><span class="params">(Node&lt;String&gt; first)</span> </span>&#123;</span><br><span class="line">        Node&lt;String&gt; temp = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;String&gt; fast = first;</span><br><span class="line">        Node&lt;String&gt; slow = first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (slow.equals(fast)) &#123;</span><br><span class="line">                temp = first;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">                <span class="keyword">if</span> (temp.equals(slow)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//存储数据</span></span><br><span class="line">        T item;</span><br><span class="line">        <span class="comment">//下一个结点</span></span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T item, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="两个有序链表的合并"><a href="#两个有序链表的合并" class="headerlink" title="两个有序链表的合并"></a>两个有序链表的合并</h5><h5 id="删除链表倒数第n个节点"><a href="#删除链表倒数第n个节点" class="headerlink" title="删除链表倒数第n个节点"></a>删除链表倒数第n个节点</h5><h5 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h5><blockquote>
<p>41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。</p>
<p>1.编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈；</p>
<p>2.自退出那个人开始的下一个人再次从1开始报数，以此类推；</p>
<p>3.求出最后退出的那个人的编号。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JosephTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//总共的人数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PERSON_NUM = <span class="number">41</span>;</span><br><span class="line">    <span class="comment">//规则，每多少个人出局</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RULE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用来记录首节点</span></span><br><span class="line">        Node&lt;Integer&gt; first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//用来记录前一个节点</span></span><br><span class="line">        Node&lt;Integer&gt; pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= PERSON_NUM; i++) &#123;</span><br><span class="line">            <span class="comment">//如果是第一个</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                first = <span class="keyword">new</span> Node&lt;&gt;(<span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line">                pre = first;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Node&lt;Integer&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(i, <span class="keyword">null</span>);</span><br><span class="line">            pre.next = newNode;</span><br><span class="line">            pre = newNode;</span><br><span class="line">            <span class="keyword">if</span> (i == PERSON_NUM) &#123;</span><br><span class="line">                newNode.next = first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点遍历</span></span><br><span class="line">        print(first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备开始按照规则输出</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">        Node&lt;Integer&gt; node = first;</span><br><span class="line">        Node&lt;Integer&gt; before = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != node.next) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count == RULE) &#123;</span><br><span class="line">                System.out.println(<span class="string">"第"</span> + (number++) + <span class="string">"次移除当前元素："</span> + node.item);</span><br><span class="line">                before.next = node.next;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                before = node;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"最后一个元素："</span> + node.item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Node&lt;Integer&gt; node)</span> </span>&#123;</span><br><span class="line">        Node&lt;Integer&gt; begin = node;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(node.item + <span class="string">"--&gt;"</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">if</span> (node.equals(begin)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//存储数据</span></span><br><span class="line">        T item;</span><br><span class="line">        <span class="comment">//下一个结点</span></span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T item, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。</p>
<p>我们称数据进入到栈的动作为<strong>压栈</strong>，数据从栈中出去的动作为<strong>弹栈</strong>。</p>
<blockquote>
<p>栈是一种逻辑层面的数据结构，而物理存储结构有两种：顺序存储结构和链式存储结构，顺序存储结构对应于数组，链式存储结构对应于链表。所以栈的实现既可以用数组也可以用链表实现，这里我们使用链表。</p>
</blockquote>
<h4 id="栈的基本使用"><a href="#栈的基本使用" class="headerlink" title="栈的基本使用"></a>栈的基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stock</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; head;<span class="comment">//记录首节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//当前栈的元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node&lt;T&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T data;</span><br><span class="line">        Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; returnNode = head.next;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> returnNode.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(t, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.next = newNode;</span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode.next = head.next;</span><br><span class="line">        head.next = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        Node&lt;T&gt; n;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n.next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> n.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stock&lt;String&gt; stock = <span class="keyword">new</span> Stock&lt;&gt;();</span><br><span class="line">        stock.push(<span class="string">"a"</span>);</span><br><span class="line">        stock.push(<span class="string">"b"</span>);</span><br><span class="line">        stock.push(<span class="string">"c"</span>);</span><br><span class="line">        stock.push(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"size:"</span> + stock.size());</span><br><span class="line">        <span class="keyword">for</span> (String s : stock) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">"--&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line"></span><br><span class="line">        String pop = stock.pop();</span><br><span class="line">        System.out.println(<span class="string">"pop:"</span> + pop);</span><br><span class="line">        System.out.println(<span class="string">"pop:"</span> + stock.pop());</span><br><span class="line">        System.out.println(<span class="string">"pop:"</span> + stock.pop());</span><br><span class="line">        System.out.println(<span class="string">"pop:"</span> + stock.pop());</span><br><span class="line">        System.out.println(<span class="string">"pop:"</span> + stock.pop());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : stock) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">"--&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="栈的练习"><a href="#栈的练习" class="headerlink" title="栈的练习"></a>栈的练习</h4><h4 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2020/6/3 14:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 栈_案例_括号匹配问题, 给定一个字符串，里边可能包含"()"小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BracketsMatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(isMatch(<span class="string">"(上海)(长安)"</span>));</span><br><span class="line">        System.out.println(isMatch(<span class="string">"上海((长安))"</span>));</span><br><span class="line">        System.out.println(isMatch(<span class="string">"上海(长安(北京)(深圳)南京)"</span>));</span><br><span class="line">        System.out.println(isMatch(<span class="string">"上海(长安))"</span>));</span><br><span class="line">        System.out.println(isMatch(<span class="string">"((上海)长安"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stock&lt;String&gt; stock = <span class="keyword">new</span> Stock&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            String ch = s.charAt(i) + <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">if</span> (ch.equals(<span class="string">"("</span>)) &#123;</span><br><span class="line">                stock.push(ch);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch.equals(<span class="string">")"</span>)) &#123;</span><br><span class="line">                String pop = stock.pop();</span><br><span class="line">                <span class="keyword">if</span> (pop == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stock.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 2020/6/3 14:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:栈_案例_逆波兰表达式,给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePolishNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//中缀表达式3*（17-15）+18/6的逆波兰表达式如下:9</span></span><br><span class="line">        String[] notation = &#123;<span class="string">"3"</span>, <span class="string">"17"</span>, <span class="string">"15"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"18"</span>, <span class="string">"6"</span>, <span class="string">"/"</span>, <span class="string">"+"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result = calculate(notation);</span><br><span class="line">        System.out.println(<span class="string">"逆波兰表达式的结果为："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String[] notation)</span> </span>&#123;</span><br><span class="line">        Stock&lt;Integer&gt; stock = <span class="keyword">new</span> Stock&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : notation) &#123;</span><br><span class="line">            Integer p1;</span><br><span class="line">            Integer p2;</span><br><span class="line">            <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                    p1 = stock.pop();</span><br><span class="line">                    p2 = stock.pop();</span><br><span class="line">                    stock.push(p2 + p1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                    p1 = stock.pop();</span><br><span class="line">                    p2 = stock.pop();</span><br><span class="line">                    stock.push(p2 - p1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                    p1 = stock.pop();</span><br><span class="line">                    p2 = stock.pop();</span><br><span class="line">                    stock.push(p2 * p1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                    p1 = stock.pop();</span><br><span class="line">                    p2 = stock.pop();</span><br><span class="line">                    stock.push(p2 / p1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    stock.push(Integer.parseInt(s));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stock.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/3 14:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：队列，先进先出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往队列中插入一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = <span class="keyword">new</span> Node(t, <span class="keyword">null</span>);</span><br><span class="line">            head.next = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node oldLast = last;</span><br><span class="line">            last = <span class="keyword">new</span> Node(t, <span class="keyword">null</span>);</span><br><span class="line">            oldLast.next = last;</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中拿出一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object item = head.next.item;</span><br><span class="line">            head = head.next;</span><br><span class="line">            N--;</span><br><span class="line">            <span class="keyword">return</span> (T) item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T item;</span><br><span class="line">        Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T item, Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;T&gt; n;</span><br><span class="line"></span><br><span class="line">        QIterator() &#123;</span><br><span class="line">            n = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n.next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> n.item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/3 14:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：队列的测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        queue.enqueue(<span class="string">"a"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"b"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"c"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">        System.out.println(queue.dequeue());</span><br><span class="line">         <span class="comment">/* System.out.println(queue.dequeue());</span></span><br><span class="line"><span class="comment">        System.out.println(queue.dequeue());</span></span><br><span class="line"><span class="comment">        System.out.println(queue.dequeue());</span></span><br><span class="line"><span class="comment">        System.out.println(queue.dequeue());*/</span></span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str : queue) &#123;</span><br><span class="line">            System.out.print(str + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><blockquote>
<p>符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的键值对数据，我们可以根据键来查找对应的值。</p>
<p>符号表的实现既可以是数组也可以是链表，这里我们用链表形式实现。</p>
</blockquote>
<h3 id="无序符号表"><a href="#无序符号表" class="headerlink" title="无序符号表"></a>无序符号表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/3 15:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：符号表</span></span><br><span class="line"><span class="comment"> * 符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的键值对数据，我们可以根据键来查找对应的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymbolTable</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//记录首节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//记录长度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SymbolTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; n = head;</span><br><span class="line">        <span class="keyword">while</span> (n.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n.k.equals(k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> n.v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        Node n = head;</span><br><span class="line">        <span class="keyword">while</span> (n.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n.k.equals(k)) &#123;</span><br><span class="line">                n.v = v;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//要求新的key要插到队列首部</span></span><br><span class="line">        <span class="comment">//n.next = new Node(k, v, null);</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(k, v, <span class="keyword">null</span>);</span><br><span class="line">        Node oldFirst = head.next;</span><br><span class="line">        newNode.next = oldFirst;</span><br><span class="line">        head.next = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        Node n = head;</span><br><span class="line">        <span class="keyword">while</span> (n.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n.next.k.equals(k)) &#123;</span><br><span class="line">                n.next = n.next.next;</span><br><span class="line">                N--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K k, V v, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymbolTableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SymbolTable&lt;Integer, String&gt; symbolTable = <span class="keyword">new</span> SymbolTable&lt;&gt;();</span><br><span class="line">        symbolTable.put(<span class="number">1</span>, <span class="string">"zs"</span>);</span><br><span class="line">        symbolTable.put(<span class="number">2</span>, <span class="string">"ls"</span>);</span><br><span class="line">        symbolTable.put(<span class="number">3</span>, <span class="string">"ww"</span>);</span><br><span class="line">        symbolTable.put(<span class="number">4</span>, <span class="string">"zl"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(symbolTable.get(<span class="number">4</span>));</span><br><span class="line">        System.out.println(symbolTable.get(<span class="number">3</span>));</span><br><span class="line">        System.out.println(symbolTable.get(<span class="number">2</span>));</span><br><span class="line">        System.out.println(symbolTable.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(symbolTable.get(<span class="number">0</span>));</span><br><span class="line">        symbolTable.delete(<span class="number">3</span>);</span><br><span class="line">        System.out.println(symbolTable.get(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="有序符号表"><a href="#有序符号表" class="headerlink" title="有序符号表"></a>有序符号表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSymbolTable</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; head;<span class="comment">//记录首节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//记录长度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderSymbolTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; n = head;</span><br><span class="line">        <span class="keyword">while</span> (n.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n.k.equals(k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> n.v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; curr = head.next;</span><br><span class="line">        Node&lt;K, V&gt; pre = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span> &amp;&amp; k.compareTo(curr.k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相等的情况</span></span><br><span class="line">        <span class="keyword">if</span> (curr != <span class="keyword">null</span> &amp;&amp; k.compareTo(curr.k) == <span class="number">0</span>) &#123;</span><br><span class="line">            curr.v = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新插入的值要插在pre后面，curr前面</span></span><br><span class="line">        Node&lt;K, V&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(k, v, <span class="keyword">null</span>);</span><br><span class="line">        pre.next = newNode;</span><br><span class="line">        newNode.next = curr;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        Node n = head;</span><br><span class="line">        <span class="keyword">while</span> (n.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n.next.k.equals(k)) &#123;</span><br><span class="line">                n.next = n.next.next;</span><br><span class="line">                N--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node n = head;</span><br><span class="line">        <span class="keyword">while</span> (n.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            System.out.print(n.k + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K k, V v, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSymbolTableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OrderSymbolTable&lt;Integer, String&gt; symbolTable = <span class="keyword">new</span> OrderSymbolTable&lt;&gt;();</span><br><span class="line">        symbolTable.put(<span class="number">1</span>, <span class="string">"zs"</span>);</span><br><span class="line">        symbolTable.put(<span class="number">2</span>, <span class="string">"ls"</span>);</span><br><span class="line">        symbolTable.put(<span class="number">4</span>, <span class="string">"ww"</span>);</span><br><span class="line">        symbolTable.put(<span class="number">5</span>, <span class="string">"zl"</span>);</span><br><span class="line">        symbolTable.put(<span class="number">3</span>, <span class="string">"qs"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(symbolTable.size());</span><br><span class="line">        <span class="comment">//通过debug调试</span></span><br><span class="line">        System.out.println(symbolTable.get(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        symbolTable.print();<span class="comment">//1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的基本概念和分类"><a href="#树的基本概念和分类" class="headerlink" title="树的基本概念和分类"></a>树的基本概念和分类</h3><blockquote>
<p>二叉树的基本定义：二叉树就是度不超过 2的树(每个结点最多有两个子结点)</p>
</blockquote>
<p>满二叉树</p>
<blockquote>
<p>一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。</p>
</blockquote>
<p>完全二叉树</p>
<blockquote>
<p>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树</p>
</blockquote>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><blockquote>
<p>二叉树的实现，既可以用数组实现，也可以用链表实现，这里我们使用链表实现，后面讲堆的时候在，再讲如何使用数组进行实现。</p>
</blockquote>
<p>二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。是数据结构中的一类。在一般情况下，查询效率比链表结构要高。</p>
<p>定义：</p>
<blockquote>
<p>一棵空树，或者是具有下列性质的<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">二叉树</a>：</p>
<p>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
<p>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>（3）左、右子树也分别为二叉排序树；</p>
<p>（4）没有键值相等的结点。</p>
</blockquote>
<h4 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h4><p>定义二叉查找树的增删改操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;Key, Value&gt; root;<span class="comment">//记录根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//记录树中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">        Key key;<span class="comment">//存储键</span></span><br><span class="line">        Value value;<span class="comment">//存储值</span></span><br><span class="line">        Node&lt;Key, Value&gt; left;<span class="comment">//记录左子节点</span></span><br><span class="line">        Node&lt;Key, Value&gt; right;<span class="comment">//记录右子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, Node left, Node right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//像树中插入一个键值对</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">        root = put(root, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给指定树x上，添加建一个键值对，并返回添加后的新树</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用</span></span><br><span class="line"><span class="comment">        2.如果当前树不为空，则从根结点开始：</span></span><br><span class="line"><span class="comment">            2.1如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；</span></span><br><span class="line"><span class="comment">            2.2如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；</span></span><br><span class="line"><span class="comment">            2.3如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node&lt;Key, Value&gt; x, Key key, Value value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.如果当前树不为空</span></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x.right = put(x.right, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x.left = put(x.left, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据key，从树中找出对应的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从指定树x中，找出key对应的值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；</span></span><br><span class="line"><span class="comment">        2.如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；</span></span><br><span class="line"><span class="comment">        3.如果要查询的key等于当前结点的key，则树中返回当前结点的value。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node&lt;Key, Value&gt; x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据key，删除树中对应的键值对</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        delete(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定树x上的键为key的键值对，并返回删除后的新树</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.找到被删除结点；</span></span><br><span class="line"><span class="comment">        2.找到被删除结点右子树中的最小结点minNode</span></span><br><span class="line"><span class="comment">        3.删除右子树中的最小结点</span></span><br><span class="line"><span class="comment">        4.让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树</span></span><br><span class="line"><span class="comment">        5.让被删除结点的父节点指向最小结点minNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node&lt;Key, Value&gt; x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x.left = delete(x.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x.right = delete(x.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            N--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果找到的节点x没有右孩子则返回左子树</span></span><br><span class="line">            <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> x.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> x.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//minNode记录x右子树最小的元素</span></span><br><span class="line">            Node minNode = x.right;</span><br><span class="line">            <span class="keyword">while</span> (minNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                minNode = minNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除minNode节点</span></span><br><span class="line">            Node deleteNode = x.right;</span><br><span class="line">            <span class="keyword">while</span> (deleteNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (deleteNode.left.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    deleteNode.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    deleteNode = deleteNode.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让minNode成为x节点的位置</span></span><br><span class="line">            minNode.left = x.left;</span><br><span class="line">            minNode.right = x.right;</span><br><span class="line">            x = minNode;<span class="comment">//这句话很关键，让x节点的腹肌诶单指向minNode</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出树中最小的键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min(root).key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在指定树x中找出最小键所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;Key, Value&gt; <span class="title">min</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> min(x.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出树中最大的键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max(root).key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在指定树x中找出最小键所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;Key, Value&gt; <span class="title">max</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> max(x.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryTree&lt;Integer, String&gt; tree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        tree.put(<span class="number">1</span>, <span class="string">"zs"</span>);</span><br><span class="line">        tree.put(<span class="number">2</span>, <span class="string">"ls"</span>);</span><br><span class="line">        tree.put(<span class="number">3</span>, <span class="string">"ww"</span>);</span><br><span class="line">        tree.put(<span class="number">4</span>, <span class="string">"zl"</span>);</span><br><span class="line">        System.out.println(tree.size());</span><br><span class="line">        System.out.println(tree.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(tree.get(<span class="number">2</span>));</span><br><span class="line">        System.out.println(tree.get(<span class="number">3</span>));</span><br><span class="line">        System.out.println(tree.get(<span class="number">4</span>));</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        tree.delete(<span class="number">4</span>);</span><br><span class="line">        System.out.println(tree.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(tree.get(<span class="number">2</span>));</span><br><span class="line">        System.out.println(tree.get(<span class="number">3</span>));</span><br><span class="line">        System.out.println(tree.get(<span class="number">4</span>));</span><br><span class="line">        <span class="comment">//找出最小键</span></span><br><span class="line">        System.out.println(tree.min());</span><br><span class="line">        <span class="comment">//找出最大键</span></span><br><span class="line">        System.out.println(tree.max());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//...</span></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue&lt;Key&gt; <span class="title">preErgodic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Queue&lt;Key&gt; keys = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">       preErgodic(root, keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取指定树x的所有键，并放到keys队列中</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preErgodic</span><span class="params">(Node&lt;Key, Value&gt; x, Queue&lt;Key&gt; keys)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">       <span class="keyword">if</span> (x.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">           preErgodic(x.left, keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (x.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           preErgodic(x.right, keys);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//中序遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue&lt;Key&gt; <span class="title">midErgodic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Queue&lt;Key&gt; keys = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">       midErgodic(root, keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">midErgodic</span><span class="params">(Node&lt;Key, Value&gt; x, Queue&lt;Key&gt; keys)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (x.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">           midErgodic(x.left, keys);</span><br><span class="line">       &#125;</span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">       <span class="keyword">if</span> (x.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           midErgodic(x.right, keys);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//后序遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue&lt;Key&gt; <span class="title">afterErgodic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Queue&lt;Key&gt; keys = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">       afterErgodic(root, keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterErgodic</span><span class="params">(Node&lt;Key, Value&gt; x, Queue&lt;Key&gt; keys)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (x.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">           afterErgodic(x.left, keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (x.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           afterErgodic(x.right, keys);</span><br><span class="line">       &#125;</span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeErgodicTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryTree&lt;String, String&gt; tree = <span class="keyword">new</span> BinaryTree&lt;&gt;();</span><br><span class="line">        tree.put(<span class="string">"E"</span>, <span class="string">"5"</span>);</span><br><span class="line">        tree.put(<span class="string">"B"</span>, <span class="string">"2"</span>);</span><br><span class="line">        tree.put(<span class="string">"G"</span>, <span class="string">"7"</span>);</span><br><span class="line">        tree.put(<span class="string">"A"</span>, <span class="string">"1"</span>);</span><br><span class="line">        tree.put(<span class="string">"D"</span>, <span class="string">"4"</span>);</span><br><span class="line">        tree.put(<span class="string">"F"</span>, <span class="string">"6"</span>);</span><br><span class="line">        tree.put(<span class="string">"H"</span>, <span class="string">"8"</span>);</span><br><span class="line">        tree.put(<span class="string">"C"</span>, <span class="string">"3"</span>);</span><br><span class="line">        <span class="comment">//前序遍历</span></span><br><span class="line">        Queue&lt;String&gt; queue = tree.preErgodic();</span><br><span class="line">        <span class="keyword">for</span> (String s : queue) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">" "</span>);<span class="comment">//E B A D C G F H</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        Queue&lt;String&gt; midQueue = tree.midErgodic();</span><br><span class="line">        <span class="keyword">for</span> (String s : midQueue) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">" "</span>);<span class="comment">//A B C D E F G H</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        Queue&lt;String&gt; afterQueue = tree.afterErgodic();</span><br><span class="line">        <span class="keyword">for</span> (String s : afterQueue) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">" "</span>);<span class="comment">//A C D B F H G E</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.创建队列，存储每一层的结点；</span></span><br><span class="line"><span class="comment">2.使用循环从队列中弹出一个结点：</span></span><br><span class="line"><span class="comment">    2.1获取当前结点的key；</span></span><br><span class="line"><span class="comment">    2.2如果当前结点的左子结点不为空，则把左子结点放入到队列中</span></span><br><span class="line"><span class="comment">    2.3如果当前结点的右子结点不为空，则把右子结点放入到队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue&lt;Key&gt; <span class="title">layerErgodic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;Key&gt; keys = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">    Queue&lt;Node&gt; nodes = <span class="keyword">new</span> Queue&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    nodes.enqueue(root);</span><br><span class="line">    <span class="keyword">while</span> (!nodes.isEmpty()) &#123;</span><br><span class="line">        Node&lt;Key, Value&gt; dequeue = nodes.dequeue();</span><br><span class="line">        keys.enqueue(dequeue.key);</span><br><span class="line">        <span class="keyword">if</span> (dequeue.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nodes.enqueue(dequeue.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dequeue.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nodes.enqueue(dequeue.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="求树的深度问题"><a href="#求树的深度问题" class="headerlink" title="求树的深度问题"></a>求树的深度问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxDepth(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">计算指定树x的最大深度：</span></span><br><span class="line"><span class="comment">    1.如果根结点为空，则最大深度为0；</span></span><br><span class="line"><span class="comment">    2.计算左子树的最大深度；</span></span><br><span class="line"><span class="comment">    3.计算右子树的最大深度；</span></span><br><span class="line"><span class="comment">    4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node&lt;Key, Value&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        maxLeft = maxDepth(x.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        maxRight = maxDepth(x.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxLeft &gt; maxRight) &#123;</span><br><span class="line">        max = maxLeft + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = maxRight + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>堆的定义：<br>堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一棵完全二叉树的数组对象。</p>
<p>堆的特性：</p>
<ol>
<li><p>它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。</p>
</li>
<li><p>它通常用数组来实现。<br>具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子结点则分别在位置4,5,6和7，以此类推。如果一个结点的位置为k，则它的父结点的位置为[k/2],而它的两个子结点的位置则分别为2k和2k+1。这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k/2,向下一层就令k等于2k或2k+1。</p>
</li>
<li><p><strong>每个结点都大于等于它的两个子结点</strong>。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。</p>
</li>
</ol>
</blockquote>
<h4 id="堆操作（插入-删除）"><a href="#堆操作（插入-删除）" class="headerlink" title="堆操作（插入/删除）"></a>堆操作（插入/删除）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第0个位置不存放数据</span></span><br><span class="line">        items = (T[]) <span class="keyword">new</span> Comparable[capacity + <span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        T temp = items[j];</span><br><span class="line">        items[j] = items[i];</span><br><span class="line">        items[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除堆中最大的元素，并返回这个值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        当删除掉最大元素后，只需要将最后一个元素放到索引 1处，并不断的拿着当前结点a[k]与它的子结点a[2k]和a[2k+1]中的较大者交换位置，即可完成堆的有序调整</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T max = items[<span class="number">1</span>];</span><br><span class="line">        exchange(<span class="number">1</span>, N);</span><br><span class="line">        items[N] = <span class="keyword">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往堆中插入一个元素</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果往堆中新插入元素，我们只需要不断的比较新结点 a[k]和它的父结点a[k/2]的大小，然后根据结果完成数据元素的交换，就可以完成堆的有序调整</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用上浮算法，使索引k除的元素能在堆中处于一个正确的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(k / <span class="number">2</span>, k)) &#123;</span><br><span class="line">                exchange(k / <span class="number">2</span>, k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用下沉算法，使索引k除的元素能在堆中处于一个正确的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt; N) &#123;</span><br><span class="line">            <span class="keyword">int</span> max;<span class="comment">//记录较大位置</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k, <span class="number">2</span> * k + <span class="number">1</span>)) &#123;</span><br><span class="line">                    max = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span> * k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span> * k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前节点比左右子节点都要大，则退出</span></span><br><span class="line">            <span class="keyword">if</span> (!less(k, max)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exchange(k, max);</span><br><span class="line">            <span class="comment">//变换k</span></span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T item : items) &#123;</span><br><span class="line">            System.out.print(item + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//堆的插入</span></span><br><span class="line">        Heap&lt;String&gt; heap = <span class="keyword">new</span> Heap&lt;String&gt;(<span class="number">20</span>);</span><br><span class="line">        heap.insert(<span class="string">"T"</span>);</span><br><span class="line">        heap.insert(<span class="string">"P"</span>);</span><br><span class="line">        heap.insert(<span class="string">"R"</span>);</span><br><span class="line">        heap.insert(<span class="string">"N"</span>);</span><br><span class="line">        heap.insert(<span class="string">"H"</span>);</span><br><span class="line">        heap.insert(<span class="string">"O"</span>);</span><br><span class="line">        heap.insert(<span class="string">"A"</span>);</span><br><span class="line">        heap.insert(<span class="string">"E"</span>);</span><br><span class="line">        heap.insert(<span class="string">"I"</span>);</span><br><span class="line">        heap.insert(<span class="string">"G"</span>);</span><br><span class="line">        heap.print();</span><br><span class="line">        heap.insert(<span class="string">"S"</span>);</span><br><span class="line">        heap.print();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        <span class="comment">//堆的删除</span></span><br><span class="line">        Heap&lt;String&gt; heap2 = <span class="keyword">new</span> Heap&lt;String&gt;(<span class="number">20</span>);</span><br><span class="line">        heap2.insert(<span class="string">"T"</span>);</span><br><span class="line">        heap2.insert(<span class="string">"S"</span>);</span><br><span class="line">        heap2.insert(<span class="string">"R"</span>);</span><br><span class="line">        heap2.insert(<span class="string">"P"</span>);</span><br><span class="line">        heap2.insert(<span class="string">"N"</span>);</span><br><span class="line">        heap2.insert(<span class="string">"O"</span>);</span><br><span class="line">        heap2.insert(<span class="string">"A"</span>);</span><br><span class="line">        heap2.insert(<span class="string">"E"</span>);</span><br><span class="line">        heap2.insert(<span class="string">"I"</span>);</span><br><span class="line">        heap2.insert(<span class="string">"H"</span>);</span><br><span class="line">        heap2.insert(<span class="string">"G"</span>);</span><br><span class="line">        heap2.print();</span><br><span class="line">        String max = heap2.delMax();</span><br><span class="line">        System.out.println(max);</span><br><span class="line">        heap2.print();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/9 11:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：堆排序</span></span><br><span class="line"><span class="comment"> * 对构造好的堆，我们只需要做类似于堆的删除操作，就可以完成排序。</span></span><br><span class="line"><span class="comment"> * 1.将堆顶元素和堆中最后一个元素交换位置；</span></span><br><span class="line"><span class="comment"> * 2.通过对堆顶元素下沉调整堆，把最大的元素放到堆顶(此时最后一个元素不参与堆的调整，因为最大的数据已经到了数组的最右边)</span></span><br><span class="line"><span class="comment"> * 3.重复1~2步骤，直到堆中剩最后一个元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//对source数组进行从小到大堆排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] source)</span> </span>&#123;</span><br><span class="line">        Comparable[] heap = <span class="keyword">new</span> Comparable[source.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//构造堆</span></span><br><span class="line">        createHeap(source, heap);</span><br><span class="line">        <span class="comment">//堆排序</span></span><br><span class="line">        <span class="keyword">int</span> N = heap.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (N != <span class="number">1</span>) &#123;</span><br><span class="line">            exchange(heap, <span class="number">1</span>, N);</span><br><span class="line">            N--;</span><br><span class="line">            sink(heap, <span class="number">1</span>, N);</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(heap, <span class="number">1</span>, source, <span class="number">0</span>, source.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable[] heap, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[i].compareTo(heap[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换堆中i和j处的索引处的值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable[] heap, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable temp = heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据原数组，构造出有序堆heap</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(Comparable[] source, Comparable[] heap)</span> </span>&#123;</span><br><span class="line">        System.arraycopy(source, <span class="number">0</span>, heap, <span class="number">1</span>, source.length);</span><br><span class="line">        <span class="comment">//对heap数组长度一半的位置之前进行下沉调整</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heap.length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sink(heap, i, heap.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        print(heap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在heap堆中，对target处的元素做下沉，范围是0-range</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] heap, <span class="keyword">int</span> target, <span class="keyword">int</span> range)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * target &lt;= range) &#123;</span><br><span class="line">            <span class="keyword">int</span> max;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * target + <span class="number">1</span> &lt;= range) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(heap, <span class="number">2</span> * target, <span class="number">2</span> * target + <span class="number">1</span>)) &#123;</span><br><span class="line">                    max = <span class="number">2</span> * target + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span> * target;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span> * target;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!less(heap, target, max)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exchange(heap, target, max);</span><br><span class="line">            target = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Comparable[] heap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heap.length; i++) &#123;</span><br><span class="line">            System.out.printf(heap[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSortTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">"S"</span>, <span class="string">"O"</span>, <span class="string">"R"</span>, <span class="string">"T"</span>, <span class="string">"E"</span>, <span class="string">"X"</span>, <span class="string">"A"</span>, <span class="string">"M"</span>, <span class="string">"P"</span>, <span class="string">"L"</span>, <span class="string">"E"</span>&#125;;</span><br><span class="line">        HeapSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>null X T S P L R A M O E E<br>[A, E, E, L, M, O, P, R, S, T, X]</p>
</blockquote>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><blockquote>
<p>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在某些情况下，我们可能需要找出队列中的最大值或者最小值，例如使用一个队列保存计算机的任务，一般情况下计算机的任务都是有优先级的，我们需要在这些计算机的任务中找出优先级最高的任务先执行，执行完毕后就需要把这个任务从队列中移除。普通的队列要完成这样的功能，需要每次遍历队列中的所有元素，比较并找出最大值，效率不是很高，这个时候，我们就可以使用一种特殊的队列来完成这种需求，优先队列。</p>
</blockquote>
<p>我们之前学习过堆，而堆这种结构是可以方便的删除最大的值，所以，接下来我们可以基于堆区实现最大优先队列。</p>
<h4 id="最大优先队列"><a href="#最大优先队列" class="headerlink" title="最大优先队列"></a>最大优先队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPriorityQueue</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPriorityQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> Comparable[capacity];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换堆中i和j处的索引处的值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        T temp = items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T max = items[<span class="number">1</span>];</span><br><span class="line">        exchange(<span class="number">1</span>, N);</span><br><span class="line">        N--;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上浮算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(k / <span class="number">2</span>, k)) &#123;</span><br><span class="line">                exchange(k / <span class="number">2</span>, k);</span><br><span class="line">            &#125;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下沉算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">            <span class="keyword">int</span> max;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k, <span class="number">2</span> * k + <span class="number">1</span>)) &#123;</span><br><span class="line">                    max = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span> * k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span> * k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!less(k, max)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exchange(k, max);</span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPriorityQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MaxPriorityQueue&lt;String&gt; queue = <span class="keyword">new</span> MaxPriorityQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        queue.insert(<span class="string">"G"</span>);</span><br><span class="line">        queue.insert(<span class="string">"E"</span>);</span><br><span class="line">        queue.insert(<span class="string">"B"</span>);</span><br><span class="line">        queue.insert(<span class="string">"A"</span>);</span><br><span class="line">        queue.insert(<span class="string">"F"</span>);</span><br><span class="line">        queue.insert(<span class="string">"D"</span>);</span><br><span class="line">        queue.insert(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            System.out.printf(queue.delMax() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出：</p>
<blockquote>
<p>G F E D C B A </p>
</blockquote>
<h4 id="最小优先队列"><a href="#最小优先队列" class="headerlink" title="最小优先队列"></a>最小优先队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinPriorityQueue</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinPriorityQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> Comparable[capacity + <span class="number">1</span>];<span class="comment">//TODO</span></span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换堆中i和j处的索引处的值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        T temp = items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">delMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T min = items[<span class="number">1</span>];</span><br><span class="line">        exchange(<span class="number">1</span>, N);</span><br><span class="line">        N--;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上浮算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(k, k / <span class="number">2</span>)) &#123;</span><br><span class="line">                exchange(k, k / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下沉算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">            <span class="keyword">int</span> min;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k, <span class="number">2</span> * k + <span class="number">1</span>)) &#123;</span><br><span class="line">                    min = <span class="number">2</span> * k;<span class="comment">//TODO</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    min = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min = <span class="number">2</span> * k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (less(k, min)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exchange(k, min);</span><br><span class="line">            k = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinPriorityQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinPriorityQueue&lt;String&gt; queue = <span class="keyword">new</span> MinPriorityQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        queue.insert(<span class="string">"G"</span>);</span><br><span class="line">        queue.insert(<span class="string">"E"</span>);</span><br><span class="line">        queue.insert(<span class="string">"B"</span>);</span><br><span class="line">        queue.insert(<span class="string">"A"</span>);</span><br><span class="line">        queue.insert(<span class="string">"F"</span>);</span><br><span class="line">        queue.insert(<span class="string">"D"</span>);</span><br><span class="line">        queue.insert(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            System.out.printf(queue.delMin() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出：</p>
<blockquote>
<p>A C D E F B G </p>
</blockquote>
<h4 id="索引最小优先队列-暂略"><a href="#索引最小优先队列-暂略" class="headerlink" title="索引最小优先队列(暂略)"></a>索引最小优先队列(暂略)</h4><blockquote>
<p>索引优先队列</p>
<p>在之前实现的最大优先队列和最小优先队列，他们可以分别快速访问到队列中最大元素和最小元素，但是他们有一个缺点，就是没有办法通过索引访问已存在于优先队列中的对象，并更新它们。为了实现这个目的，在优先队列的基础上，学习一种新的数据结构，索引优先队列。接下来我们以最小索引优先队列举列。</p>
</blockquote>
<p><strong>索引优先队列实现思路</strong></p>
<p>步骤一：<br>存储数据时，给每一个数据元素关联一个整数，例如insert(int k,T t),我们可以看做k是t关联的整数，那么我们的实现需要通过k这个值，快速获取到队列中t这个元素，此时有个k这个值需要具有唯一性。<br>最直观的想法就是我们可以用一个T[] items数组来保存数据元素，在insert(int k,T t)完成插入时，可以把k看做是items数组的索引，把t元素放到items数组的索引k处，这样我们再根据k获取元素t时就很方便了，直接就可以拿到items[k]即可。</p>
<p>步骤二：<br>步骤一完成后的结果，虽然我们给每个元素关联了一个整数，并且可以使用这个整数快速的获取到该元素，但是，items数组中的元素顺序是随机的，并不是堆有序的，所以，为了完成这个需求，我们可以增加一个数组int[]pq,来保存每个元素在items数组中的索引，pq数组需要堆有序，也就是说，pq[1]对应的数据元素items[pq[1]]要小于等于pq[2]和pq[3]对应的数据元素items[pq[2]]和items[pq[3]]。</p>
<p>步骤三：<br>通过步骤二的分析，我们可以发现，其实我们通过上浮和下沉做堆调整的时候，其实调整的是pq数组。如果需要对items中的元素进行修改，比如让items[0]=“H”,那么很显然，我们需要对pq中的数据做堆调整，而且是调整pq[9]中元素的位置。但现在就会遇到一个问题，我们修改的是items数组中0索引处的值，如何才能快速的知道需要挑中pq[9]中元素的位置呢？<br>最直观的想法就是遍历pq数组，拿出每一个元素和0做比较，如果当前元素是0，那么调整该索引处的元素即可，但是效率很低。<br>我们可以另外增加一个数组，int[] qp,用来存储pq的逆序。例如：<br>在pq数组中：pq[1]=6;<br>那么在qp数组中，把6作为索引，1作为值，结果是：qp[6]=1;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexMinPriorityQueue</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">//保存每个元素在items数组中的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] pq;</span><br><span class="line">    <span class="comment">//保存pq数组的逆序，pq的值为索引，pq的索引作为值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] qp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexMinPriorityQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> Comparable[capacity];</span><br><span class="line">        pq = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        qp = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qp.length; i++) &#123;</span><br><span class="line">            qp[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[pq[i]].compareTo(items[pq[j]]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换堆中i和j处的索引处的值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//交换pq中的数据</span></span><br><span class="line">        <span class="keyword">int</span> temp = pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = temp;</span><br><span class="line">        <span class="comment">//更新qp中的数据</span></span><br><span class="line">        qp[pq[i]] = j;</span><br><span class="line">        qp[pq[j]] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断k对应元素是否在qp数组中存在</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> qp[k] != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最小元素关联索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往队列中插入一个元素，并关联索引i</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (contains(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">        items[i] = t;</span><br><span class="line">        pq[N] = i;</span><br><span class="line">        qp[i] = N;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除队列中最小元素，并返回该元素的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = pq[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//交换pq中索引1处和最大索引处的元素</span></span><br><span class="line">        exchange(<span class="number">1</span>, N);</span><br><span class="line">        <span class="comment">//删除qp中对应内容</span></span><br><span class="line">        qp[pq[N]] = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//删除pq最大索引处内容</span></span><br><span class="line">        pq[N] = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//删除items中对应内容</span></span><br><span class="line">        items[minIndex] = <span class="keyword">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> minIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除索引i关联的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = qp[i];</span><br><span class="line">        exchange(k, N);</span><br><span class="line">        <span class="comment">//删除qp中对应内容</span></span><br><span class="line">        qp[pq[N]] = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//删除pq最大索引处内容</span></span><br><span class="line">        pq[N] = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//删除items中对应内容</span></span><br><span class="line">        <span class="comment">//items[pq[N]] = null;</span></span><br><span class="line">        items[k] = <span class="keyword">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        sink(k);</span><br><span class="line">        swim(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//把与索引i关联的元素修改成t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeItem</span><span class="params">(<span class="keyword">int</span> i, T t)</span> </span>&#123;</span><br><span class="line">        items[i] = t;</span><br><span class="line">        <span class="keyword">int</span> k = qp[i];</span><br><span class="line">        sink(k);</span><br><span class="line">        swim(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上浮算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(k, k / <span class="number">2</span>)) &#123;</span><br><span class="line">                exchange(k, k / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下沉算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">            <span class="keyword">int</span> min;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k, <span class="number">2</span> * k + <span class="number">1</span>)) &#123;</span><br><span class="line">                    min = <span class="number">2</span> * k;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    min = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min = <span class="number">2</span> * k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (less(k, min)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exchange(k, min);</span><br><span class="line">            k = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="索引最大优先队列-暂略"><a href="#索引最大优先队列-暂略" class="headerlink" title="索引最大优先队列(暂略)"></a>索引最大优先队列(暂略)</h4><h3 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h3><p>理解概念，不要求实现。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackTree</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedBlackTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前节点的父指向链接是否为红色</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左旋调整</span></span><br><span class="line">    <span class="comment">//左旋的情况：红链出现在右侧</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotateLeft</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">        Node x = h.right;<span class="comment">//x为h的右子节点</span></span><br><span class="line"></span><br><span class="line">        h.right = x.right;</span><br><span class="line">        x.left = h;</span><br><span class="line">        x.color = h.color;</span><br><span class="line">        h.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右旋调整</span></span><br><span class="line">    <span class="comment">//右旋的情况：两条红链同时出现在左侧</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotateRight</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">        Node x = h.left;<span class="comment">//x为h的左子节点</span></span><br><span class="line"></span><br><span class="line">        h.left = x.right;</span><br><span class="line">        x.right = h;</span><br><span class="line">        x.color = h.color;</span><br><span class="line">        h.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//颜色反转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        h.color = RED;</span><br><span class="line">        h.left.color = BLACK;</span><br><span class="line">        h.right.color = BLACK;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在整棵树上面完成插入操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">        root = put(root, key, value);</span><br><span class="line">        root.color = BLACK;<span class="comment">//根节点颜色总是黑色</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在指定树上面完成插入操作，并返回添加之后的数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node&lt;Key, Value&gt; h, Key key, Value value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>, key, value, RED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行节点比较</span></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(h.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            h.right = put(h.right, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            h.left = put(h.left, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分别进行左旋、右旋、颜色反转操作</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left)) &#123;</span><br><span class="line">            h = rotateLeft(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left)) &#123;</span><br><span class="line">            h = rotateRight(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right)) &#123;</span><br><span class="line">            flipColors(h);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据key，在树中找出对应位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Value) get(root, key);</span><br><span class="line">        <span class="comment">//todo:为什么要强转？</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从指定树x中，找出key对应的值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node&lt;Key, Value&gt; x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">        Node&lt;Key, Value&gt; left;</span><br><span class="line">        Node&lt;Key, Value&gt; right;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node left, Node right, Key key, Value value, <span class="keyword">boolean</span> color)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RedBlackTree&lt;String, String&gt; tree = <span class="keyword">new</span> RedBlackTree&lt;&gt;();</span><br><span class="line">        tree.put(<span class="string">"1"</span>, <span class="string">"张三"</span>);</span><br><span class="line">        tree.put(<span class="string">"2"</span>, <span class="string">"李四"</span>);</span><br><span class="line">        tree.put(<span class="string">"3"</span>, <span class="string">"王五"</span>);</span><br><span class="line">        System.out.println(tree.get(<span class="string">"1"</span>));</span><br><span class="line">        System.out.println(tree.get(<span class="string">"2"</span>));</span><br><span class="line">        System.out.println(tree.get(<span class="string">"3"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>理解概念和应用场景即可。</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>理解概念和应用场景即可。</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="第一个版本"><a href="#第一个版本" class="headerlink" title="第一个版本"></a>第一个版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] eleAndGroup;<span class="comment">//记录节点元素和元素所在分组的标识</span></span><br><span class="line">    <span class="keyword">int</span> count;<span class="comment">//记录并查集中数据的分组个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        count = N;</span><br><span class="line">        <span class="comment">//eleAndGroup数组索引为元素，值为所在分组</span></span><br><span class="line">        eleAndGroup = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            eleAndGroup[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断p和q是否在同一分组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eleAndGroup[p] == eleAndGroup[q];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回p所在的分组标识</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eleAndGroup[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接p、q到同一个分组中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connected(p, q)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pIndex = find(p);</span><br><span class="line">        <span class="keyword">int</span> qIndex = find(q);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eleAndGroup.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eleAndGroup[i] == qIndex) &#123;</span><br><span class="line">                eleAndGroup[i] = pIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UFTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"默认情况下UF有多少个分组："</span> + uf.count());</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入第一个要合并的元素："</span>);</span><br><span class="line">            <span class="keyword">int</span> p = scanner.nextInt();</span><br><span class="line">            System.out.println(<span class="string">"请输入第二个要合并的元素："</span>);</span><br><span class="line">            <span class="keyword">int</span> q = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(p, q)) &#123;</span><br><span class="line">                System.out.println(p + <span class="string">" 和 "</span> + q + <span class="string">"已经在同一个组中了"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            uf.union(p, q);</span><br><span class="line">            System.out.println(<span class="string">"此时并查集中有"</span> + uf.count() + <span class="string">"个分组"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="优化版本"><a href="#优化版本" class="headerlink" title="优化版本"></a>优化版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/15 13:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：一般像计算机这样网络型的数据，我们要求网络中的每两个数据之间都是相连通的，也就是说，</span></span><br><span class="line"><span class="comment"> * 我们需要调用很多次union方法，使得网络中所有数据相连，其实我们很容易可以得出，如果要让网络中的数据都相连，</span></span><br><span class="line"><span class="comment"> * 则我们至少要调用N-1次union方法才可以，但由于我们的union方法中使用for循环遍历了所有的元素，所以很明显，</span></span><br><span class="line"><span class="comment"> * 我们之前实现的合并算法的时间复杂度是O(N^2)，如果要解决大规模问题，它是不合适的，所以我们需要对算法进行优化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF_Tree</span> </span>&#123;</span><br><span class="line">    <span class="comment">//优化：1. 索引仍为元素值，2：eleAndGroup[i]值为该节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] eleAndGroup;<span class="comment">//记录节点元素和元素所在分组的标识</span></span><br><span class="line">    <span class="keyword">int</span> count;<span class="comment">//记录并查集中数据的分组个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF_Tree</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        count = N;</span><br><span class="line">        <span class="comment">//eleAndGroup数组索引为元素，值为所在分组</span></span><br><span class="line">        eleAndGroup = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            eleAndGroup[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断p和q是否在同一分组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eleAndGroup[p] == eleAndGroup[q];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回p所在的分组标识</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == eleAndGroup[p]) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = eleAndGroup[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接p、q到同一个分组中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pRootIndex = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRootIndex = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRootIndex == qRootIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        eleAndGroup[pRootIndex] = qRootIndex;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UFTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UF_Tree uf = <span class="keyword">new</span> UF_Tree(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"默认情况下UF有多少个分组："</span> + uf.count());</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入第一个要合并的元素："</span>);</span><br><span class="line">            <span class="keyword">int</span> p = scanner.nextInt();</span><br><span class="line">            System.out.println(<span class="string">"请输入第二个要合并的元素："</span>);</span><br><span class="line">            <span class="keyword">int</span> q = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(p, q)) &#123;</span><br><span class="line">                System.out.println(p + <span class="string">" 和 "</span> + q + <span class="string">"已经在同一个组中了"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            uf.union(p, q);</span><br><span class="line">            System.out.println(<span class="string">"此时并查集中有"</span> + uf.count() + <span class="string">"个分组"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="并查集案例：畅通工程"><a href="#并查集案例：畅通工程" class="headerlink" title="并查集案例：畅通工程"></a>并查集案例：畅通工程</h4><blockquote>
<p>省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。<br>省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/15 13:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：UF_Tree中最坏情况下union算法的时间复杂度为O(N^2)，其最主要的问题在于最坏情况下，</span></span><br><span class="line"><span class="comment"> * 树的深度和数组的大小一样，如果我们能够通过一些算法让合并时，生成的树的深度尽可能的小，就可以优化find方法。</span></span><br><span class="line"><span class="comment"> * 之前我们在union算法中，合并树的时候将任意的一棵树连接到了另外一棵树，这种合并方法是比较暴力的，</span></span><br><span class="line"><span class="comment"> * 如果我们把并查集中每一棵树的大小记录下来，然后在每次合并树的时候，把较小的树连接到较大的树上，就可以减小树的深度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF_Tree_Weighted</span> </span>&#123;</span><br><span class="line">    <span class="comment">//优化：1. 索引仍为元素值，2：eleAndGroup[i]值为该节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] eleAndGroup;<span class="comment">//记录节点元素和元素所在分组的标识</span></span><br><span class="line">    <span class="keyword">int</span> count;<span class="comment">//记录并查集中数据的分组个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sz;<span class="comment">//存储每个根节点对应的树中的元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF_Tree_Weighted</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        count = N;</span><br><span class="line">        <span class="comment">//eleAndGroup数组索引为元素，值为所在分组</span></span><br><span class="line">        eleAndGroup = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            eleAndGroup[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sz = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz.length; i++) &#123;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断p和q是否在同一分组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eleAndGroup[p] == eleAndGroup[q];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回p所在的分组标识</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == eleAndGroup[p]) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = eleAndGroup[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接p、q到同一个分组中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pRootIndex = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRootIndex = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRootIndex == qRootIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sz[pRootIndex] &lt; sz[qRootIndex]) &#123;</span><br><span class="line">            eleAndGroup[pRootIndex] = qRootIndex;</span><br><span class="line">            sz[qRootIndex] += sz[pRootIndex];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            eleAndGroup[qRootIndex] = pRootIndex;</span><br><span class="line">            sz[pRootIndex] += sz[qRootIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Traffic_Project</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入流</span></span><br><span class="line">        InputStream inputStream = Traffic_Project.class.getClassLoader().getResourceAsStream("traffic_project.txt");</span><br><span class="line">        System.out.println(<span class="string">"inputStream:"</span> + inputStream);</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">        <span class="comment">//读取城市数目，初始化并查集</span></span><br><span class="line">        <span class="keyword">int</span> number = Integer.parseInt(reader.readLine());</span><br><span class="line">        UF_Tree_Weighted uf = <span class="keyword">new</span> UF_Tree_Weighted(number);</span><br><span class="line">        <span class="comment">//读取已经修建好的道路数目</span></span><br><span class="line">        <span class="keyword">int</span> roadNumber = Integer.parseInt(reader.readLine());</span><br><span class="line">        <span class="comment">//循环读取已经修建好的道路，并调用union方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; roadNumber; i++) &#123;</span><br><span class="line">            String line = reader.readLine();</span><br><span class="line">            <span class="keyword">int</span> p = Integer.parseInt(line.split(<span class="string">" "</span>)[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> q = Integer.parseInt(line.split(<span class="string">" "</span>)[<span class="number">1</span>]);</span><br><span class="line">            uf.union(p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取剩余的分组数量</span></span><br><span class="line">        <span class="keyword">int</span> groupNumber = uf.count();</span><br><span class="line">        <span class="comment">//计算出还需要修建的道路</span></span><br><span class="line">        System.out.println(<span class="string">"还需要修建"</span> + (groupNumber - <span class="number">1</span>) + <span class="string">"道路，城市才能相通"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>traffic_project.txt文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">7</span><br><span class="line">0 1</span><br><span class="line">6 9</span><br><span class="line">3 8</span><br><span class="line">5 11</span><br><span class="line">2 12</span><br><span class="line">6 10</span><br><span class="line">4 8</span><br></pre></td></tr></table></figure>



<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/15 18:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：无向图,使用邻接表实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt;[] adj;<span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">int</span> V;<span class="comment">//包含的顶点数量</span></span><br><span class="line">    <span class="keyword">int</span> E;<span class="comment">//边的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = <span class="keyword">new</span> Queue[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> Queue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取和顶点v相邻的所有顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[V];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向图中添加一条边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        adj[v].enqueue(w);</span><br><span class="line">        adj[w].enqueue(v);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/15 18:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：图_深度优先搜索.</span></span><br><span class="line"><span class="comment"> * 所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点。</span></span><br><span class="line"><span class="comment"> * 可以使用一个布尔类型的数组 boolean[V] marked,索引代表顶点，值代表当前顶点是否已经搜索，如果已经搜索，标记为true，如果没有搜索，标记为false；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//记录有多少个顶点与s顶点相通</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstSearch</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.V];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        dfs(graph, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用深度优先搜索找出g图中v顶点的所有相通顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;Integer&gt; adj = graph.adj(v);</span><br><span class="line">        <span class="keyword">for</span> (Integer w : adj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked(w)) &#123;</span><br><span class="line">                dfs(graph, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断w顶点是否与s顶点相通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">marked</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取与顶点s相通的所有顶点的总数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/15 18:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：深度优先搜索测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(<span class="number">13</span>);</span><br><span class="line">        graph.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        graph.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        graph.addEdge(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        graph.addEdge(<span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">        graph.addEdge(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        graph.addEdge(<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">        graph.addEdge(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        graph.addEdge(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">        graph.addEdge(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">        graph.addEdge(<span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        graph.addEdge(<span class="number">9</span>, <span class="number">11</span>);</span><br><span class="line">        graph.addEdge(<span class="number">9</span>, <span class="number">12</span>);</span><br><span class="line">        graph.addEdge(<span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"原始图一共有边："</span> + graph.E());</span><br><span class="line"></span><br><span class="line">        DepthFirstSearch search = <span class="keyword">new</span> DepthFirstSearch(graph, <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"与起点0相通的顶点数量为："</span> + search.count());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"0是否与5相通"</span> + search.marked(<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="string">"0是否与7相通"</span> + search.marked(<span class="number">7</span>));</span><br><span class="line">        System.out.println(<span class="string">"0是否与4相通"</span> + search.marked(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/15 18:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：图_广度优先搜索.</span></span><br><span class="line"><span class="comment"> * 所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后找子结点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreadFirstSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//记录有多少个顶点与s顶点相通</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; waitSearch;<span class="comment">//用来存储待搜索邻接表的点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadFirstSearch</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.V];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        waitSearch = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        bfs(graph, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用深度优先搜索找出g图中v顶点的所有相通顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        waitSearch.enqueue(v);</span><br><span class="line">        <span class="keyword">while</span> (!waitSearch.isEmpty()) &#123;</span><br><span class="line">            Integer wait = waitSearch.dequeue();</span><br><span class="line">            Queue&lt;Integer&gt; adj = graph.adj(wait);</span><br><span class="line">            <span class="keyword">for</span> (Integer w : adj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!marked(w)) &#123;</span><br><span class="line">                    bfs(graph, w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断w顶点是否与s顶点相通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">marked</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取与顶点s相通的所有顶点的总数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/15 18:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：广度优先搜索测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreadFirstSearchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(<span class="number">13</span>);</span><br><span class="line">        graph.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        graph.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        graph.addEdge(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        graph.addEdge(<span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">        graph.addEdge(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        graph.addEdge(<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">        graph.addEdge(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        graph.addEdge(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">        graph.addEdge(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">        graph.addEdge(<span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        graph.addEdge(<span class="number">9</span>, <span class="number">11</span>);</span><br><span class="line">        graph.addEdge(<span class="number">9</span>, <span class="number">12</span>);</span><br><span class="line">        graph.addEdge(<span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"原始图一共有边："</span> + graph.E());</span><br><span class="line"></span><br><span class="line">        DepthFirstSearch search = <span class="keyword">new</span> DepthFirstSearch(graph, <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"与起点0相通的顶点数量为："</span> + search.count());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"0是否与5相通"</span> + search.marked(<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="string">"0是否与7相通"</span> + search.marked(<span class="number">7</span>));</span><br><span class="line">        System.out.println(<span class="string">"0是否与4相通"</span> + search.marked(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="畅通工程"><a href="#畅通工程" class="headerlink" title="畅通工程"></a>畅通工程</h4><p>判断两个城市是否连通：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Traffic_Project2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入流</span></span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span></span><br><span class="line">                InputStreamReader(Traffic_Project2.class.getClassLoader().getResourceAsStream("traffic_project.txt")));</span><br><span class="line">        <span class="comment">//读取城市数目，初始化Graph图</span></span><br><span class="line">        <span class="keyword">int</span> number = Integer.parseInt(reader.readLine());</span><br><span class="line">        Graph G = <span class="keyword">new</span> Graph(number);</span><br><span class="line">        <span class="comment">//读取已经修建好的道路数目</span></span><br><span class="line">        <span class="keyword">int</span> roadNumber = Integer.parseInt(reader.readLine());</span><br><span class="line">        <span class="comment">//循环读取已经修建好的道路，并调用addEdge方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; roadNumber; i++) &#123;</span><br><span class="line">            String line = reader.readLine();</span><br><span class="line">            <span class="keyword">int</span> p = Integer.parseInt(line.split(<span class="string">" "</span>)[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> q = Integer.parseInt(line.split(<span class="string">" "</span>)[<span class="number">1</span>]);</span><br><span class="line">            G.addEdge(p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据图G和顶点9构建图的搜索对象</span></span><br><span class="line">        <span class="comment">//BreadthFirstSearch search = new BreadthFirstSearch(G,9);</span></span><br><span class="line">        DepthFirstSearch search = <span class="keyword">new</span> DepthFirstSearch(G, <span class="number">9</span>);</span><br><span class="line">        <span class="comment">//调用搜索对象的marked(10)方法和marked(8)方法</span></span><br><span class="line">        <span class="keyword">boolean</span> flag1 = search.marked(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">boolean</span> flag2 = search.marked(<span class="number">8</span>);</span><br><span class="line">        System.out.println(<span class="string">"9号城市和10号城市是否已相通："</span> + flag1);</span><br><span class="line">        System.out.println(<span class="string">"9号城市和8号城市是否已相通："</span> + flag2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>traffic_project.txt文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">7</span><br><span class="line">0 1</span><br><span class="line">6 9</span><br><span class="line">3 8</span><br><span class="line">5 11</span><br><span class="line">2 12</span><br><span class="line">6 10</span><br><span class="line">4 8</span><br></pre></td></tr></table></figure>

<h4 id="路径查找"><a href="#路径查找" class="headerlink" title="路径查找"></a>路径查找</h4><blockquote>
<p>在实际生活中，地图是我们经常使用的一种工具，通常我们会用它进行导航，输入一个出发城市，输入一个目的地城市，就可以把路线规划好，而在规划好的这个路线上，会路过很多中间的城市。这类问题翻译成专业问题就是：<br>从s顶点到v顶点是否存在一条路径？如果存在，请找出这条路径。</p>
</blockquote>
<p><strong>1. 深度优先搜索实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/16 12:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：路径查找</span></span><br><span class="line"><span class="comment"> * 在实际生活中，地图是我们经常使用的一种工具，通常我们会用它进行导航，输入一个出发城市，输入一个目的地城市，就可以把路线规划好，</span></span><br><span class="line"><span class="comment"> * 而在规划好的这个路线上，会路过很多中间的城市。这类问题翻译成专业问题就是：</span></span><br><span class="line"><span class="comment"> * 从s顶点到v顶点是否存在一条路径？如果存在，请找出这条路径。</span></span><br><span class="line"><span class="comment"> * 这个API是基于深度优先搜索实现的，当然也可以基于广度优先搜索实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstPaths</span> </span>&#123;</span><br><span class="line">    <span class="comment">//索引代表顶点，值代表是否已经被搜索过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s;<span class="comment">//起点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;<span class="comment">//索引代表顶点，值代表起点s到当前顶点路径上的最后一个顶点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造深度优先搜索对象，使用深度优先搜索找出G图中起点为s的所有路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstPaths</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.V()];</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[graph.V()];</span><br><span class="line">        dfs(graph, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用深度优先搜索找出G图中v顶点所有的相邻顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;Integer&gt; adj = graph.adj(v);</span><br><span class="line">        <span class="keyword">for</span> (Integer w : adj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(graph, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断顶点v与顶点s是否存在路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出从起点s到顶点v的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stack&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x]) &#123;</span><br><span class="line">            stack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(s);</span><br><span class="line">        <span class="keyword">return</span> stack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstPathsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入流</span></span><br><span class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(DepthFirstPathsTest.class.getClassLoader().getResourceAsStream("com/github/algorithm/road_find.txt")));</span><br><span class="line">        <span class="comment">//读取城市数目，初始化Graph图</span></span><br><span class="line">        <span class="keyword">int</span> number = Integer.parseInt(reader.readLine());</span><br><span class="line">        Graph G = <span class="keyword">new</span> Graph(number);</span><br><span class="line">        <span class="comment">//读取已经修建好的道路数目</span></span><br><span class="line">        <span class="keyword">int</span> roadNumber = Integer.parseInt(reader.readLine());</span><br><span class="line">        <span class="comment">//循环读取已经修建好的道路，并调用addEdge方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; roadNumber; i++) &#123;</span><br><span class="line">            String line = reader.readLine();</span><br><span class="line">            <span class="keyword">int</span> p = Integer.parseInt(line.split(<span class="string">" "</span>)[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> q = Integer.parseInt(line.split(<span class="string">" "</span>)[<span class="number">1</span>]);</span><br><span class="line">            G.addEdge(p, q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DepthFirstPaths paths = <span class="keyword">new</span> DepthFirstPaths(G, <span class="number">0</span>);</span><br><span class="line">        Stack&lt;Integer&gt; path = paths.pathTo(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">while</span> (!path.empty()) &#123;</span><br><span class="line">            System.out.println(path.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>road_find.txt文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>





<p><strong>2. 广度优先搜索实现</strong></p>
<h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/17 9:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：有向图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Digraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt;[] adj;<span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V;<span class="comment">//包含的顶点数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;<span class="comment">//边的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Digraph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = v;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = <span class="keyword">new</span> Queue[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向有向图中添加一条边v-&gt;w</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        adj[v].enqueue(w);</span><br><span class="line">        E++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取由v指出的边所连接的所有顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在api中设计了一个反向图，其因为有向图的实现中，用adj方法获取出来的是由当前顶点v指向的其他顶点，如果能得到其反向图，就可以很容易得到指向v的其他顶点。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Digraph <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Digraph digraph = <span class="keyword">new</span> Digraph(<span class="keyword">this</span>.V);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer w : adj[v]) &#123;</span><br><span class="line">                digraph.addEdge(w, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> digraph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>完成拓扑排序需要先完成两个前置工作：1. 判断是否有环 2. 顶点排序</p>
<ol>
<li><p>判断是否有环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/17 10:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：检查有向环API</span></span><br><span class="line"><span class="comment"> * 检测有向环实现</span></span><br><span class="line"><span class="comment"> * 在API中添加了onStack[] 布尔数组，索引为图的顶点，当我们深度搜索时：</span></span><br><span class="line"><span class="comment"> * 1. 在如果当前顶点正在搜索，则把对应的onStack数组中的值改为true，标识进栈；</span></span><br><span class="line"><span class="comment"> * 2. 如果当前顶点搜索完毕，则把对应的onStack数组中的值改为false，标识出栈；</span></span><br><span class="line"><span class="comment"> * 3. 如果即将要搜索某个顶点，但该顶点已经在栈中，则图中有环；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedCycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;<span class="comment">//表示是否已经被搜索过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasCycle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedCycle</span><span class="params">(Digraph digraph)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[digraph.V()];</span><br><span class="line">        hasCycle = <span class="keyword">false</span>;</span><br><span class="line">        onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[digraph.V()];</span><br><span class="line">        <span class="comment">//从图中依次找每一个节点，进行dfs遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digraph.V(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[i]) &#123;</span><br><span class="line">                dfs(digraph, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于深度优先搜索，检测图中是否有环</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Digraph digraph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        onStack[v] = <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;Integer&gt; adj = digraph.adj(v);</span><br><span class="line">        <span class="keyword">for</span> (Integer w : adj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                dfs(digraph, w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (onStack[w]) &#123;</span><br><span class="line">                hasCycle = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把当前顶点出栈</span></span><br><span class="line">        onStack[v] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasCycle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顶点排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/17 10:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：顶点排序</span></span><br><span class="line"><span class="comment"> * 如果要把图中的顶点生成线性序列其实是一件非常简单的事，之前我们学习并使用了多次深度优先搜索，</span></span><br><span class="line"><span class="comment"> * 我们会发现其实深度优先搜索有一个特点，那就是在一个连通子图上，每个顶点只会被搜索一次，如果我们能在深度优先搜索的基础上，</span></span><br><span class="line"><span class="comment"> * 添加一行代码，只需要将搜索的顶点放入到线性序列的数据结构中，我们就能完成这件事。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstOrder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; reversePost;<span class="comment">//使用栈，存储顶点序列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstOrder</span><span class="params">(Digraph digraph)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[digraph.V()];</span><br><span class="line">        reversePost = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; digraph.V(); v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[v]) &#123;</span><br><span class="line">                dfs(digraph, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Digraph digraph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;Integer&gt; adj = digraph.adj(v);</span><br><span class="line">        <span class="keyword">for</span> (Integer w : adj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                dfs(digraph, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reversePost.push(v);<span class="comment">//让顶点v进栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶点线性对了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stack&lt;Integer&gt; <span class="title">reversePost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reversePost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>最终实现拓扑排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/17 10:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：拓扑排序</span></span><br><span class="line"><span class="comment"> * 前面已经实现了环的检测以及顶点排序，那么拓扑排序就很简单了，基于一幅图，先检测有没有环，如果没有环，则调用顶点排序即可。</span></span><br><span class="line"><span class="comment"> * 需要用到的类，Digraph、DirectedCycle、DepthFirstOrder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopoLogical</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopoLogical</span><span class="params">(Digraph digraph)</span> </span>&#123;</span><br><span class="line">        DirectedCycle directedCycle = <span class="keyword">new</span> DirectedCycle(digraph);</span><br><span class="line">        <span class="keyword">if</span> (!directedCycle.isHasCycle()) &#123;</span><br><span class="line">            DepthFirstOrder depthFirstOrder = <span class="keyword">new</span> DepthFirstOrder(digraph);</span><br><span class="line">            stack = depthFirstOrder.reversePost();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stack&lt;Integer&gt; <span class="title">order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/17 10:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：拓扑排序测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopoLogicalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Digraph digraph = <span class="keyword">new</span> Digraph(<span class="number">6</span>);</span><br><span class="line">        digraph.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        digraph.addEdge(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        digraph.addEdge(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        digraph.addEdge(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        digraph.addEdge(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        digraph.addEdge(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        TopoLogical topoLogical = <span class="keyword">new</span> TopoLogical(digraph);</span><br><span class="line">        Stack&lt;Integer&gt; order = topoLogical.order();</span><br><span class="line">        <span class="keyword">while</span> (!order.empty()) &#123;</span><br><span class="line">            System.out.println(order.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出：</p>
<blockquote>
<p>1 0 3 2 4 5</p>
</blockquote>
<h3 id="加权无向图"><a href="#加权无向图" class="headerlink" title="加权无向图"></a>加权无向图</h3><p>加权无向边：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/17 11:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：加权无向边</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">either</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertex == v ? w : v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.weight &gt; o.weight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.weight &lt; o.weight) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前我们已经完成了无向图，在无向图的基础上，我们只需要把边的表示切换成Edge对象即可。</p>
<p>加权无向图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeWeightedGraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V;<span class="comment">//包含的顶点数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;<span class="comment">//边的个数</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt;[] adj;<span class="comment">//邻接表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedGraph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = <span class="keyword">new</span> Queue[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> Queue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取和顶点v相邻的所有顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue&lt;Edge&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[V];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向图中添加一条边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Edge edge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge.either();</span><br><span class="line">        <span class="keyword">int</span> w = edge.other(v);</span><br><span class="line">        adj[v].enqueue(edge);</span><br><span class="line">        adj[w].enqueue(edge);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取加权无向图的所有边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Edge&gt; edges = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            Queue&lt;Edge&gt; adj = adj(v);</span><br><span class="line">            <span class="keyword">for</span> (Edge e : adj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.other(v) &lt; v) &#123;</span><br><span class="line">                    edges.enqueue(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><blockquote>
<p>介绍：</p>
</blockquote>
<h4 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h4><p>需要用到索引最小优先队列、加权无向图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/17 11:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：最小生成树Prim算法事先</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Edge[] edgeTo;<span class="comment">//索引代表顶点，值代表当前顶点和最小生成树之间的最短边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;<span class="comment">//索引代表顶点，值代表当前顶点和最小生成树之间的最短边的权重</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;<span class="comment">//true：当前顶点已经在树中了</span></span><br><span class="line">    <span class="keyword">private</span> IndexMinPriorityQueue&lt;Double&gt; pq;<span class="comment">//存放树中顶点与非树中顶点之间的有效横切边</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span><span class="params">(EdgeWeightedGraph graph)</span> </span>&#123;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> Edge[graph.V()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[graph.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.V(); i++) &#123;</span><br><span class="line">            distTo[i] = Double.POSITIVE_INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.V()];</span><br><span class="line">        pq = <span class="keyword">new</span> IndexMinPriorityQueue&lt;&gt;(graph.V());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认让顶点0进入树中，但是树中只有一个顶点0，因此0顶点默认没有和其他的顶点相连，所有distTo[0]也是0</span></span><br><span class="line">        distTo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        pq.insert(<span class="number">0</span>, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历索引最小优先队列，拿到最小和N切边对应的顶点，把该顶点加入到最小生成树中</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            visit(graph, pq.delMin());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将顶点v加入到最小生成树中，并更新数据</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(EdgeWeightedGraph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;Edge&gt; adj = graph.adj(v);</span><br><span class="line">        <span class="keyword">for</span> (Edge e : adj) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">            <span class="keyword">if</span> (marked[w]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断边e的权重是否小于从w顶点到树中已经存在的最小边的权重</span></span><br><span class="line">            <span class="keyword">if</span> (e.weight() &lt; distTo[w]) &#123;</span><br><span class="line">                edgeTo[w] = e;</span><br><span class="line">                distTo[w] = e.weight();</span><br><span class="line">                <span class="keyword">if</span> (pq.contains(w)) &#123;</span><br><span class="line">                    pq.changeItem(w, e.weight());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pq.insert(w, e.weight());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最小生成树的所有边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Edge&gt; edges = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeTo.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edgeTo[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                edges.enqueue(edgeTo[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Author: Github</span><br><span class="line"> * @Time: 2020&#x2F;6&#x2F;17 10:34</span><br><span class="line"> * @Description: 类描述：拓扑排序测试类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PrimMSTTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(PrimMSTTest.class.getClassLoader().getResourceAsStream(&quot;min_create_tree_test.txt&quot;)));</span><br><span class="line">        int number &#x3D; Integer.parseInt(reader.readLine());</span><br><span class="line">        EdgeWeightedGraph graph &#x3D; new EdgeWeightedGraph(number);</span><br><span class="line">        int edgeNumber &#x3D; Integer.parseInt(reader.readLine());</span><br><span class="line">        for (int i &#x3D; 0; i &lt; edgeNumber; i++) &#123;</span><br><span class="line">            String line &#x3D; reader.readLine();</span><br><span class="line">            String[] strs &#x3D; line.split(&quot; &quot;);</span><br><span class="line">            int v &#x3D; Integer.parseInt(strs[0]);</span><br><span class="line">            int w &#x3D; Integer.parseInt(strs[1]);</span><br><span class="line">            double weight &#x3D; Double.parseDouble(strs[2]);</span><br><span class="line">            Edge edge &#x3D; new Edge(v, w, weight);</span><br><span class="line">            graph.addEdge(edge);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PrimMST mst &#x3D; new PrimMST(graph);</span><br><span class="line">        Queue&lt;Edge&gt; edges &#x3D; mst.edges();</span><br><span class="line">        for (Edge edge : edges) &#123;</span><br><span class="line">            System.out.println(edge.either() + &quot;-&quot; + edge.other(edge.either()) + &quot;::&quot; + edge.weight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>min_create_tree_test.txt：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">16</span><br><span class="line">4 5 0.35</span><br><span class="line">4 7 0.37</span><br><span class="line">5 7 0.28</span><br><span class="line">0 7 0.16</span><br><span class="line">1 5 0.32</span><br><span class="line">0 4 0.38</span><br><span class="line">2 3 0.17</span><br><span class="line">1 7 0.19</span><br><span class="line">0 2 0.26</span><br><span class="line">1 2 0.36</span><br><span class="line">1 3 0.29</span><br><span class="line">2 7 0.34</span><br><span class="line">6 2 0.40</span><br><span class="line">3 6 0.52</span><br><span class="line">6 0 0.58</span><br><span class="line">6 4 0.93</span><br></pre></td></tr></table></figure>



<p>输出：</p>
<blockquote>
<p>1-7::0.19<br>0-2::0.26<br>2-3::0.17<br>4-5::0.35<br>5-7::0.28<br>6-2::0.4<br>0-7::0.16</p>
</blockquote>
<h4 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/17 11:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：最小生成树kruskal算法实现</span></span><br><span class="line"><span class="comment"> * kruskal算法是计算一副加权无向图的最小生成树的另外一种算法，它的主要思想是按照边的权重(从小到大)处理它们，将边加入最小生成树中，</span></span><br><span class="line"><span class="comment"> * 加入的边不会与已经加入最小生成树的边构成环，直到树中含有V-1条边为止。</span></span><br><span class="line"><span class="comment"> * 在设计API的时候，使用了一个MinPriorityQueue pq存储图中所有的边，每次使用pq.delMin()取出权重最小的边，并得到该边关联的两个顶点v和w，</span></span><br><span class="line"><span class="comment"> * 通过uf.connect(v,w)判断v和w是否已经连通，如果连通，则证明这两个顶点在同一棵树中，那么就不能再把这条边添加到最小生成树中，</span></span><br><span class="line"><span class="comment"> * 因为在一棵树的任意两个顶点上添加一条边，都会形成环，而最小生成树不能有环的存在，如果不连通，则通过uf.connect(v,w)把顶点v所在的树和顶点w所在的树合并成一棵树，并把这条边加入到mst队列中，这样如果把所有的边处理完，最终mst中存储的就是最小生树的所有边。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalMST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; mst;<span class="comment">//保存最小生成树所有的边</span></span><br><span class="line">    <span class="keyword">private</span> UF_Tree_Weighted uf;<span class="comment">//索引代表顶点，使用uf.connect(v,w)可以判断v和w是否在同一颗树上，使用uf.union(v,w)可以把两顶点合并</span></span><br><span class="line">    <span class="keyword">private</span> MinPriorityQueue&lt;Edge&gt; pq;<span class="comment">//存储图中所有的边，使用最小优先队列，对边进行权重排序</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalMST</span><span class="params">(EdgeWeightedGraph graph)</span> </span>&#123;</span><br><span class="line">        mst = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        uf = <span class="keyword">new</span> UF_Tree_Weighted(graph.V());</span><br><span class="line">        pq = <span class="keyword">new</span> MinPriorityQueue&lt;&gt;(graph.E() + <span class="number">1</span>);</span><br><span class="line">        Queue&lt;Edge&gt; edges = graph.edges();</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">            pq.insert(edge);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历pq队列取得最小边进行处理</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; mst.size() &lt; graph.V() - <span class="number">1</span>) &#123;</span><br><span class="line">            Edge minEdge = pq.delMin();</span><br><span class="line">            <span class="keyword">int</span> v = minEdge.either();</span><br><span class="line">            <span class="keyword">int</span> w = minEdge.other(v);</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(v, w)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            uf.union(v, w);</span><br><span class="line">            mst.enqueue(minEdge);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最小生成树的所有边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalMSTTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(KruskalMSTTest.class.getClassLoader().getResourceAsStream("min_create_tree_test.txt")));</span><br><span class="line">        <span class="keyword">int</span> number = Integer.parseInt(reader.readLine());</span><br><span class="line">        EdgeWeightedGraph graph = <span class="keyword">new</span> EdgeWeightedGraph(number);</span><br><span class="line">        <span class="keyword">int</span> edgeNumber = Integer.parseInt(reader.readLine());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeNumber; i++) &#123;</span><br><span class="line">            String line = reader.readLine();</span><br><span class="line">            String[] strs = line.split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> v = Integer.parseInt(strs[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> w = Integer.parseInt(strs[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">double</span> weight = Double.parseDouble(strs[<span class="number">2</span>]);</span><br><span class="line">            Edge edge = <span class="keyword">new</span> Edge(v, w, weight);</span><br><span class="line">            graph.addEdge(edge);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        KruskalMST mst = <span class="keyword">new</span> KruskalMST(graph);</span><br><span class="line">        Queue&lt;Edge&gt; edges = mst.edges();</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">            System.out.println(edge.either() + <span class="string">"-"</span> + edge.other(edge.either()) + <span class="string">"::"</span> + edge.weight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>0-7::0.16<br>2-3::0.17<br>1-7::0.19<br>0-2::0.26<br>5-7::0.28<br>1-3::0.29<br>4-5::0.35</p>
</blockquote>
<h3 id="加权有向图"><a href="#加权有向图" class="headerlink" title="加权有向图"></a>加权有向图</h3><p>加权有向边表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedEdge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">from</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">to</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加权有向图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/17 9:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：加权有向图</span></span><br><span class="line"><span class="comment"> * 之前我们已经完成了有向图，在有向图的基础上，我们只需要把边的表示切换成DirectedEdge对象即可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeWeightedDigraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;DirectedEdge&gt;[] adj;<span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V;<span class="comment">//包含的顶点数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;<span class="comment">//边的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedDigraph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = v;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = <span class="keyword">new</span> Queue[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向有向图中添加一条边v-&gt;w</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(DirectedEdge edge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge.from();</span><br><span class="line">        adj[v].enqueue(edge);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取由v指出的边所连接的所有顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue&lt;DirectedEdge&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue&lt;DirectedEdge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;DirectedEdge&gt; edges = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            Queue&lt;DirectedEdge&gt; queue = adj[v];</span><br><span class="line">            <span class="keyword">for</span> (DirectedEdge edge : queue) &#123;</span><br><span class="line">                edges.enqueue(edge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="最短路径-Dijkstra算法"><a href="#最短路径-Dijkstra算法" class="headerlink" title="最短路径-Dijkstra算法"></a>最短路径-Dijkstra算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/18 12:47</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：最短路径</span></span><br><span class="line"><span class="comment"> * 有了加权有向图之后，我们立刻就能联想到实际生活中的使用场景，例如在一副地图中，找到顶点a与地点b之间的路径，这条路径可以是距离最短，</span></span><br><span class="line"><span class="comment"> * 也可以是时间最短，也可以是费用最小等，如果我们把  距离 /时间/费用 看做是成本，那么就需要找到地点a和地点b之间成本最小的路径，</span></span><br><span class="line"><span class="comment"> * 也就是我们接下来要解决的最短路径问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraSP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IndexMinPriorityQueue&lt;Double&gt; pq;<span class="comment">//存放树中顶点与非树中顶点之间有效横切边</span></span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;<span class="comment">//索引：顶点，值：从顶点s到当前顶点最短路径上的最后一条边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;<span class="comment">//索引：顶点，值：从顶点s到当前顶点的最短路径的总权重</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DijkstraSP</span><span class="params">(EdgeWeightedDigraph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        pq = <span class="keyword">new</span> IndexMinPriorityQueue&lt;&gt;(graph.V());</span><br><span class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[graph.V()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[graph.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; distTo.length; i++) &#123;</span><br><span class="line">            distTo[i] = Double.POSITIVE_INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认让顶点s进入到最短树中</span></span><br><span class="line">        distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">        pq.insert(s, <span class="number">0.0</span>);</span><br><span class="line">        <span class="comment">//遍历pq</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            relax(graph, pq.delMin());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//松弛图G中v顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge edge : graph.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = edge.to();</span><br><span class="line">            <span class="keyword">if</span> (distTo(v) + edge.weight() &lt; distTo(w)) &#123;</span><br><span class="line">                distTo[w] = distTo[v] + edge.weight();</span><br><span class="line">                edgeTo[w] = edge;</span><br><span class="line">                <span class="keyword">if</span> (pq.contains(w)) &#123;</span><br><span class="line">                    pq.changeItem(w, distTo(w));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pq.insert(w, distTo(w));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶点s到顶点v的最短路径的总权重</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断顶点s到顶点v是否可达</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v] &lt; Double.POSITIVE_INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询顶点s到顶点v的最短路径中所有的边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue&lt;DirectedEdge&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;DirectedEdge&gt; allEdges = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            DirectedEdge directedEdge = edgeTo[v];</span><br><span class="line">            <span class="keyword">if</span> (directedEdge == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            allEdges.enqueue(directedEdge);</span><br><span class="line">            v = directedEdge.from();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allEdges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraSPTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建一副加权有向图</span></span><br><span class="line">        BufferedReader br = new BufferedReader(new InputStreamReader(DijkstraSPTest.class.getClassLoader().getResourceAsStream("min_route_test.txt")));</span><br><span class="line">        <span class="keyword">int</span> total = Integer.parseInt(br.readLine());</span><br><span class="line">        EdgeWeightedDigraph G = <span class="keyword">new</span> EdgeWeightedDigraph(total);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> edgeNumbers = Integer.parseInt(br.readLine());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= edgeNumbers; i++) &#123;</span><br><span class="line">            String line = br.readLine();<span class="comment">//4 5 0.35</span></span><br><span class="line">            String[] strs = line.split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> v = Integer.parseInt(strs[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> w = Integer.parseInt(strs[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> weight = Double.parseDouble(strs[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">            DirectedEdge e = <span class="keyword">new</span> DirectedEdge(v, w, weight);</span><br><span class="line">            G.addEdge(e);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建DijkstraSP对象，查找最短路径树</span></span><br><span class="line">        DijkstraSP dijkstraSP = <span class="keyword">new</span> DijkstraSP(G, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找最短路径,0-&gt;6的最短路径</span></span><br><span class="line">        Queue&lt;DirectedEdge&gt; edges = dijkstraSP.pathTo(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历打印</span></span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge edge : edges) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(edge.from() + <span class="string">"-&gt;"</span> + edge.to() + <span class="string">" ：： "</span> + edge.weight());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>min_route_test.txt：</p>
<blockquote>
<p>8<br>15<br>4 5 0.35<br>5 4 0.35<br>4 7 0.37<br>5 7 0.28<br>7 5 0.28<br>5 1 0.32<br>0 4 0.38<br>0 2 0.26<br>7 3 0.39<br>1 3 0.29<br>2 7 0.34<br>6 2 0.40<br>3 6 0.52<br>6 0 0.58<br>6 4 0.93</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>3-&gt;6 ：： 0.52<br>7-&gt;3 ：： 0.39<br>2-&gt;7 ：： 0.34<br>0-&gt;2 ：： 0.26</p>
</blockquote>
<h4 id="最小生成树和最短路径的区别"><a href="#最小生成树和最短路径的区别" class="headerlink" title="最小生成树和最短路径的区别"></a>最小生成树和最短路径的区别</h4><p><strong>定义：</strong><br>    最小生成树能够保证整个拓扑图的<strong>所有路径之和</strong>最小，但不能保证任意两点之间是最短路径。<br>    最短路径是从一点出发，到达目的地的路径最小。</p>
<p><strong>总结：</strong><br>　　遇到求所有路径之和最小的问题用<strong>最小生成树&amp;并查集</strong>解决；<br>　　遇到求两点间最短路径问题的用<strong>最短路</strong>，即从一个城市到另一个城市最短的路径问题。</p>
<p><strong>区别：</strong><br>　　最小生成树构成后所有的点都被连通，而最短路只要到达目的地走的是最短的路径即可，与所有的点连不连通没有关系。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>难点：</p>
<ul>
<li>复杂排序</li>
<li>优先队列<ul>
<li>最大/最小优先队列</li>
<li>索引最大/最小优先队列</li>
</ul>
</li>
<li>红黑树</li>
<li>并查集</li>
<li>最小生成树<ul>
<li>prim</li>
<li>kruskal</li>
</ul>
</li>
<li>最短路径<ul>
<li>Dijkstra</li>
</ul>
</li>
</ul>
<p><strong>END.</strong></p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=781620072,2709100387&amp;fm=26&amp;gp=0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/11/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><img class="prev_cover lazyload" data-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1591889310669&amp;di=be6eb09cee916539f259689f061f7862&amp;imgtype=0&amp;src=http%3A%2F%2Fimg14.360buyimg.com%2Fn0%2Fjfs%2Ft9730%2F40%2F847174291%2F365589%2F2c1c4949%2F59d88418N7ab46c0e.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《深入理解计算机系统》读书笔记</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/25/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Dagger2%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/"><img class="next_cover lazyload" data-src="https://img.cniao5.com/o_1b3rl8h6mk8d162i1i0p1ha6p989.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android源码分析——Dagger2（未完）</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Kai</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>