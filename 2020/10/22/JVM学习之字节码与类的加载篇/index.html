<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM学习之字节码与类的加载篇 | K的小屋</title><meta name="description" content="JVM学习之字节码与类的加载篇"><meta name="keywords" content="JVM,字节码,类的加载"><meta name="author" content="Kai"><meta name="copyright" content="Kai"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM学习之字节码与类的加载篇"><meta name="twitter:description" content="JVM学习之字节码与类的加载篇"><meta name="twitter:image" content="http://www.52xxit.com/data/attachment/forum/201809/10/160026v7ackztmcopvkisz.jpg"><meta property="og:type" content="article"><meta property="og:title" content="JVM学习之字节码与类的加载篇"><meta property="og:url" content="https://www.google.com/2020/10/22/JVM%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/"><meta property="og:site_name" content="K的小屋"><meta property="og:description" content="JVM学习之字节码与类的加载篇"><meta property="og:image" content="http://www.52xxit.com/data/attachment/forum/201809/10/160026v7ackztmcopvkisz.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://www.google.com/2020/10/22/JVM%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/"><link rel="prev" title="UML建模" href="https://www.google.com/2020/11/07/UML%E5%BB%BA%E6%A8%A1/"><link rel="next" title="JVM学习之性能监控与调优篇" href="https://www.google.com/2020/10/22/JVM%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Class文件结构"><span class="toc-number">1.</span> <span class="toc-text">Class文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字节码文件的跨平台性"><span class="toc-number">1.1.1.</span> <span class="toc-text">字节码文件的跨平台性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java前端编译器"><span class="toc-number">1.1.2.</span> <span class="toc-text">Java前端编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#透过字节码指令看代码"><span class="toc-number">1.1.3.</span> <span class="toc-text">透过字节码指令看代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机的基石：Class文件"><span class="toc-number">1.2.</span> <span class="toc-text">虚拟机的基石：Class文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class文件结构-1"><span class="toc-number">1.3.</span> <span class="toc-text">Class文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#魔数（Magic-Number）"><span class="toc-number">1.3.1.</span> <span class="toc-text">魔数（Magic Number）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class文件版本号（Version）"><span class="toc-number">1.3.2.</span> <span class="toc-text">Class文件版本号（Version）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常量池（Constant-Pool）"><span class="toc-number">1.3.3.</span> <span class="toc-text">常量池（Constant Pool）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常量池计数器（constan-pool-count）"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">常量池计数器（constan pool count）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常量池（constan-pool-）"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">常量池（constan pool[]）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#字面量（literal）和符号引用（symbolic-reference）"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">字面量（literal）和符号引用（symbolic reference）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#常量类型和结构"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">常量类型和结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问标识（Access-Flag）"><span class="toc-number">1.3.4.</span> <span class="toc-text">访问标识（Access Flag）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类索引（this-class）、父类索引（super-class）、接口索引集合"><span class="toc-number">1.3.5.</span> <span class="toc-text">类索引（this_class）、父类索引（super_class）、接口索引集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字段表集合（Fields）"><span class="toc-number">1.3.6.</span> <span class="toc-text">字段表集合（Fields）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字段计数器（fields-count）"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">字段计数器（fields count）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字段表（fields-）"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">字段表（fields[]）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#字段访问标志（access-flags）"><span class="toc-number">1.3.6.2.1.</span> <span class="toc-text">字段访问标志（access_flags）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字段名称索引-（name-index-）"><span class="toc-number">1.3.6.2.2.</span> <span class="toc-text">字段名称索引  （name_index ）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字段描述符索引-（descriptor-index-）"><span class="toc-number">1.3.6.2.3.</span> <span class="toc-text">字段描述符索引  （descriptor_index ）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字段属性表集合（attributes）"><span class="toc-number">1.3.6.2.4.</span> <span class="toc-text">字段属性表集合（attributes）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法表集合（Methods）"><span class="toc-number">1.3.7.</span> <span class="toc-text">方法表集合（Methods）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法计数器（methods-count）"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">方法计数器（methods count）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法表（methods-）"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">方法表（methods[]）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#方法访问标志（access-flags）"><span class="toc-number">1.3.7.2.1.</span> <span class="toc-text">方法访问标志（access_flags）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#方法名索引（name-index）"><span class="toc-number">1.3.7.2.2.</span> <span class="toc-text">方法名索引（name_index）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#方法描述索引（descriptor-index）"><span class="toc-number">1.3.7.2.3.</span> <span class="toc-text">方法描述索引（descriptor_index）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#方法的属性表集合（attributes）"><span class="toc-number">1.3.7.2.4.</span> <span class="toc-text">方法的属性表集合（attributes）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性表集合（Attributes）"><span class="toc-number">1.3.8.</span> <span class="toc-text">属性表集合（Attributes）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Code属性介绍"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">Code属性介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LineNumberTable属性介绍"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">LineNumberTable属性介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalVariableTable属性介绍"><span class="toc-number">1.3.8.3.</span> <span class="toc-text">LocalVariableTable属性介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SourceFile属性介绍"><span class="toc-number">1.3.8.4.</span> <span class="toc-text">SourceFile属性介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class文件小结"><span class="toc-number">1.3.9.</span> <span class="toc-text">Class文件小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用javap指令解析Class文件"><span class="toc-number">1.4.</span> <span class="toc-text">使用javap指令解析Class文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#javap指令使用小结"><span class="toc-number">1.4.1.</span> <span class="toc-text">javap指令使用小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字节码指令集与解析举例"><span class="toc-number">2.</span> <span class="toc-text">字节码指令集与解析举例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类的加载过程详解"><span class="toc-number">3.</span> <span class="toc-text">类的加载过程详解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#再谈类的加载器"><span class="toc-number">4.</span> <span class="toc-text">再谈类的加载器</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(http://www.52xxit.com/data/attachment/forum/201809/10/160026v7ackztmcopvkisz.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">K的小屋</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">JVM学习之字节码与类的加载篇</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-10-22 14:30:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-10-22</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-11-13 18:38:53"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-11-13</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">12.6k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 42 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h1><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622174536.png"  alt="JVM整体结构"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="字节码文件的跨平台性"><a href="#字节码文件的跨平台性" class="headerlink" title="字节码文件的跨平台性"></a>字节码文件的跨平台性</h3><p><strong>Java语言：跨平台的语言</strong></p>
<ul>
<li>当Java源代码成功编译成字节码后，如果想在不同的平台上面运行，则无需再次编译</li>
<li>这个优势不再那么吸引人，Python、PHP、Perl、Ruby、Lisp等有强大的解释器</li>
<li>跨平台似乎已经快成为一门语言必选的特性</li>
</ul>
<p><strong>JVM：跨语言的平台</strong></p>
<ul>
<li>Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联。无论使用何种语言进行软件开发，只要能将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行。可以说统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁。</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201111144640.png"  alt="img"></p>
<ul>
<li>所有的JVM全部遵守Java虚拟机规范，也就是所有的JVM环境都是一样的，这样一来字节码文件可以在各种JVM上运行<ul>
<li><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/index.html</a></li>
</ul>
</li>
</ul>
<p><strong>想要让一个Java程序正确的运行在JVM中，Java源码就必须要被编译为符合JVM规范的字节码</strong></p>
<ul>
<li>前端编译器的主要任务就是负责将符合Java语法规范的Java代码转换为符合JVM规范的字节码文件</li>
<li>javac是一种能够将Java源码编译为字节码的前端编译器</li>
<li>javac编译器在将Java源码编译为一个有效的字节码文件过程中经历了4个步骤，分别是词法分析、语法分析、语义解析以及生成字节码</li>
</ul>
<p><strong>Oracle的JDK软件包括两部分内容：</strong></p>
<ul>
<li>一部分是将Java源代码编译成Java虚拟机的指令集的编译器</li>
<li>另一部分是用于实现Java虚拟机的运行环境</li>
</ul>
<h3 id="Java前端编译器"><a href="#Java前端编译器" class="headerlink" title="Java前端编译器"></a>Java前端编译器</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201111144840.png"  alt="img"></p>
<p><strong>前端编译器vs后端编译器</strong></p>
<p>Java源代码的编译结果是字节码，那么肯定需要有一种编译器能够将Java源码编译为字节码，承担这个重要责任的就是配置在path环境变量中的javac编译器。javac是一种能够将Java源码编译为字节码的前端编译器。</p>
<p>Hotspot VM并没有强制要求前端编译器只能使用javac来编译字节码，其实只要编译结果符合JVM规范都可以被JVM所识别即可。在Java的前端编译器领域，除了javac之外，还有一种被大家经常用到的前端编译器，那就是内置在Eclipse中的ECJ(Eclipse Compiler for Java）编译器。和javac的全量式编译不同，ECJ是一种增量式编译器。</p>
<ul>
<li><p>在Eclipse中，当开发人员编写完代码后，使用”Ctrl+S”快捷键时，ECJ编译器所采取的编译方案是把未编译部分的源码逐行进行编译，而非每次都全量编译。因此ECJ的编译效率会比javac更加迅速和高效，当然编译质量和javac相比大致还是一样的。</p>
</li>
<li><p>EJC不仅是Eclipse的默认内置前端编译器，在Tomcat中同样也是使用ECJ编译器来编译jsp文件。由于ECJ编译器是采用GPLv2的开源协议进行源代码公开，所以，大家可以登录eclispe官网下载ECJ编译器的源码进行二次开发。</p>
</li>
<li><p>默认情况下，IntelliJ IDEA使用javac编译器。（还可以自己设置为AspectJ 编译器ajc)</p>
</li>
</ul>
<p>前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给HotSpot的JIT编译器负责。</p>
<p>复习：AOT（静态提前编译器，Ahead Of Time Compiler)</p>
<h3 id="透过字节码指令看代码"><a href="#透过字节码指令看代码" class="headerlink" title="透过字节码指令看代码"></a>透过字节码指令看代码</h3><p>BAT面试题目</p>
<p>① 类文件结构有几部分</p>
<p>② 知道字节码吗？字节码都有哪些？Integer x = 5;int y = 5;比较x ==y 都经历过哪些步骤？</p>
<p>代码举例：</p>
<p>Example1:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">        System.out.println(x == y);</span><br><span class="line"></span><br><span class="line">        Integer i1 = <span class="number">10</span>;</span><br><span class="line">        Integer i2 = <span class="number">10</span>;</span><br><span class="line">        System.out.println(i1 == i2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        Integer i3 = <span class="number">128</span>;</span><br><span class="line">        Integer i4 = <span class="number">128</span>;</span><br><span class="line">        System.out.println(i3 == i4);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Integer.java中关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Example2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">"hello"</span>) + <span class="keyword">new</span> String(<span class="string">"world"</span>);</span><br><span class="line">        String str1 = <span class="string">"helloworld"</span>;</span><br><span class="line">        System.out.println(str == str1);<span class="comment">//false</span></span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"helloworld"</span>);</span><br><span class="line">        System.out.println(str == str2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用jclasslib插件查看对应的class字节码文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> 0 new #2 &lt;java&#x2F;lang&#x2F;StringBuilder&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 invokespecial #3 &lt;java&#x2F;lang&#x2F;StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"> 7 new #4 &lt;java&#x2F;lang&#x2F;String&gt;</span><br><span class="line">10 dup</span><br><span class="line">11 ldc #5 &lt;hello&gt;</span><br><span class="line">13 invokespecial #6 &lt;java&#x2F;lang&#x2F;String.&lt;init&gt;&gt;</span><br><span class="line">16 invokevirtual #7 &lt;java&#x2F;lang&#x2F;StringBuilder.append&gt;</span><br><span class="line">19 new #4 &lt;java&#x2F;lang&#x2F;String&gt;</span><br><span class="line">22 dup</span><br><span class="line">23 ldc #8 &lt;world&gt;</span><br><span class="line">25 invokespecial #6 &lt;java&#x2F;lang&#x2F;String.&lt;init&gt;&gt;</span><br><span class="line">28 invokevirtual #7 &lt;java&#x2F;lang&#x2F;StringBuilder.append&gt;</span><br><span class="line">31 invokevirtual #9 &lt;java&#x2F;lang&#x2F;StringBuilder.toString&gt;</span><br><span class="line">34 astore_1</span><br><span class="line">35 ldc #10 &lt;helloworld&gt;</span><br><span class="line">37 astore_2</span><br><span class="line">38 getstatic #11 &lt;java&#x2F;lang&#x2F;System.out&gt;</span><br><span class="line">41 aload_1</span><br><span class="line">42 aload_2</span><br><span class="line">43 if_acmpne 50 (+7)</span><br><span class="line">46 iconst_1</span><br><span class="line">47 goto 51 (+4)</span><br><span class="line">50 iconst_0</span><br><span class="line">51 invokevirtual #12 &lt;java&#x2F;io&#x2F;PrintStream.println&gt;</span><br><span class="line">54 new #4 &lt;java&#x2F;lang&#x2F;String&gt;</span><br><span class="line">57 dup</span><br><span class="line">58 ldc #10 &lt;helloworld&gt;</span><br><span class="line">60 invokespecial #6 &lt;java&#x2F;lang&#x2F;String.&lt;init&gt;&gt;</span><br><span class="line">63 astore_3</span><br><span class="line">64 getstatic #11 &lt;java&#x2F;lang&#x2F;System.out&gt;</span><br><span class="line">67 aload_1</span><br><span class="line">68 aload_3</span><br><span class="line">69 if_acmpne 76 (+7)</span><br><span class="line">72 iconst_1</span><br><span class="line">73 goto 77 (+4)</span><br><span class="line">76 iconst_0</span><br><span class="line">77 invokevirtual #12 &lt;java&#x2F;io&#x2F;PrintStream.println&gt;</span><br><span class="line">80 getstatic #11 &lt;java&#x2F;lang&#x2F;System.out&gt;</span><br><span class="line">83 aload_2</span><br><span class="line">84 aload_3</span><br><span class="line">85 if_acmpne 92 (+7)</span><br><span class="line">88 iconst_1</span><br><span class="line">89 goto 93 (+4)</span><br><span class="line">92 iconst_0</span><br><span class="line">93 invokevirtual #12 &lt;java&#x2F;io&#x2F;PrintStream.println&gt;</span><br><span class="line">96 return</span><br></pre></td></tr></table></figure>

<p>StringBuilder中的toString方法就是new了一个新对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">    &#x2F;&#x2F; Create a copy, don&#39;t share the array</span><br><span class="line">    return new String(value, 0, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Example3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        x = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father.x = "</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        x = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son.x = "</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father f = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(f.x);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------"</span>);</span><br><span class="line">        Father f2 = <span class="keyword">new</span> Father();</span><br><span class="line">        System.out.println(f2.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出日志：</span></span><br><span class="line"><span class="comment">Son.x = 0</span></span><br><span class="line"><span class="comment">Son.x = 30</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment">Father.x = 10</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>成员变量（非静态的）的赋值过程：<br>① 默认初始化<br>② 显式初始化 /代码块中初始化<br>③ 构造器中初始化<br>④ 有了对象之后，可以“对象.属性”或”对象.方法”的方式对成员变量进行赋值</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201111151034.png"  alt="Father"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201111151103.png"  alt="Son"></p>
<h2 id="虚拟机的基石：Class文件"><a href="#虚拟机的基石：Class文件" class="headerlink" title="虚拟机的基石：Class文件"></a>虚拟机的基石：Class文件</h2><ul>
<li>字节码文件里是什么？</li>
</ul>
<p>源代码经过编译器编译之后会生成一个字节码文件，字节码是一种二进制文件，它的内容是JVM的指令，而不像C、C++经由编译器直接生成机器码。</p>
<ul>
<li>什么是字节码指令（byte code）？</li>
</ul>
<p>Java虚拟机的指令是由一个字节长度的、代表着某种特点操作含义的操作码（opcode）以及跟随其后的零个或多个代表此操作所需的操作数（operand）所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。</p>
<ul>
<li>如何解读供虚拟机解释执行的二进制代码？</li>
</ul>
<p>方式1：NotePad++安装一个Hex-Editor</p>
<p>方式2：使用Binary View</p>
<p>方式3：使用javap指令，jdk自带的反解析工具</p>
<p>方式4：使用IDEA插件：jclasslib或jclasslib bytecode viewer客户端</p>
<h2 id="Class文件结构-1"><a href="#Class文件结构-1" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><p>官方文档位置：</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html</a></p>
<p>需要分析的Java源代码文件Demo.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.jvm2.chapter01.java1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析这个类对应的字节码文件结构</span></span><br><span class="line"><span class="comment"> * 全类名：com.github.jvm2.chapter01.java1.Demo</span></span><br><span class="line"><span class="comment"> * 全限定名：com/github/jvm2/chapter01/java1/Demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num = num + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过javac编译之生成的Demo.class文件，用NotePad++Hex-Editor查看：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201112181052.png"  alt="Demo.class字节码文件"></p>
<p>放入到Excel中进行呈现：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201113110323.png"  alt="Demo.class文件"></p>
<p><strong>Class类的本质</strong></p>
<p>任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，Class文件实际上它并不一定以磁盘文件的形式存在：Class文件是一组以8位字节为基础单位的二进制流。</p>
<p><strong>Class文件格式</strong></p>
<p>Class的结构不像XML等描述语言，由于它没有任何分隔符号。所以在其中的数据项，无论是字节顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。</p>
<p>Class文件格式采用一种类似于c语言结构体的方式进行数据存储，这种结构中只有两种数据类型：<strong>无符号数和表</strong>。</p>
<ul>
<li>无符号数属于基本的数据类型，以ul、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>
<li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明</li>
</ul>
<blockquote>
<p>充分理解了每一个字节码文件的细节，自己也可以反编译出Java源文件来</p>
</blockquote>
<p><strong>Class文件结构概述</strong></p>
<p>Class文件的结构并不是一成不变的，随着Java虚拟机的不断发展，总是不可避免地会对Class文件结构做出一些调整，但是其基本结构和框架是非常稳定的。</p>
<p>Class文件的总体结构如下：</p>
<ul>
<li>魔数</li>
<li>Class文件版本号</li>
<li>常量池</li>
<li>访问标识</li>
<li>类索引、父类索引、接口索引集合</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>属性表集合</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201111160406.png"  alt="Class文件结构"></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
<th>长度</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td>magic</td>
<td>魔数,识别Class文件格式</td>
<td>4个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>副版本号(小版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>主版本号(大版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>常量池计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>常量池表</td>
<td>n个字节</td>
<td>constant_pool_count-1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标识</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>父类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>接口计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>接口索引集合</td>
<td>2个字节</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>字段计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>字段表</td>
<td>n个字节</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>方法计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>方法表</td>
<td>n个字节</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性表</td>
<td>n个字节</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<h3 id="魔数（Magic-Number）"><a href="#魔数（Magic-Number）" class="headerlink" title="魔数（Magic Number）"></a>魔数（Magic Number）</h3><p>Magic Number（魔数）</p>
<ul>
<li><p>每个Class文件开头的4个字节的无符号整数称为魔数（Magic Number）</p>
</li>
<li><p>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即．魔数是Class文件的标识符。</p>
</li>
<li><p>魔数值固定为0xCAFEBABE不会改变。</p>
</li>
<li><p>如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：</p>
</li>
</ul>
<p>​            Error:A JNIerrorhasoccurred,pleasecheckyourinstallationandtryagainExceptioninthread”main”java.lang.C1assFormatError:Incompatiblemagicvalue188543e635inclassfileStringTest</p>
<ul>
<li>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。</li>
</ul>
<h3 id="Class文件版本号（Version）"><a href="#Class文件版本号（Version）" class="headerlink" title="Class文件版本号（Version）"></a>Class文件版本号（Version）</h3><ul>
<li><p>紧接着魔数的4个字节存储的是Class文件的版本号。同样也是4个字节。第5个和第6个字节所代表的含义就是编译的副版本号minor_version，而第7个和第8个字节就是编译的主版本号major_version。</p>
</li>
<li><p>它们共同构成了class文件的格式版本号。譬如某个Class文件的主版本号为M，副版本号为m，那么这个Class文件的格式版本号就确定为生M.m</p>
</li>
<li><p>Java的版本号是从45开始的,JDK1.1之后的每个JDK大版本发布主版本号向上加1。</p>
</li>
<li><p>不同叛本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java拟机可以执行由低版本编译器生成的Class文件,但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件。否则〕会抛出java.lang.Unsupported ClassVersionError异常。（向下兼容）</p>
</li>
<li><p>在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的JDK版本和生产环境中的JDK版本是否一致。</p>
</li>
<li><p>虚拟机JDK版本为1.k（k&gt;=2）时，对应的class文件格式版本号的范围为 45.0 - 44+k.0〈含两端）。</p>
</li>
<li><p>版本号和Java编译器的对应关系如下表：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>主版本（十进制）</th>
<th>副版本（十进制）</th>
<th>编译器版本</th>
</tr>
</thead>
<tbody><tr>
<td>45</td>
<td>3</td>
<td>1.1</td>
</tr>
<tr>
<td>46</td>
<td>0</td>
<td>1.2</td>
</tr>
<tr>
<td>47</td>
<td>0</td>
<td>1.3</td>
</tr>
<tr>
<td>48</td>
<td>0</td>
<td>1.4</td>
</tr>
<tr>
<td>49</td>
<td>0</td>
<td>1.5</td>
</tr>
<tr>
<td>50</td>
<td>0</td>
<td>1.6</td>
</tr>
<tr>
<td>51</td>
<td>0</td>
<td>1.7</td>
</tr>
<tr>
<td>52</td>
<td>0</td>
<td>1.8</td>
</tr>
<tr>
<td>53</td>
<td>0</td>
<td>1.9</td>
</tr>
<tr>
<td>54</td>
<td>0</td>
<td>1.10</td>
</tr>
<tr>
<td>55</td>
<td>0</td>
<td>1.11</td>
</tr>
</tbody></table>
<h3 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h3><ul>
<li><p>常量池是Class文件中内容最为丰富的区域之一，常量池对于Class文件中的字段和方法解析也有着至关重要的作用。</p>
</li>
<li><p>随着Java迅疾的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个Class文件的基石。而Class文件又是整个JVM的基石。</p>
</li>
<li><p>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</p>
</li>
<li><p>常量池中的常量数量是不固定的，所以在常量池的入口需要放置一个<strong>u2类型</strong>的无符号数，代表常量池计数器（constant_pool_count）。与Java中的语言习惯不一样的是，这个容量计数是从1开始，而不从0开始。</p>
</li>
<li><p>Class文件使用了一个前置的容量计数器（constant_pool_count）加若干个连续的数据项（constan_pool）的形式来描述常量池的内容。我们把这个一系列的连续常量池的数据称为常量池集合。</p>
</li>
<li><p>常量池表项中，用于存放编译时期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>，这部分内容将在类加载之后进入方法区的运行时常量池中存放</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">具体的常量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字面量</td>
<td align="center">文本字符串</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">声明为final的常量值</td>
</tr>
<tr>
<td align="center">符号引用</td>
<td align="center">类和接口的全限定名</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">字段的名称和描述符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">方法的名称和描述符</td>
</tr>
</tbody></table>
<h4 id="常量池计数器（constan-pool-count）"><a href="#常量池计数器（constan-pool-count）" class="headerlink" title="常量池计数器（constan pool count）"></a>常量池计数器（constan pool count）</h4><p>constan_pool_count（常量池计数器）</p>
<ul>
<li>由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值</li>
<li>常量池计数值（u2类型）：从1开始，表示常量池中有多少项常量。即constant_pool_count=1表示常量池中有0个常量项</li>
<li>为什么常量池是从1开始？因为它把第0项常量空出来了，这是为了满足后面某些执行常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池”的含义，这种情况可以用索引值0来表示。</li>
</ul>
<h4 id="常量池（constan-pool-）"><a href="#常量池（constan-pool-）" class="headerlink" title="常量池（constan pool[]）"></a>常量池（constan pool[]）</h4><p>constant_pool[] （常量池）</p>
<ul>
<li>constan_pool是一种表结构，以1~constant_pool_count-1为索引，表明后面有多少个常量项。</li>
<li>常量池主要存放量大常量：<strong>字面量</strong>（Literal）和<strong>符号引用</strong>（Symbolic Reference）</li>
<li>它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的没一项都具备相同的特征。第一个字节作为类型标记，用于确定该项的格式，这个字节称为<strong>tag byte</strong>（标记字节、标签字节）</li>
</ul>
<h5 id="字面量（literal）和符号引用（symbolic-reference）"><a href="#字面量（literal）和符号引用（symbolic-reference）" class="headerlink" title="字面量（literal）和符号引用（symbolic reference）"></a>字面量（literal）和符号引用（symbolic reference）</h5><ul>
<li><p>字面量和符号引用</p>
<p>常量池中主要存放量大类常量：字面量和符号引用</p>
<p>字面量：文本字符串、声明为final的常量值</p>
<p>符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</p>
</li>
<li><p>全限定名</p>
<p>com/github/jvm/Demo这个就是类的全限定名，仅仅是把包名的”.”换成了”/“，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名的结束</p>
</li>
<li><p>简单名称</p>
<p>简单名称是指没有类型和参数修饰的方法或字段名称，如add()方法和num字段的简单名称分别是add和num</p>
</li>
<li><p>描述符</p>
<p>描述符的作用是用来描述字段的<strong>数据类型</strong>、<strong>方法的参数列表</strong>（包括数量、类型以及顺序）和<strong>返回值</strong>。根据描述符规则，基本数据类型（byte、char、short、int、long、float、double、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。</p>
</li>
</ul>
<p>用描述符来描述方法的时候，按照先参数列表，然后返回值的顺序描述，参数列表按照参数的严格顺序放在小括号“()”之内。如方法java.lang.String toString()的描述符为 ()Ljava/lang/String;，方法int add(int[]x,inty)的描述符为([II)I</p>
<table>
<thead>
<tr>
<th align="center">标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B</td>
<td>基本数据类型byte</td>
</tr>
<tr>
<td align="center">C</td>
<td>基本数据类型char</td>
</tr>
<tr>
<td align="center">D</td>
<td>基本数据类型double</td>
</tr>
<tr>
<td align="center">F</td>
<td>基本数据类型float</td>
</tr>
<tr>
<td align="center">I</td>
<td>基本数据类型int</td>
</tr>
<tr>
<td align="center">J</td>
<td>基本数据类型long</td>
</tr>
<tr>
<td align="center">S</td>
<td>基本数据类型short</td>
</tr>
<tr>
<td align="center">Z</td>
<td>基本数据类型boolean</td>
</tr>
<tr>
<td align="center">V</td>
<td>代表void类型</td>
</tr>
<tr>
<td align="center">L</td>
<td>对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td align="center">[</td>
<td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td>
</tr>
</tbody></table>
<p>补充说明：</p>
<p>虚拟机在加载Class文件时才会进行动态裢接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是是无法直接被虚拟机使用的。当虚拟机运时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。</p>
<p>这里说明下符号引用和直接引用的区别与关联：</p>
<ul>
<li><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定己经加载到了内存中。</p>
</li>
<li><p>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</p>
</li>
</ul>
<h5 id="常量类型和结构"><a href="#常量类型和结构" class="headerlink" title="常量类型和结构"></a>常量类型和结构</h5><p>tag type标记字节如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志(或标识)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody></table>
<blockquote>
<p>标志15、16、18的常量类型是用来支持动态语言调用的（jdk1.7才加入的）</p>
</blockquote>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201112144814.png"  alt="常量类型和结构1"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201112144840.png"  alt="常量类型和结构2"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201112181304.png"  alt="Demo.class字节码"></p>
<p>接下来我们对常量池中第一项和第二项分别进行解读：</p>
<p>先附上一张ASCII表：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201112182227.png"  alt="ASCII表"></p>
<p>第一项：0a 00 04 00 12</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">常量池第1项数据解读：0a 00 04 00 12</span><br><span class="line"></span><br><span class="line">0a：tag type，类型标记用于该项的格式。而0a的十进制是10，表示该项常量是类中方法的符号引用即CONSTANT_Methodref_info</span><br><span class="line">这种类型的数据格式为 tag index index,其中tag是u1长度，index为u2长度。所以00 04和00 12分别代表紧接着的两个index。</span><br><span class="line"></span><br><span class="line">00 04：表示指向声明方法的类描述符CONSTANT_Class_Info的索引项</span><br><span class="line">00 12：表示指向名称及类型描述符CONATSNT_NameAndType的索引项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">先找00 04，对应着第4个常量池数据 07 00 15</span><br><span class="line">07：tag type，类型标记用于该项的格式。而07的十进制是7，表示该项常量是类或接口的符号引用即CONSTANT_Class_info</span><br><span class="line">这种类型的数据格式为 tag index ,其中tag是u1长度，index为u2长度。所以00 15是index，表示指向全限定名常量项的索引，对应的十进制就是第21个常量池中的数据。</span><br><span class="line"></span><br><span class="line">第21个常量数据项数据为 01 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74</span><br><span class="line">01：tag type，类型标记用于该项的格式。而01的十进制是1，表示该项常量是UTF-8编码的字符串即CONSTANT_utf8_info</span><br><span class="line">这种类型的数据格式为 tag length bytes,其中tag是u1长度，length为u2长度,bytes为具体的数据内容。</span><br><span class="line">00 10：表示数据长度为16个，即紧接着的16个数据都是它的内容</span><br><span class="line">6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74：通过查ASCII码表，这些表示的内容为</span><br><span class="line">j a v a &#x2F; l a n g &#x2F; O b j e c t</span><br><span class="line"></span><br><span class="line">tag type为1的都表示utf-8编码的字符串，因此可以将01的常量全部转换为字符来表示。</span><br><span class="line"></span><br><span class="line">找完了00 04，继续再找 00 12，对应第18个常量0c 00 07 00 08</span><br><span class="line">0c：tag type为12表示字段或方法的符号引用，即CONSTANT_NameAndType_info。</span><br><span class="line">结构为tag index index</span><br><span class="line">00 07 ：表示指向该字段或方法名称常量项的索引</span><br><span class="line">00 08：表示指向该字段或方法描述符常量项的索引</span><br><span class="line"></span><br><span class="line">第7项、第8项均是utf-8的字符串。</span><br><span class="line">第7项内容-方法名称：&lt;init&gt; </span><br><span class="line">第8项内容-方法描述符形参和方法返回值：()V</span><br></pre></td></tr></table></figure>

<p>第二项：09 00 03 00 13</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">常量池第1项数据解读：09 00 03 00 13</span><br><span class="line"></span><br><span class="line">09：tag type，类型标记用于该项的格式。而09的十进制是9，表示该项常量是字段的符号引用，即CONSTANT_Fieldref_info</span><br><span class="line"></span><br><span class="line">这种类型的数据格式为 tag index index,其中tag是u1长度，index为u2长度。所以00 03和00 13分别代表紧接着的两个index。</span><br><span class="line">00 03：表示指向声明字段的类或接口描述符CONSTANT_Class_Info的索引项</span><br><span class="line">00 13：表示指向字段描述符CONATSNT_NameAndType的索引项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">先找00 03，对应着第3个常量池数据 07 00 14</span><br><span class="line">07：tag type，类型标记用于该项的格式。而07的十进制是7，表示该项常量是类或接口的符号引用即CONSTANT_Class_info</span><br><span class="line">这种类型的数据格式为 tag index ,其中tag是u1长度，index为u2长度。所以00 14是index，表示指向全限定名常量项的索引，对应的十进制就是第20个常量池中的数据。</span><br><span class="line"></span><br><span class="line">第20个常量数据项数据为 01 00 24 63 6f 6d 2f 67 69 74 68 75 62 2f 6a 76 6d 32 2f 63 68 61 70 74 65 72 30 31 2f 6a 61 76 61 31 2f 44 65 6d 6f</span><br><span class="line">01：tag type，类型标记用于该项的格式。而01的十进制是1，表示该项常量是UTF-8编码的字符串即CONSTANT_utf8_info</span><br><span class="line">这种类型的数据格式为 tag length bytes,其中tag是u1长度，length为u2长度,bytes为具体的数据内容。</span><br><span class="line">00 24：表示数据长度为30个，即紧接着的30个数据都是它的内容</span><br><span class="line">63 6f 6d 2f 67 69 74 68 75 62 2f 6a 76 6d 32 2f 63 68 61 70 74 65 72 30 31 2f 6a 61 76 61 31 2f 44 65 6d 6f：通过查ASCII码表，这些表示的内容为</span><br><span class="line">com&#x2F;github&#x2F;jvm2&#x2F;chapter01&#x2F;java1&#x2F;Demo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">找完了00 03，继续再找 00 13，对应第19个常量0c 00 05 00 06</span><br><span class="line">0c：tag type为12表示字段或方法的符号引用，即CONSTANT_NameAndType_info。</span><br><span class="line">结构为tag index index</span><br><span class="line">00 05 ：表示指向该字段或方法名称常量项的索引</span><br><span class="line">00 06：表示指向该字段或方法描述符常量项的索引</span><br><span class="line">第5项、第6项均是utf-8的字符串。</span><br><span class="line">第5项内容-字段名称：num</span><br><span class="line">第6项内容-字段描述符：I</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201112181525.png"  alt="jclasslib第一项常量"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201112181557.png"  alt="jclasslib第二项常量"></p>
<p><strong>常量池总结：</strong></p>
<p>总结1：</p>
<ul>
<li><p>这14种表（或者常量项结构）的共同点是：表开始的第一位是一个ul类型的标志位(tag)，代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</p>
</li>
<li><p>在常量池列表中，CONSTANT_Utf8_info常量项是一种使用改进过的UTF-8编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。</p>
</li>
<li><p>这14种常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有CONSTANT_Utf8-f。占用字节不固定，其大小由length决定。为什么呢？因为从常量池存放的内容可知，其存放的是字量和符引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过utf-8编码，就可以知道其长度。</p>
</li>
</ul>
<p>总结2：</p>
<ul>
<li><p>常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用Class文件空间最大的数据项目之一</p>
</li>
<li><p>常量池中为什么要包含这些内容?</p>
<p>Java代码在进行javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态链接。也就是说，在Class一文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态链接的内容，在虚拟机类加载过程时再进行详细讲解。</p>
</li>
</ul>
<h3 id="访问标识（Access-Flag）"><a href="#访问标识（Access-Flag）" class="headerlink" title="访问标识（Access Flag）"></a>访问标识（Access Flag）</h3><p>访问标识（access_flag、访问标志、访问标记）</p>
<ul>
<li>在常量池之后，紧跟着的就是访问标识。该标记使用两个字节u2长度，用于识别一些类或接口层次的访问信息。包括这个Class是接口还是类；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等</li>
<li>类的访问权限通常以ACC_开头的常量</li>
<li>每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的。比如，若是public final的类则标记位ACC_PUBLIC | ACC_FINAL</li>
<li>使用ACC_SUPPER可以让类更准确的定位到父类的方法super.method()，现在编译器都会设置并使用这个标记</li>
</ul>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>标志为public类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>标志被声明为final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标志这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标志这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标志这是一个枚举</td>
</tr>
</tbody></table>
<p>补充说明：</p>
<ol>
<li><p>带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口。</p>
<ol>
<li>如果一个个class文件被设置了ACC_INTERFACE标志，那么同时也得设置ACC_ABSTRACT标志。同时它不能再没置ACC_FINAL、ACC_SUPER或ACC_ENUM标志。</li>
<li>如果没有设置ACC_INTERFACE表示,那么这个class文件可以具有上表中除ACC_ANNOTATION外的其他所有标志．当然，ACC_FINAL和ACC_ABSTRACT这类互斥的标志除外，这两个标志不得同时设置。</li>
</ol>
</li>
<li><p>ACC_SUPER标志用于确定类或接口里面的invokesspecial指令使用的是哪一种执行语义。针对Java拟机指令集的编泽器都应当当设置这个标志。对于JavaSE8及后续版本来说，无论class文件中这个标志的实际值是什么，也不管class文件的版本号是多少，Java虚拟机都认为每个class文件均设置了ACC_SUPER标志。</p>
<ol>
<li>ACC_SUPER标志是为了向后兼容由旧Java编译器所编译的代码而设计的。目前的ACC_SUPER标志在由JDK1.0.2之前的编译器所生成的access_flags中是没有确定含义的，如果设置了该标志，那么Oracle的Java虚拟机实现会将其忽略。</li>
</ol>
</li>
<li><p>ACC_SYNTHETIC标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。</p>
</li>
<li><p>注解类型必须设置ACC_ANTATION标志：如果设置了ACC_ANNOTATION标志，那么也必须设置ACC_INTERFACE标志。</p>
</li>
<li><p>ACC_ENUM标志表明该类或其父类为枚举类型。</p>
</li>
</ol>
<p>对应则Demo.class文件中的数值为<code>00 21</code>，表示同时被ACC_SUPER和ACC_PUBLIC修饰。</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201113110643.png"  alt="访问标识"></p>
<h3 id="类索引（this-class）、父类索引（super-class）、接口索引集合"><a href="#类索引（this-class）、父类索引（super-class）、接口索引集合" class="headerlink" title="类索引（this_class）、父类索引（super_class）、接口索引集合"></a>类索引（this_class）、父类索引（super_class）、接口索引集合</h3><p>在访问标记后，会指定该类的类别、父类类别、父亲类别以及实现的接口</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>this_class ，类索引，用于确定这类的全限定名</td>
</tr>
<tr>
<td>u2</td>
<td>super_class，父类索引，用于确定这个类的父类全限定名</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count，接口计数器，标识当前类或接口的直接接口数量</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces[interfaces_count]，接口索引集合</td>
</tr>
</tbody></table>
<ul>
<li>这三项数据用来确定这个类的继承关系<ul>
<li>类索引，用于确定这类的全限定名</li>
<li>父类索引，用于确定这个类的父类全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0</li>
<li>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当使用extends语句）后的接口顺序从左到右排列在接口索引集合中</li>
</ul>
</li>
</ul>
<p><strong>this_class（类索引）</strong></p>
<ul>
<li>2字节无符号整数，指向常量池的索引。它提供了类的全限定名，如com/github/jvm2/chapter01/java1/Demo的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为CONSTANT_Class_info类型结构体，该结构体表示这个class文件所定义的类或接口。</li>
</ul>
<p><strong>super_class（父类索引）</strong></p>
<ul>
<li><p>2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是java/lang/Object类。同时，由于Java不支持多继承，所以其父类只有一个</p>
</li>
<li><p>superclass指向的父类不能是final</p>
</li>
</ul>
<p><strong>interfaces</strong></p>
<ul>
<li>指向常量池索引集合，它提供了一个符号引用到所有己实现的接口<br>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的素引，表示接口的每个素引也是一个指向常量池的CONSTANT_Class（当然这里就必须是接口，而不是类）<ul>
<li>interfaces_count（接口计数器）<br>nterfaces_count项的值表示当前类或接口的直接超接口数量</li>
<li>interfaces[]（接口索引集合）<br>interfaces[]中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为interfaces_count。每个成员interfaces[i]必须为CONSTANTClassnfo结构，其中0&lt;=i&lt;interfaces_count。在interfaces[]中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即interfaces[0]对应的是源代码中最左边的接口</li>
</ul>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201113113143.png"  alt="类索引、父类索引、接口索引"></p>
<h3 id="字段表集合（Fields）"><a href="#字段表集合（Fields）" class="headerlink" title="字段表集合（Fields）"></a>字段表集合（Fields）</h3><p><strong>字段表集合</strong></p>
<ul>
<li><p>用于描述接口或类中声明的变量。字段（field）包括类级变量以及实例级变量。但是不包括方法内部、代码块内部声明的局部变量。</p>
</li>
<li><p>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p>
</li>
<li><p>它指向常量池索引集合，它描还了每个字段的完整信息：比如字段的标识符、访问修饰符(public、private或protected)、是类变量还是实例变量(static修饰符）是否是常量(final修饰符）等。</p>
</li>
</ul>
<p>注意事项：</p>
<ul>
<li>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</li>
<li>在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</li>
</ul>
<h4 id="字段计数器（fields-count）"><a href="#字段计数器（fields-count）" class="headerlink" title="字段计数器（fields count）"></a>字段计数器（fields count）</h4><p>u2长度，fields_count的值表示当前class文件fields表的成员个数，使用两个字节来表示。<br>fields表中每个成员都是一个file_info结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。</p>
<h4 id="字段表（fields-）"><a href="#字段表（fields-）" class="headerlink" title="字段表（fields[]）"></a>字段表（fields[]）</h4><ul>
<li><p>fileds表中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述。</p>
</li>
<li><p>一个字段的信息包括如下这些信息，这些信息中，各个修饰符是布尔值，要么有，要么没有。</p>
<ul>
<li>作用域（public、private、protected修饰符）</li>
<li>是实例变量还是类变量（static修饰符〕</li>
<li>可变性（final修饰）</li>
<li>并发可见性（volatile修饰符，是否强制从主内存读写）</li>
<li>可否序列化（transient修饰符）</li>
<li>字段数据类型（基本数据类型、对象、数组）</li>
<li>字段名称</li>
</ul>
</li>
<li><p>字段表的结构，字段表作为一个表也有自己的结构</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">含义</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">accesss_flags</td>
<td align="center">访问标志</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">name_index</td>
<td align="center">字段名称索引</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">descriptor_index</td>
<td align="center">描述符索引</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">属性计数器</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">属性集合</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="字段访问标志（access-flags）"><a href="#字段访问标志（access-flags）" class="headerlink" title="字段访问标志（access_flags）"></a>字段访问标志（access_flags）</h5><p>我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符(public、private、protected）、static修饰符、final修饰符、volatile修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>字段是否为public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>字段是否为private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>字段是否为protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>字段是否为static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>字段是否为final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>字段是否为volatile</td>
</tr>
<tr>
<td>ACC_TRANSTENT</td>
<td>0x0080</td>
<td>字段是否为transient</td>
</tr>
<tr>
<td>ACC_SYNCHETIC</td>
<td>0x1000</td>
<td>字段是否为由编译器自动产生</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>字段是否为enum</td>
</tr>
</tbody></table>
<h5 id="字段名称索引-（name-index-）"><a href="#字段名称索引-（name-index-）" class="headerlink" title="字段名称索引  （name_index ）"></a>字段名称索引  （name_index ）</h5><p>根据字段名索引的值，查询常量池中的指定索引项即可</p>
<h5 id="字段描述符索引-（descriptor-index-）"><a href="#字段描述符索引-（descriptor-index-）" class="headerlink" title="字段描述符索引  （descriptor_index ）"></a>字段描述符索引  （descriptor_index ）</h5><p>描还符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型(byte,char,double,float,int,long,short,boolean)及代表无返回值的类型都用一个大写字符来表示，而对象则用字符L加对象的全限定名来表示，如下所示：</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本数据类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>代表void类型</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td>[</td>
<td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td>
</tr>
</tbody></table>
<h5 id="字段属性表集合（attributes）"><a href="#字段属性表集合（attributes）" class="headerlink" title="字段属性表集合（attributes）"></a>字段属性表集合（attributes）</h5><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在attribute_count中，属性具体内容存放在attributes数组中。<br>以常量属性为例．结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute&#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 constantvalue_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：对于常量属性而言，attribute_length值恒为2。</p>
<p>属性的通用格式：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
<td>属性表</td>
</tr>
</tbody></table>
<p>演示一下常量属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201113122443.png"  alt="常量属性"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201113122600.png"  alt="常量属性"></p>
<h3 id="方法表集合（Methods）"><a href="#方法表集合（Methods）" class="headerlink" title="方法表集合（Methods）"></a>方法表集合（Methods）</h3><p>methods：指向常量池索引集合，它完整描述了每个方法的签名。</p>
<ul>
<li>在字节码文件中，每一个method_info项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private或protected)，方法的返回值类型以及方法的参数信息等。</li>
<li>如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来。</li>
<li>一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：类（接口）初始化方法<code>&lt;clint&gt;()</code>和实例初始化方法<code>&lt;init&gt;()</code>）。</li>
</ul>
<p><strong>使用注意事项：</strong><br>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里无法仅仅依靠返回值的不同来对一个己有方法进行重我。但在Class文件格式中，特征签名的范围更大一些，只要述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个class文件中。</p>
<p>也就是说，尽管Java语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和Java语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。</p>
<h4 id="方法计数器（methods-count）"><a href="#方法计数器（methods-count）" class="headerlink" title="方法计数器（methods count）"></a>方法计数器（methods count）</h4><p>methods_count的值表示当前class文件methods表的成员个数。使用两个字节来表示。methods表中每一个成员都是一个method_info结构。</p>
<h4 id="方法表（methods-）"><a href="#方法表（methods-）" class="headerlink" title="方法表（methods[]）"></a>方法表（methods[]）</h4><ul>
<li>methods表中的每个成员都必须是一个method_info结构，用于表示当前类或接口中某个方法的完整描述。如果某个method_info结构的access_flags项既没有设置ACC_NATIVE标志也没有设置ACC_ABSTRACT标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。</li>
<li>method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法</li>
<li>方法表的结构实际跟字段表是一样的，方法表结构如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">含义</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">accesss_flasg</td>
<td align="center">访问标志</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">name_index</td>
<td align="center">方法名称索引</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">descriptor_index</td>
<td align="center">描述符索引</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">属性计数器</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">属性集合</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<h5 id="方法访问标志（access-flags）"><a href="#方法访问标志（access-flags）" class="headerlink" title="方法访问标志（access_flags）"></a>方法访问标志（access_flags）</h5><p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分不相同，具体如下：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201113153921.png"  alt="方法访问标志"></p>
<h5 id="方法名索引（name-index）"><a href="#方法名索引（name-index）" class="headerlink" title="方法名索引（name_index）"></a>方法名索引（name_index）</h5><p>根据方法名索引的值，查询常量池中的指定索引项即可</p>
<h5 id="方法描述索引（descriptor-index）"><a href="#方法描述索引（descriptor-index）" class="headerlink" title="方法描述索引（descriptor_index）"></a>方法描述索引（descriptor_index）</h5><p>参考字段表的描述索引</p>
<h5 id="方法的属性表集合（attributes）"><a href="#方法的属性表集合（attributes）" class="headerlink" title="方法的属性表集合（attributes）"></a>方法的属性表集合（attributes）</h5><p>参考字段表的属性表集合</p>
<h3 id="属性表集合（Attributes）"><a href="#属性表集合（Attributes）" class="headerlink" title="属性表集合（Attributes）"></a>属性表集合（Attributes）</h3><p>方法表集合之后的属性表集合，指的是Class文件所携带的辅助信息，比如该class文件的源文件的名称。以及任何带有RetentionPo1icy.CLASS或者RetentionPolicy.RUNTIME的注解。这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，一般无须深入了解。</p>
<p>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</p>
<p>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与己有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但Java虚拟机运行时会忽略掉它不认识的属性。</p>
<p>属性表的每一项的值必须是attribute_info结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p>
<p><strong>属性的通用格式</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
<td>属性表</td>
</tr>
</tbody></table>
<p>只需说明属性的名称以及占用位数的长度即可，属性表具体的结构可以去自定义。</p>
<p>attribute_info又可细分为以下21种(即《Java虚拟机规范(Java SE 7)》中预定义了的21项虚拟机实现应当能识别的属性)：</p>
<table>
<thead>
<tr>
<th align="left">属性名称</th>
<th align="left">使用位置</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Code</strong></td>
<td align="left">方法表中</td>
<td align="left">Java代码编译成的字节码指令(即：具体的方法逻辑字节码指令)</td>
</tr>
<tr>
<td align="left">ConstantValue</td>
<td align="left">字段表中</td>
<td align="left">final关键字定义的常量值</td>
</tr>
<tr>
<td align="left">Deprecated</td>
<td align="left">类中、方法表中、字段表中</td>
<td align="left">被声明为deprecated的方法和字段</td>
</tr>
<tr>
<td align="left">Exceptions</td>
<td align="left">方法表中</td>
<td align="left">方法声明的异常</td>
</tr>
<tr>
<td align="left"><strong>LocalVariableTable</strong></td>
<td align="left">Code属性中</td>
<td align="left">方法的局部变量描述</td>
</tr>
<tr>
<td align="left">LocalVariableTypeTable</td>
<td align="left">类中</td>
<td align="left">JDK1.5中新增的属性，它使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td align="left">InnerClasses</td>
<td align="left">类中</td>
<td align="left">内部类列表</td>
</tr>
<tr>
<td align="left">EnclosingMethod</td>
<td align="left">类中</td>
<td align="left">仅当一个类为局部类或者匿名类时，才能拥有这个属性，这个属性用于表示这个类所在的外围方法</td>
</tr>
<tr>
<td align="left"><strong>LineNumberTable</strong></td>
<td align="left">Code属性中</td>
<td align="left">Java源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td align="left">StackMapTable</td>
<td align="left">Code属性中</td>
<td align="left">JDK1.6中新增的属性，供新的类型检查验证器(Type Checker)检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配</td>
</tr>
<tr>
<td align="left">Signature</td>
<td align="left">类中、方法表中、字段表中</td>
<td align="left">JDK1.5新增的属性，这个属性用于支持泛型情况下的方法签名，在Java语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量(Type Variables)或参数类型(Parameterized Types),则Signature属性会为它记录泛型签名信息。由于Java的泛型采用擦除法实现，在为了避免类型信息被擦除后导致签名混乱，需要这个属性记录泛型中的相关信息</td>
</tr>
<tr>
<td align="left"><strong>SourceFile</strong></td>
<td align="left">类中</td>
<td align="left">记录源文件名称</td>
</tr>
<tr>
<td align="left">SourceDebugExtension</td>
<td align="left">类中</td>
<td align="left">JDK1.6中新增的属性，SourceDebugExtension用于存储额外的调试信息。如在进行JSP文件调试时，无法通过Java堆栈来定位到JSP文件的行号，JSR-45规范为这些非Java语言编写，却需要编译成字节码运行在Java虚拟机汇中的程序提供了一个进行调试的标准机制，使用SourceDebugExtension就可以存储这些调试信息。</td>
</tr>
<tr>
<td align="left">Synthetic</td>
<td align="left">类中、方法表中、字段表中</td>
<td align="left">标识方法或字段为编译器自动产生的</td>
</tr>
<tr>
<td align="left">RuntimeVisibleAnnotations</td>
<td align="left">类中、方法表中、字段表中</td>
<td align="left">JDK1.5中新增的属性，为动态注解提供支持。RuntimeVisibleAnnotations属性，用于指明哪些注解是运行时(实际上运行时就是进行反射调用)可见的。</td>
</tr>
<tr>
<td align="left">RuntimeVisibleParameterAnnotations</td>
<td align="left">方法表中</td>
<td align="left">JDK1.5中新增的属性，作用与RuntimeVisibleAnnotations类似，只不过作用对象为方法的参数。</td>
</tr>
<tr>
<td align="left">RuntimeInvisibleParameterAnnotations</td>
<td align="left">方法表中</td>
<td align="left">JDK1.5中新增的属性，作用与RuntimeInvisibleAnnotations类似，只不过作用对象为方法的参数。</td>
</tr>
<tr>
<td align="left">AnnotationDefault</td>
<td align="left">方法表中</td>
<td align="left">JDK1.5中新增的属性，用于记录注解类元素的默认值</td>
</tr>
<tr>
<td align="left">BootstrapMethods</td>
<td align="left">类中</td>
<td align="left">JDK1.7新增的属性，用于保存invokedynamic指令引用的引导方法限定符</td>
</tr>
</tbody></table>
<h4 id="Code属性介绍"><a href="#Code属性介绍" class="headerlink" title="Code属性介绍"></a>Code属性介绍</h4><p>Code属性就是存放方法体里面的代码。但是，并非所有的方法表都有Code属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有Code属性了。</p>
<blockquote>
<p>Java程序方法体重的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内，Code属性出现在方法表的属性集合中(如下图)，但并非所有的方法都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在。</p>
</blockquote>
<p>Code属性表的结构如图：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">attribute_name_index</td>
<td align="center">1</td>
<td align="center">属性名索引</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">attribute_length</td>
<td align="center">1</td>
<td align="center">属性长度</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">max_stack</td>
<td align="center">1</td>
<td align="center">操作数栈深度的最大值</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">max_locals</td>
<td align="center">1</td>
<td align="center">局部变量表所需的存续空间</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">code_length</td>
<td align="center">1</td>
<td align="center">字节码指令的长度</td>
</tr>
<tr>
<td align="center">u1</td>
<td align="center">code</td>
<td align="center">code_length</td>
<td align="center">存储字节码指令</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">exception_table_length</td>
<td align="center">1</td>
<td align="center">异常表长度</td>
</tr>
<tr>
<td align="center">exception_info</td>
<td align="center">exception_table</td>
<td align="center">exception_table_length</td>
<td align="center">异常表</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attribute_count</td>
<td align="center">1</td>
<td align="center">属性集合计数器</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">attribute_count</td>
<td align="center">属性集合</td>
</tr>
</tbody></table>
<p>可以看到：Code属性表的前两项跟属性是一致的，即Code属性表遵循属性表的结构，后面那些规则是他自定义的结构。</p>
<h4 id="LineNumberTable属性介绍"><a href="#LineNumberTable属性介绍" class="headerlink" title="LineNumberTable属性介绍"></a>LineNumberTable属性介绍</h4><blockquote>
<p>主要是用于描叙源代码行号和字节码行号之间的关系</p>
</blockquote>
<p>LineNumberTable属性是可选变长属性，位于Code结构的属性表。<br>LineNumberTab1e属性是用来描述Java源码行号与字节码行号之间的对应关系：这个属性可以用来在调试的时候定位代码执行的行数。<br>start_pc，即字节码行号;line_number,即Java源代码行号。<br>在code属性的属性表中,LineNumberTable属性可以按照任意顺序出现，此外，多个LineNumberTable属性可以共同表示一个行号在源文件中表示的内容，即LineNumberTable属性不需要与源文件的行一一对应。</p>
<p>LineNumberTables属性表结构：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201113173640.png"  alt="LineNumberTables属性表结构"></p>
<h4 id="LocalVariableTable属性介绍"><a href="#LocalVariableTable属性介绍" class="headerlink" title="LocalVariableTable属性介绍"></a>LocalVariableTable属性介绍</h4><blockquote>
<p>是用于描述栈帧中局部变量中的变量与java源码中定义的变量之间的关系</p>
</blockquote>
<p>LocalVariableTables属性表结构：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20201113173829.png"  alt="LocalVariableTables属性表结构"></p>
<h4 id="SourceFile属性介绍"><a href="#SourceFile属性介绍" class="headerlink" title="SourceFile属性介绍"></a>SourceFile属性介绍</h4><p>SourceFile属性结构：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">attribute_name_index</td>
<td align="center">1</td>
<td align="center">属性名索引</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">attribute_length</td>
<td align="center">1</td>
<td align="center">属性长度</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">source_index</td>
<td align="center">1</td>
<td align="center">源码文件索引</td>
</tr>
</tbody></table>
<h3 id="Class文件小结"><a href="#Class文件小结" class="headerlink" title="Class文件小结"></a>Class文件小结</h3><p>本章主要介绍了Class文件的基本格式。<br>随着Java平台的不断发展，在将来，Class文件的内容也一定会做进一步的扩充，但是其基本的格式和结构不会做重大调整。<br>从Java虚拟机的角度看，通过Class文件，可以让更多的计算机语言支持Java虚拟机平台。因此，Class文件结构不仅仅是Java虚拟机的执行入口，更是Java生态圈的基础和核心。</p>
<h2 id="使用javap指令解析Class文件"><a href="#使用javap指令解析Class文件" class="headerlink" title="使用javap指令解析Class文件"></a>使用javap指令解析Class文件</h2><h3 id="javap指令使用小结"><a href="#javap指令使用小结" class="headerlink" title="javap指令使用小结"></a>javap指令使用小结</h3><p>1、通过javap命令可以查看一个java类反汇编的到的Class文件版本号、常量池、访问标识、变量表、指令代码行号表等等信息。不显示类索引、父类索引、接口索引集合、<code>&lt;clinit&gt;()</code>、<code>&lt;init&gt;</code>等结构</p>
<p>2、通过对前面例子代码反汇编文件的简单分析，可以发现，一个方法的执行通常会涉及下面几块内存的操作：<br>（1）java栈中：局部变量表、操作数栈。<br>（2）java堆。通过对象的地址引用去操作。<br>（3）常量池。<br>（4）其他如帧数据区、方法区的剩余部分等情况，测试中没有显示出来，这里说明一下。</p>
<p>3、平常，我们比较关注的是java类中每个方法的反汇编中的指令操作过程，这些指令都是顺序执行的，可以参考官方文档查看每个指令的含义。</p>
<h1 id="字节码指令集与解析举例"><a href="#字节码指令集与解析举例" class="headerlink" title="字节码指令集与解析举例"></a>字节码指令集与解析举例</h1><p>this.</p>
<h1 id="类的加载过程详解"><a href="#类的加载过程详解" class="headerlink" title="类的加载过程详解"></a>类的加载过程详解</h1><h1 id="再谈类的加载器"><a href="#再谈类的加载器" class="headerlink" title="再谈类的加载器"></a>再谈类的加载器</h1></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81/">字节码</a><a class="post-meta__tags" href="/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/">类的加载</a></div><div class="post_share"><div class="social-share" data-image="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1693510714,1840516921&amp;fm=26&amp;gp=0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/11/07/UML%E5%BB%BA%E6%A8%A1/"><img class="prev_cover lazyload" data-src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1693510714,1840516921&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UML建模</div></div></a></div><div class="next-post pull_right"><a href="/2020/10/22/JVM%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/"><img class="next_cover lazyload" data-src="http://www.52xxit.com/data/attachment/forum/201809/10/160026v7ackztmcopvkisz.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM学习之性能监控与调优篇</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/10/22/JVM学习之性能监控与调优篇/" title="JVM学习之性能监控与调优篇"><img class="relatedPosts_cover lazyload"data-src="http://www.52xxit.com/data/attachment/forum/201809/10/160026v7ackztmcopvkisz.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-10-22</div><div class="relatedPosts_title">JVM学习之性能监控与调优篇</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/22/JVM学习之内存与垃圾回收篇/" title="JVM学习之内存与垃圾回收篇"><img class="relatedPosts_cover lazyload"data-src="http://www.52xxit.com/data/attachment/forum/201809/10/160026v7ackztmcopvkisz.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-22</div><div class="relatedPosts_title">JVM学习之内存与垃圾回收篇</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Kai</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>