<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM学习之内存与垃圾回收篇 | K的小屋</title><meta name="description" content="JVM学习之内存与垃圾回收篇"><meta name="keywords" content="JVM,垃圾回收"><meta name="author" content="Kai"><meta name="copyright" content="Kai"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM学习之内存与垃圾回收篇"><meta name="twitter:description" content="JVM学习之内存与垃圾回收篇"><meta name="twitter:image" content="http://www.52xxit.com/data/attachment/forum/201809/10/160026v7ackztmcopvkisz.jpg"><meta property="og:type" content="article"><meta property="og:title" content="JVM学习之内存与垃圾回收篇"><meta property="og:url" content="https://www.google.com/2020/06/22/JVM%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/"><meta property="og:site_name" content="K的小屋"><meta property="og:description" content="JVM学习之内存与垃圾回收篇"><meta property="og:image" content="http://www.52xxit.com/data/attachment/forum/201809/10/160026v7ackztmcopvkisz.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://www.google.com/2020/06/22/JVM%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/"><link rel="prev" title="作业：Android so文件的解析" href="https://www.google.com/2020/06/23/%E4%BD%9C%E4%B8%9A%EF%BC%9AAndroid%20so%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90/"><link rel="next" title="《深入理解计算机系统》读书笔记" href="https://www.google.com/2020/06/11/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#说明"><span class="toc-number">1.1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#推荐书籍"><span class="toc-number">1.2.</span> <span class="toc-text">推荐书籍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM与Java体系结构"><span class="toc-number">2.</span> <span class="toc-text">JVM与Java体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#跨平台的语言Java和跨语言的平台JVM"><span class="toc-number">2.1.</span> <span class="toc-text">跨平台的语言Java和跨语言的平台JVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字节码"><span class="toc-number">2.2.</span> <span class="toc-text">字节码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多语言混合编程"><span class="toc-number">2.3.</span> <span class="toc-text">多语言混合编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java发展的重大事件"><span class="toc-number">2.4.</span> <span class="toc-text">Java发展的重大事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Open-JDK和Oracle-JDK"><span class="toc-number">2.5.</span> <span class="toc-text">Open JDK和Oracle JDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机与Java虚拟机"><span class="toc-number">2.6.</span> <span class="toc-text">虚拟机与Java虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM的整体结构"><span class="toc-number">2.7.</span> <span class="toc-text">JVM的整体结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM架构模型"><span class="toc-number">2.8.</span> <span class="toc-text">JVM架构模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM生命周期"><span class="toc-number">2.9.</span> <span class="toc-text">JVM生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM的发展历程"><span class="toc-number">2.10.</span> <span class="toc-text">JVM的发展历程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sun-Classic-VM"><span class="toc-number">2.10.1.</span> <span class="toc-text">Sun Classic VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exact-VM"><span class="toc-number">2.10.2.</span> <span class="toc-text">Exact VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HotSpot-VM"><span class="toc-number">2.10.3.</span> <span class="toc-text">HotSpot VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JRockit-VM"><span class="toc-number">2.10.4.</span> <span class="toc-text">JRockit VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J9-VM"><span class="toc-number">2.10.5.</span> <span class="toc-text">J9 VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KVM、CDC、CLDC"><span class="toc-number">2.10.6.</span> <span class="toc-text">KVM、CDC、CLDC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Azul-VM"><span class="toc-number">2.10.7.</span> <span class="toc-text">Azul VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Liquid-VM"><span class="toc-number">2.10.8.</span> <span class="toc-text">Liquid VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Apache-Harmony"><span class="toc-number">2.10.9.</span> <span class="toc-text">Apache Harmony</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Microsoft-JVM"><span class="toc-number">2.10.10.</span> <span class="toc-text">Microsoft JVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TaobaoJVM"><span class="toc-number">2.10.11.</span> <span class="toc-text">TaobaoJVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dalvik-VM"><span class="toc-number">2.10.12.</span> <span class="toc-text">Dalvik VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他JVM"><span class="toc-number">2.10.13.</span> <span class="toc-text">其他JVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graal-VM"><span class="toc-number">2.10.14.</span> <span class="toc-text">Graal VM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类加载子系统"><span class="toc-number">3.</span> <span class="toc-text">类加载子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存结构概述"><span class="toc-number">3.1.</span> <span class="toc-text">内存结构概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器与类的加载过程"><span class="toc-number">3.2.</span> <span class="toc-text">类加载器与类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类的加载过程"><span class="toc-number">3.2.1.</span> <span class="toc-text">类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#加载（Loading）"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">加载（Loading）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链接（Linking）"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">链接（Linking）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化（Initialization）"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">初始化（Initialization）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码演示"><span class="toc-number">3.2.2.</span> <span class="toc-text">代码演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器分类"><span class="toc-number">3.3.</span> <span class="toc-text">类加载器分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟机自带的加载器"><span class="toc-number">3.3.1.</span> <span class="toc-text">虚拟机自带的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">启动类加载器（引导类加载器，Bootstrap ClassLoader）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展类加载器（Extension-ClassLoader）"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">扩展类加载器（Extension ClassLoader）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#应用程序类加载器（AppClassLoader）"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">应用程序类加载器（AppClassLoader）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户自定义类加载器"><span class="toc-number">3.3.2.</span> <span class="toc-text">用户自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassLoader的使用说明"><span class="toc-number">3.4.</span> <span class="toc-text">ClassLoader的使用说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟机自带类加载器演示"><span class="toc-number">3.4.1.</span> <span class="toc-text">虚拟机自带类加载器演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户自定义加载类演示"><span class="toc-number">3.4.2.</span> <span class="toc-text">用户自定义加载类演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取ClassLoader的几种途径"><span class="toc-number">3.4.3.</span> <span class="toc-text">获取ClassLoader的几种途径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双亲委派机制"><span class="toc-number">3.5.</span> <span class="toc-text">双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委派工作原理"><span class="toc-number">3.5.1.</span> <span class="toc-text">双亲委派工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委派机制的优势"><span class="toc-number">3.5.2.</span> <span class="toc-text">双亲委派机制的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">3.6.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#判断两个class对象是否为同一个类"><span class="toc-number">3.6.1.</span> <span class="toc-text">判断两个class对象是否为同一个类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对类加载器的引用"><span class="toc-number">3.6.2.</span> <span class="toc-text">对类加载器的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的主动使用和被动使用"><span class="toc-number">3.6.3.</span> <span class="toc-text">类的主动使用和被动使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运行时数据区（Runtime-Data-Area）"><span class="toc-number">4.</span> <span class="toc-text">运行时数据区（Runtime Data Area）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#程序计数器-PC-Register"><span class="toc-number">4.1.</span> <span class="toc-text">程序计数器(PC Register)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用"><span class="toc-number">4.1.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍"><span class="toc-number">4.1.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于PC寄存器的两个常见问题"><span class="toc-number">4.1.3.</span> <span class="toc-text">关于PC寄存器的两个常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU时间片"><span class="toc-number">4.1.4.</span> <span class="toc-text">CPU时间片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机栈-Java-Virtual-Machine-Stack"><span class="toc-number">4.2.</span> <span class="toc-text">虚拟机栈(Java Virtual Machine Stack)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">4.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈的存储单位"><span class="toc-number">4.2.2.</span> <span class="toc-text">栈的存储单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧-局部变量表（local-variables）"><span class="toc-number">4.2.3.</span> <span class="toc-text">栈帧-局部变量表（local variables）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#变量槽Slot"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">变量槽Slot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态变量与局部变量的对比"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">静态变量与局部变量的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧-操作数栈-Operand-Stack"><span class="toc-number">4.2.4.</span> <span class="toc-text">栈帧-操作数栈(Operand Stack)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#操作数栈说明"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">操作数栈说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#操作数栈的字节码指令执行分析"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">操作数栈的字节码指令执行分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈顶缓存（Top-Of-Stack-Cashing）技术"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">栈顶缓存（Top-Of-Stack Cashing）技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧-动态链接-Dynamic-Linking"><span class="toc-number">4.2.5.</span> <span class="toc-text">栈帧-动态链接(Dynamic Linking)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法的调用"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">方法的调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧-返回地址-return-address"><span class="toc-number">4.2.6.</span> <span class="toc-text">栈帧-返回地址(return address)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧-一些附加信息"><span class="toc-number">4.2.7.</span> <span class="toc-text">栈帧-一些附加信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于栈的一些面试题"><span class="toc-number">4.2.8.</span> <span class="toc-text">关于栈的一些面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地方法接口-不属于运行时数据区"><span class="toc-number">4.3.</span> <span class="toc-text">本地方法接口(不属于运行时数据区)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是本地方法接口"><span class="toc-number">4.3.1.</span> <span class="toc-text">什么是本地方法接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要使用Native-Method"><span class="toc-number">4.3.2.</span> <span class="toc-text">为什么要使用Native Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#现状"><span class="toc-number">4.3.3.</span> <span class="toc-text">现状</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地方法栈-Native-Method-Stack"><span class="toc-number">4.4.</span> <span class="toc-text">本地方法栈(Native Method Stack)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆（Heap）"><span class="toc-number">4.5.</span> <span class="toc-text">堆（Heap）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#堆核心概述"><span class="toc-number">4.5.1.</span> <span class="toc-text">堆核心概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆的细分内存结构（重点）"><span class="toc-number">4.5.2.</span> <span class="toc-text">堆的细分内存结构（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置堆的大小"><span class="toc-number">4.5.3.</span> <span class="toc-text">设置堆的大小</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OOM演示"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">OOM演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新生代与老年代"><span class="toc-number">4.5.4.</span> <span class="toc-text">新生代与老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图解对象分配过程"><span class="toc-number">4.5.5.</span> <span class="toc-text">图解对象分配过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-GC、Major-GC与Full-GC"><span class="toc-number">4.5.6.</span> <span class="toc-text">Minor GC、Major GC与Full GC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#年轻代GC（Minor-GC-Young-GC）触发机制"><span class="toc-number">4.5.6.1.</span> <span class="toc-text">年轻代GC（Minor GC&#x2F;Young GC）触发机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#老年代GC（Major-GC-Old-GC）触发机制"><span class="toc-number">4.5.6.2.</span> <span class="toc-text">老年代GC（Major GC&#x2F;Old GC）触发机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#整堆收集Full-GC触发机制"><span class="toc-number">4.5.6.3.</span> <span class="toc-text">整堆收集Full GC触发机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC举例与日志分析"><span class="toc-number">4.5.6.4.</span> <span class="toc-text">GC举例与日志分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆空间分代思想"><span class="toc-number">4.5.7.</span> <span class="toc-text">堆空间分代思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存分配策略（或对象提升promotion规则）"><span class="toc-number">4.5.8.</span> <span class="toc-text">内存分配策略（或对象提升promotion规则）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#测试：大对象直接进入老年代"><span class="toc-number">4.5.8.1.</span> <span class="toc-text">测试：大对象直接进入老年代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLAB"><span class="toc-number">4.5.9.</span> <span class="toc-text">TLAB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么会有TLAB（Thread-Local-Allocation-Buffer）"><span class="toc-number">4.5.9.1.</span> <span class="toc-text">为什么会有TLAB（Thread Local Allocation Buffer）?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是TLAB？"><span class="toc-number">4.5.9.2.</span> <span class="toc-text">什么是TLAB？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLAB补充说明"><span class="toc-number">4.5.9.3.</span> <span class="toc-text">TLAB补充说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆空间的参数设置小结"><span class="toc-number">4.5.10.</span> <span class="toc-text">堆空间的参数设置小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逃逸分析"><span class="toc-number">4.5.11.</span> <span class="toc-text">逃逸分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#逃逸分析概念"><span class="toc-number">4.5.11.1.</span> <span class="toc-text">逃逸分析概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用逃逸分析进行代码优化"><span class="toc-number">4.5.11.2.</span> <span class="toc-text">利用逃逸分析进行代码优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#栈上分配"><span class="toc-number">4.5.11.2.1.</span> <span class="toc-text">栈上分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#同步省略（消除）"><span class="toc-number">4.5.11.2.2.</span> <span class="toc-text">同步省略（消除）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分离对象（标量替换）"><span class="toc-number">4.5.11.2.3.</span> <span class="toc-text">分离对象（标量替换）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#逃逸分析小结"><span class="toc-number">4.5.11.3.</span> <span class="toc-text">逃逸分析小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#本章小结"><span class="toc-number">4.5.12.</span> <span class="toc-text">本章小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区（Method-Area）"><span class="toc-number">4.6.</span> <span class="toc-text">方法区（Method Area）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#栈、堆、、方法区的交互关系"><span class="toc-number">4.6.1.</span> <span class="toc-text">栈、堆、、方法区的交互关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的理解"><span class="toc-number">4.6.2.</span> <span class="toc-text">方法区的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法区大小与OOM"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">方法区大小与OOM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置方法区大小与OOM"><span class="toc-number">4.6.3.</span> <span class="toc-text">设置方法区大小与OOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#演示OOM"><span class="toc-number">4.6.3.1.</span> <span class="toc-text">演示OOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何解决OOM？"><span class="toc-number">4.6.3.2.</span> <span class="toc-text">如何解决OOM？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区内部结构"><span class="toc-number">4.6.4.</span> <span class="toc-text">方法区内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法区（Method-Area）存储什么？"><span class="toc-number">4.6.4.1.</span> <span class="toc-text">方法区（Method Area）存储什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#类型信息"><span class="toc-number">4.6.4.1.1.</span> <span class="toc-text">类型信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#域（Field）信息"><span class="toc-number">4.6.4.1.2.</span> <span class="toc-text">域（Field）信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#方法（Method）信息"><span class="toc-number">4.6.4.1.3.</span> <span class="toc-text">方法（Method）信息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行时常量池vs常量池"><span class="toc-number">4.6.4.2.</span> <span class="toc-text">运行时常量池vs常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么需要常量池？"><span class="toc-number">4.6.4.2.1.</span> <span class="toc-text">为什么需要常量池？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#常量池中都有什么？"><span class="toc-number">4.6.4.2.2.</span> <span class="toc-text">常量池中都有什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#运行时常量的理解"><span class="toc-number">4.6.4.2.3.</span> <span class="toc-text">运行时常量的理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区使用举例"><span class="toc-number">4.6.5.</span> <span class="toc-text">方法区使用举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的演进"><span class="toc-number">4.6.6.</span> <span class="toc-text">方法区的演进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#永久代为什么要被元空间替换"><span class="toc-number">4.6.6.1.</span> <span class="toc-text">永久代为什么要被元空间替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringTable为什么要调整位置"><span class="toc-number">4.6.6.2.</span> <span class="toc-text">StringTable为什么要调整位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态变量放在哪里？"><span class="toc-number">4.6.7.</span> <span class="toc-text">静态变量放在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的垃圾回收"><span class="toc-number">4.6.8.</span> <span class="toc-text">方法区的垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时数据区总结"><span class="toc-number">4.7.</span> <span class="toc-text">运行时数据区总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常见面试题"><span class="toc-number">4.7.1.</span> <span class="toc-text">常见面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的实例化、内存布局与访问定位（补充）"><span class="toc-number">4.8.</span> <span class="toc-text">对象的实例化、内存布局与访问定位（补充）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的实例化"><span class="toc-number">4.8.1.</span> <span class="toc-text">对象的实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#从字节码角度去看对象创建过程"><span class="toc-number">4.8.1.1.</span> <span class="toc-text">从字节码角度去看对象创建过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从代码执行步骤的角度去看对象创建过程"><span class="toc-number">4.8.1.2.</span> <span class="toc-text">从代码执行步骤的角度去看对象创建过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的内存布局"><span class="toc-number">4.8.2.</span> <span class="toc-text">对象的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的访问定位"><span class="toc-number">4.8.3.</span> <span class="toc-text">对象的访问定位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#句柄访问"><span class="toc-number">4.8.3.1.</span> <span class="toc-text">句柄访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#直接指针"><span class="toc-number">4.8.3.2.</span> <span class="toc-text">直接指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直接内存（补充）"><span class="toc-number">4.9.</span> <span class="toc-text">直接内存（补充）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#直接内存概述"><span class="toc-number">4.9.1.</span> <span class="toc-text">直接内存概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直接内存的OOM与内存大小的设置"><span class="toc-number">4.9.2.</span> <span class="toc-text">直接内存的OOM与内存大小的设置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StringTable"><span class="toc-number">5.</span> <span class="toc-text">StringTable</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#执行引擎（Execution-Engine）"><span class="toc-number">6.</span> <span class="toc-text">执行引擎（Execution Engine）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述-1"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java代码编译和执行过程"><span class="toc-number">6.2.</span> <span class="toc-text">Java代码编译和执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编译过程"><span class="toc-number">6.2.1.</span> <span class="toc-text">编译过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行过程"><span class="toc-number">6.2.2.</span> <span class="toc-text">执行过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#机器码、指令、汇编语言"><span class="toc-number">6.3.</span> <span class="toc-text">机器码、指令、汇编语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#机器码"><span class="toc-number">6.3.1.</span> <span class="toc-text">机器码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令"><span class="toc-number">6.3.2.</span> <span class="toc-text">指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令集"><span class="toc-number">6.3.3.</span> <span class="toc-text">指令集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#汇编语言"><span class="toc-number">6.3.4.</span> <span class="toc-text">汇编语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高级语言"><span class="toc-number">6.3.5.</span> <span class="toc-text">高级语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C、C-源程序执行过程"><span class="toc-number">6.3.5.1.</span> <span class="toc-text">C、C++源程序执行过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字节码-1"><span class="toc-number">6.3.6.</span> <span class="toc-text">字节码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释器"><span class="toc-number">6.4.</span> <span class="toc-text">解释器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解释器工作机制（工作任务）"><span class="toc-number">6.4.1.</span> <span class="toc-text">解释器工作机制（工作任务）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解释器分类"><span class="toc-number">6.4.2.</span> <span class="toc-text">解释器分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#现状-1"><span class="toc-number">6.4.3.</span> <span class="toc-text">现状</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JIT编译器"><span class="toc-number">6.5.</span> <span class="toc-text">JIT编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java代码执行分类"><span class="toc-number">6.5.1.</span> <span class="toc-text">Java代码执行分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HotSpot-JVM的执行方式"><span class="toc-number">6.5.2.</span> <span class="toc-text">HotSpot JVM的执行方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JIT相关概念"><span class="toc-number">6.5.3.</span> <span class="toc-text">JIT相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#热点代码及探测方式"><span class="toc-number">6.5.4.</span> <span class="toc-text">热点代码及探测方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法调用计数器"><span class="toc-number">6.5.4.1.</span> <span class="toc-text">方法调用计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#回边计数器"><span class="toc-number">6.5.4.2.</span> <span class="toc-text">回边计数器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置HotSpot-VM程序执行方式"><span class="toc-number">6.5.5.</span> <span class="toc-text">设置HotSpot VM程序执行方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HotSpot-VM中JIT分类"><span class="toc-number">6.5.6.</span> <span class="toc-text">HotSpot VM中JIT分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C1和C2编译器不同的优化策略"><span class="toc-number">6.5.6.1.</span> <span class="toc-text">C1和C2编译器不同的优化策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分层编译"><span class="toc-number">6.5.6.2.</span> <span class="toc-text">分层编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结"><span class="toc-number">6.5.6.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拓展：Graal编译器和AOT编译器"><span class="toc-number">6.6.</span> <span class="toc-text">拓展：Graal编译器和AOT编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Graal编译器"><span class="toc-number">6.6.1.</span> <span class="toc-text">Graal编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOT编译器"><span class="toc-number">6.6.2.</span> <span class="toc-text">AOT编译器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#垃圾回收器（Garbage-Collection）"><span class="toc-number">7.</span> <span class="toc-text">垃圾回收器（Garbage Collection）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收概述"><span class="toc-number">7.1.</span> <span class="toc-text">垃圾回收概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是垃圾"><span class="toc-number">7.1.1.</span> <span class="toc-text">什么是垃圾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么需要GC"><span class="toc-number">7.1.2.</span> <span class="toc-text">为什么需要GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#早期垃圾回收"><span class="toc-number">7.1.3.</span> <span class="toc-text">早期垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java垃圾回收机制"><span class="toc-number">7.1.4.</span> <span class="toc-text">Java垃圾回收机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收相关算法"><span class="toc-number">7.2.</span> <span class="toc-text">垃圾回收相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾标记阶段"><span class="toc-number">7.2.1.</span> <span class="toc-text">垃圾标记阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引用计数法"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可达性分析算法"><span class="toc-number">7.2.1.2.</span> <span class="toc-text">可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的finalization机制"><span class="toc-number">7.2.2.</span> <span class="toc-text">对象的finalization机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的三种存在状态"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">对象的三种存在状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾清除阶段"><span class="toc-number">7.2.3.</span> <span class="toc-text">垃圾清除阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#标记-清除算法（Mark-Sweep）"><span class="toc-number">7.2.3.1.</span> <span class="toc-text">标记-清除算法（Mark-Sweep）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复制算法（Coping）"><span class="toc-number">7.2.3.2.</span> <span class="toc-text">复制算法（Coping）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标记-整理算法（Mark-Compat）"><span class="toc-number">7.2.3.3.</span> <span class="toc-text">标记-整理算法（Mark-Compat）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种清除算法对比"><span class="toc-number">7.2.4.</span> <span class="toc-text">三种清除算法对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分代收集算法"><span class="toc-number">7.2.5.</span> <span class="toc-text">分代收集算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增量收集算法"><span class="toc-number">7.2.6.</span> <span class="toc-text">增量收集算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分区算法"><span class="toc-number">7.2.7.</span> <span class="toc-text">分区算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收相关概念"><span class="toc-number">7.3.</span> <span class="toc-text">垃圾回收相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#System-gc-的理解"><span class="toc-number">7.3.1.</span> <span class="toc-text">System.gc()的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存溢出与内存泄露"><span class="toc-number">7.3.2.</span> <span class="toc-text">内存溢出与内存泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内存溢出"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">内存溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存泄露"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">内存泄露</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stop-the-World"><span class="toc-number">7.3.3.</span> <span class="toc-text">Stop the World</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收的并行与并发"><span class="toc-number">7.3.4.</span> <span class="toc-text">垃圾回收的并行与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#并发（Concurrent）"><span class="toc-number">7.3.4.1.</span> <span class="toc-text">并发（Concurrent）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并行"><span class="toc-number">7.3.4.2.</span> <span class="toc-text">并行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全点与安全区域"><span class="toc-number">7.3.5.</span> <span class="toc-text">安全点与安全区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安全点"><span class="toc-number">7.3.5.1.</span> <span class="toc-text">安全点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安全区域"><span class="toc-number">7.3.5.2.</span> <span class="toc-text">安全区域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用"><span class="toc-number">7.3.6.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#强引用—不回收"><span class="toc-number">7.3.6.1.</span> <span class="toc-text">强引用—不回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#软引用—内存不足即回收"><span class="toc-number">7.3.6.2.</span> <span class="toc-text">软引用—内存不足即回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#弱引用—发现即回收"><span class="toc-number">7.3.6.3.</span> <span class="toc-text">弱引用—发现即回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚引用—对象回收跟踪"><span class="toc-number">7.3.6.4.</span> <span class="toc-text">虚引用—对象回收跟踪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#终结器引用"><span class="toc-number">7.3.6.5.</span> <span class="toc-text">终结器引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收器"><span class="toc-number">7.4.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GC分类与性能指标"><span class="toc-number">7.4.1.</span> <span class="toc-text">GC分类与性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#垃圾回收器概述"><span class="toc-number">7.4.1.1.</span> <span class="toc-text">垃圾回收器概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#垃圾回收器分类"><span class="toc-number">7.4.1.2.</span> <span class="toc-text">垃圾回收器分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#评估GC的性能指标"><span class="toc-number">7.4.1.3.</span> <span class="toc-text">评估GC的性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#吞吐量-throughput"><span class="toc-number">7.4.1.3.1.</span> <span class="toc-text">吞吐量(throughput)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#暂停时间-pause-time"><span class="toc-number">7.4.1.3.2.</span> <span class="toc-text">暂停时间(pause time)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#吞吐量vs暂停时间"><span class="toc-number">7.4.1.3.3.</span> <span class="toc-text">吞吐量vs暂停时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不同的垃圾回收器概述"><span class="toc-number">7.4.2.</span> <span class="toc-text">不同的垃圾回收器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#垃圾收集器发展史"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">垃圾收集器发展史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#垃圾收集器的组合关系"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">垃圾收集器的组合关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial回收器（串行回收）"><span class="toc-number">7.4.3.</span> <span class="toc-text">Serial回收器（串行回收）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew回收器（并行回收）"><span class="toc-number">7.4.4.</span> <span class="toc-text">ParNew回收器（并行回收）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel回收器（吞吐量优先）"><span class="toc-number">7.4.5.</span> <span class="toc-text">Parallel回收器（吞吐量优先）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS回收器（低延迟）"><span class="toc-number">7.4.6.</span> <span class="toc-text">CMS回收器（低延迟）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1回收器（区域化分代式）"><span class="toc-number">7.4.7.</span> <span class="toc-text">G1回收器（区域化分代式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器总结"><span class="toc-number">7.4.8.</span> <span class="toc-text">垃圾回收器总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC日志分析"><span class="toc-number">7.4.9.</span> <span class="toc-text">GC日志分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器的新发展"><span class="toc-number">7.4.10.</span> <span class="toc-text">垃圾回收器的新发展</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(http://www.52xxit.com/data/attachment/forum/201809/10/160026v7ackztmcopvkisz.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">K的小屋</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">JVM学习之内存与垃圾回收篇</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-22 20:30:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-22</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-16 16:17:16"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-16</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">60.1k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 205 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Java语言规范和JVM虚拟机规范可以从官方地址进行下载：<a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/index.html</a></p>
<p>picgo端口号：36677</p>
<h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p>《Java虚拟机规范》</p>
<p><strong>《深入理解Java虚拟机》</strong>：推荐</p>
<p>《深入理解JVM&amp;G1 GC》</p>
<p>《解密Java虚拟机》</p>
<p>《Java虚拟机基础教程》</p>
<p>《实战Java虚拟机》</p>
<p>《Java虚拟机精讲》</p>
<p>《码出高效Java开发手册》</p>
<p>《自己动手写Java虚拟机》</p>
<h1 id="JVM与Java体系结构"><a href="#JVM与Java体系结构" class="headerlink" title="JVM与Java体系结构"></a>JVM与Java体系结构</h1><h2 id="跨平台的语言Java和跨语言的平台JVM"><a href="#跨平台的语言Java和跨语言的平台JVM" class="headerlink" title="跨平台的语言Java和跨语言的平台JVM"></a>跨平台的语言Java和跨语言的平台JVM</h2><p>TIOBE语言热度排行榜：<a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener">https://www.tiobe.com/tiobe-index/</a></p>
<blockquote>
<p>世界上没有最好的编程语言，只有最适合于具体应用场景的编程语言。</p>
</blockquote>
<p><strong>Java生态圈</strong></p>
<p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大，Java也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p>
<ul>
<li>作为一个平台，Java虚拟机扮演着举足轻重的作用<ul>
<li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li>
</ul>
</li>
<li>作为一种文化，Java几乎成为了“开源”的代名词<ul>
<li>第三方开源软件和框架，如Tomcat、MyBatis、Spring等</li>
<li>就连JDK和JVM自身也有不少开源的实现，如OpenJDK、Harmony</li>
</ul>
</li>
<li>作为一个社区，Java拥有全世界最多的技术拥护者和开源社区的支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式指复杂、参与人数之众多也令人咋舌</li>
</ul>
<p><strong>Java：跨平台的语言</strong></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622170015.png"  alt="Java一次编译到处运行"></p>
<p><strong>JVM官方介绍</strong></p>
<blockquote>
<p>The Java Virtual Machine is the cornerstone of the Java platform. <strong>It is the component of the technology responsible for its hardware- and operating system-independence</strong>, the small size of its compiled code, and its ability to protect users from malicious programs.</p>
<p>The Java Virtual Machine is an abstract computing machine. Like a real computing machine, it has an instruction set and manipulates various memory areas at run time. It is reasonably common to implement a programming language using a virtual machine; the best-known virtual machine may be the P-Code machine of UCSD Pascal.</p>
</blockquote>
<p>Google翻译：</p>
<blockquote>
<p>Java虚拟机是Java平台的基石。它是技术的组成部分，负责硬件和操作系统的独立性，编译代码的小巧大小以及保护用户免受恶意程序侵害的能力。</p>
<p>Java虚拟机是抽象的计算机。像真正的计算机一样，它具有指令集，并在运行时操作各种内存区域。使用虚拟机实现编程语言是相当普遍的。最知名的虚拟机可能是UCSD Pascal的P代码计算机。</p>
</blockquote>
<p>小结：Java是跨平台的语言，JVM是跨语言的平台</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622171157.png"  alt="JVM-跨语言的平台"></p>
<p>解释“JVM是跨语言的平台”：</p>
<ul>
<li>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现<strong>在Java虚拟机平台上运行非Java语言编写的程序</strong></li>
<li>Java虚拟机根部不关系运行在其内部的程序到底是使用何种编程语言编写的，<strong>它只关心“字节码”文件</strong>。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机内部指令集、符号表以及其他辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</li>
</ul>
<blockquote>
<p>Java不是最强大的语言，但是JVM是最强大的虚拟机</p>
</blockquote>
<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><ul>
<li>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：<strong>jvm字节码</strong></li>
<li>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行</li>
<li>Java虚拟机与Java语言并没有必然的联系，它只与特点的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者成为字节码、Bytecodes）和符号表，还有一些辅助信息</li>
</ul>
<h2 id="多语言混合编程"><a href="#多语言混合编程" class="headerlink" title="多语言混合编程"></a>多语言混合编程</h2><p>​    <strong>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方法</strong>。</p>
<p>​    试想一些，在一个项目之中，并行处理使用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都使用不同的编程语言来完成，并且接口对每一层的开发者都是透明的，<strong>各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上</strong>。</p>
<p>​    对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Davinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），<strong>推动Java虚拟机从“Java语言的虚拟机”向“多语言虚拟机”的方法发展</strong>。</p>
<h2 id="Java发展的重大事件"><a href="#Java发展的重大事件" class="headerlink" title="Java发展的重大事件"></a>Java发展的重大事件</h2><ul>
<li>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出新的程序语言，命名为Oak，后期命名为Java</li>
<li>1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相</li>
<li>1996年1月23日Sun Microsystems发布了JDK 1.0</li>
<li>1998年，JDK 1.2版本发布。同时，Sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动应用3大领域挺进</li>
<li>2000年，JDK 1.3发布，<strong>Java HotSpot Virtual Machine正式发布，成为Java默认的虚拟机</strong></li>
<li>2002年，JDK 1.4发布，古老的Classic虚拟机退出历史舞台</li>
<li>2003年底<strong>，Java平台Scala正式发布，同年Groovy也加入了Java阵营</strong></li>
<li>2004年，JDK 1.5发布，同时JDK 1.5改名成为Java SE 5.0</li>
<li>2006年，JDK 6发布，同年<strong>Java开源并建立了OpenJDK</strong>。顺理成章，<strong>Hotspot虚拟机也成为了OpenJDK中默认的虚拟机</strong></li>
<li>2007年，<strong>Java平台迎来了新伙伴Clojure</strong></li>
<li>2008年，Oracle收购了BEA，<strong>得到了JRockit虚拟机</strong></li>
<li>2009男，Twitter宣布把后台大部分程序从Ruby迁移到Scala，这是Java平台的又一次大规模应用</li>
<li>2010年，Oracale收购了Sun，<strong>获得了Java商标和最具价值的HotSpot虚拟机</strong>。此时，Orcale拥有市场率最高的两款虚拟机HotSpot和JRockit，并计划在未来对他们进行整合：HotRockit</li>
<li>2011年，JDK7发布，在JDK1.7u4中，<strong>正式启用了新的垃圾回收期G1</strong></li>
<li>2017年，JDK9发布，<strong>并将G1设置为默认GC，替代CMS</strong>。同年，IBM的J9开源，形成了现在的Open J9社区</li>
<li>2018年，Android的Java侵权案判决，Google赔偿Oracle计88亿美元</li>
<li>2018年，Oracle宣布JavaEE成为历史名词，JDBC、JMS、Servlet赠予Eclipse基金会</li>
<li>2018年，JDK11发布，LTS版本的JDK，<strong>发布革命性的ZGC，调整JDK授权许可</strong></li>
<li>2019年，JDK12发布，加入Redhat领导开发的<strong>Shenandoah GC</strong></li>
</ul>
<h2 id="Open-JDK和Oracle-JDK"><a href="#Open-JDK和Oracle-JDK" class="headerlink" title="Open JDK和Oracle JDK"></a>Open JDK和Oracle JDK</h2><blockquote>
<p>Oracle JDK与OpenJDK里的JVM都是HotSpot VM。从源码层面说，两者基本上是同一个东西。</p>
<p>从JDK7开始，Oracle JDK里的HotSpot VM，在研发的时候其实就是用放在OpenJDK的Mercurial代码库。也就是说跟大家从外部能实时看到的OpenJDK用的是同一个代码库。</p>
<p>Java SE的主要版本大约每两年发布一次，直到Java SE 7.从Java SE 6开始花了五年时间，之后又花了三年时间到达Java SE 8。</p>
<p>自Java SE 10以来，我们可以期待每六个月发布一次新版本。但是，并非所有版本都是长期支持（LTS）版本。</p>
<p>由于Oracle的发布计划，LTS产品发布仅每三年发布一次。Java SE 11是最新的LTS版本，Java SE 8将在2020年12月之前获得免费的公共更新，用于非商业用途。</p>
</blockquote>
<p>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一 次；</p>
<p>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是 OpenJDK的一个实现，并不是完全开源的；</p>
<p>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎 相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发 企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和 稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应 用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</p>
<p>顶级公司正在使用Oracle JDK，例如Android Studio，Minecraft和 IntelliJ IDEA开发工具，其中Open JDK不太受欢迎；</p>
<p>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的 性能；</p>
<p>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过 更新到最新版本获得支持来获取最新版本；</p>
<p>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</p>
<h2 id="虚拟机与Java虚拟机"><a href="#虚拟机与Java虚拟机" class="headerlink" title="虚拟机与Java虚拟机"></a>虚拟机与Java虚拟机</h2><p><strong>虚拟机</strong></p>
<ul>
<li><p>所谓虚拟机，就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<strong>系统虚拟机</strong>和<strong>程序虚拟机</strong></p>
<ul>
<li>大名鼎鼎的Visual Box，VMware就属于系统虚拟机，它们<strong>完全是对物理计算机的仿真</strong>，提供了一个可运行完整操作系统的软件平台</li>
<li>程序虚拟机典型的代码就是<strong>Java虚拟机</strong>，它<strong>专门执行单个计算机程序而设计</strong>，在Java虚拟机中执行的指令我们称为Java字节码指令</li>
</ul>
</li>
<li><p>无论系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中</p>
</li>
</ul>
<p><strong>Java虚拟机</strong></p>
<ul>
<li>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成</li>
<li>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器</li>
<li><strong>Java技术的核心就是Java虚拟机</strong>（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部</li>
<li>作用<ul>
<li><strong>Java虚拟机就是二进制字节码的运行环境</strong>，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细的定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里</li>
</ul>
</li>
<li>特点<ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
</li>
</ul>
<p><strong>JVM的位置</strong></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622172747.png"  alt="JVM的位置"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622172933.png"  alt="JVM位置"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622173122.png"  alt="Google的Android系统结构"></p>
<h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h2><ul>
<li>HotSpot VM是目前市面上高性能虚拟机的代表作之一</li>
<li>它采用解释器与即时编译器并存的架构</li>
<li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步</li>
</ul>
<p>可以参考这个：<a href="https://www.processon.com/view/5ea7a1b9e401fd21c196eb17?fromnew=1" target="_blank" rel="noopener">https://www.processon.com/view/5ea7a1b9e401fd21c196eb17?fromnew=1</a></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622174536.png"  alt="JVM整体结构"></p>
<h2 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h2><p>Java编译器输入的指令流基本上是一种基于<strong>栈的指令集架构</strong>，另外一种指令集架构则是基于<strong>寄存器的指令集架构</strong>。</p>
<p>具体来说，两种架构的区别如下：</p>
<ul>
<li>基于栈式架构的特点<ul>
<li>设计和实现更简单，适用于资源受限的系统</li>
<li>避开了寄存器的分配难题：使用零地址指令方式分配</li>
<li>指令流中的指令大部分都是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器更容易实现</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
</li>
<li>基于寄存器架构的特点<ul>
<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机</li>
<li>指令集架构则完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令去完成一项操作</li>
<li>在大部分情况下，基于寄存器架构的指令往往都是以一地址指令、二地址指令和三地址指令为主，而基于栈式的指令集往往是以零地址指令为主</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/22 17:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：演示基于栈的计算流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackStruTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译class字节码文件的指令：</p>
<blockquote>
<p>javap -v StackStruTest.class</p>
</blockquote>
<p>反编译后的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Classfile &#x2F;D:&#x2F;workspace&#x2F;Github&#x2F;jvm_study&#x2F;out&#x2F;production&#x2F;jvm_study&#x2F;com&#x2F;github&#x2F;jvm&#x2F;StackStruTest.class</span><br><span class="line">  Last modified 2020-6-22; size 478 bytes</span><br><span class="line">  MD5 checksum 888fe6cb592e62f71306c7f159c77feb</span><br><span class="line">  Compiled from &quot;StackStruTest.java&quot;</span><br><span class="line">public class com.github.jvm.StackStruTest</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #3.#21         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Class              #22            &#x2F;&#x2F; com&#x2F;github&#x2F;jvm&#x2F;StackStruTest</span><br><span class="line">   #3 &#x3D; Class              #23            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">   #4 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">   #5 &#x3D; Utf8               ()V</span><br><span class="line">   #6 &#x3D; Utf8               Code</span><br><span class="line">   #7 &#x3D; Utf8               LineNumberTable</span><br><span class="line">   #8 &#x3D; Utf8               LocalVariableTable</span><br><span class="line">   #9 &#x3D; Utf8               this</span><br><span class="line">  #10 &#x3D; Utf8               Lcom&#x2F;github&#x2F;jvm&#x2F;StackStruTest;</span><br><span class="line">  #11 &#x3D; Utf8               main</span><br><span class="line">  #12 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #13 &#x3D; Utf8               args</span><br><span class="line">  #14 &#x3D; Utf8               [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #15 &#x3D; Utf8               i</span><br><span class="line">  #16 &#x3D; Utf8               I</span><br><span class="line">  #17 &#x3D; Utf8               j</span><br><span class="line">  #18 &#x3D; Utf8               k</span><br><span class="line">  #19 &#x3D; Utf8               SourceFile</span><br><span class="line">  #20 &#x3D; Utf8               StackStruTest.java</span><br><span class="line">  #21 &#x3D; NameAndType        #4:#5          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #22 &#x3D; Utf8               com&#x2F;github&#x2F;jvm&#x2F;StackStruTest</span><br><span class="line">  #23 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">&#123;</span><br><span class="line">  public com.github.jvm.StackStruTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom&#x2F;github&#x2F;jvm&#x2F;StackStruTest;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;4, args_size&#x3D;1</span><br><span class="line">         0: iconst_2 &#x2F;&#x2F;常量2入栈</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: iconst_3 &#x2F;&#x2F;常量3入栈</span><br><span class="line">         3: istore_2</span><br><span class="line">         4: iload_1</span><br><span class="line">         5: iload_2</span><br><span class="line">         6: iadd	&#x2F;&#x2F;常量2、3出栈，执行相加</span><br><span class="line">         7: istore_3</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 11: 2</span><br><span class="line">        line 12: 4</span><br><span class="line">        line 13: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">            2       7     1     i   I</span><br><span class="line">            4       5     2     j   I</span><br><span class="line">            8       1     3     k   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;StackStruTest.java&quot;</span><br></pre></td></tr></table></figure>

<p>而基于寄存器的计算流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,2 &#x2F;&#x2F;将eax寄存器的值设为2</span><br><span class="line">add eax,3 &#x2F;&#x2F;将eax计算器的值加3</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong></p>
<p>由于跨平台性的设计，Java的指令都是依据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。有点是跨平台，指令集小，编译器更容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确的来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p>
<p>栈：跨平台性、指令集小、指令多，执行性能比寄存器差</p>
<h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><p><strong>启动</strong></p>
<p>Java虚拟机的启动是通过引导类加载器（bootstap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的</p>
<p><strong>执行</strong></p>
<ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li>
<li>程序开始执行时他才运行，程序结束时他就停止</li>
<li><strong>执行一个所谓的Java程序的时候，真正在执行的是一个叫做Java虚拟机的进程</strong></li>
</ul>
<p><strong>退出</strong></p>
<p>有如下几种情况：</p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或者错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
<li>某线程调用Runtime类或者System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或者halt操作</li>
<li>除此之外，JNI（Java Native Interface）规范了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况</li>
</ul>
<p>还是上面的程序，我们睡眠30s，通过jps可以查看当前进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackStruTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">30</span> * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>D:\workspace\Github\jvm_study\out\production\jvm_study\com\github\jvm&gt;jps<br>11376<br>6016 Launcher<br>10840<br>1192 Jps<br>3612 StackStruTest</p>
</blockquote>
<p>30s之后：</p>
<blockquote>
<p>11376<br>6016 Launcher<br>14612 Jps<br>10840</p>
</blockquote>
<h2 id="JVM的发展历程"><a href="#JVM的发展历程" class="headerlink" title="JVM的发展历程"></a>JVM的发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul>
<li>早在1996年Java1.0版本的时候，Sun共发布了一款名为Sun Classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰</li>
<li>这款虚拟机内部只提供解释器</li>
<li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管迅疾执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li>
<li>现在HotSpot内置了此虚拟机</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622183444.png"  alt="解释器与JIT"></p>
<h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ul>
<li>为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机</li>
<li>Exact Memory Management：准确式内存管理<ul>
<li>也可以叫Non-Conservative/Accurate Memory Management</li>
<li>虚拟机可以知道内存中某个位置的数据具体是什么类型</li>
</ul>
</li>
<li>具备现代高性能虚拟机的雏形<ul>
<li>热点探测</li>
<li>编译器与解释器混合工作模式</li>
</ul>
</li>
<li>只在Solaris平台短暂使用，其他平台上还是Classic VM<ul>
<li>英雄气短，终被HotSpot虚拟机替换</li>
</ul>
</li>
</ul>
<h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><ul>
<li>Hots历史<ul>
<li>最初由一家名为“Longview Technologies”的小公司设计</li>
<li>1997年，此公司被Sun收购，2009年，Sun公司被甲骨文收购</li>
<li>JDK1.3时，HotSpot VM成为默认虚拟机</li>
</ul>
</li>
<li>目前<strong>HotSpot占有绝对的市场地位</strong>，称霸武林<ul>
<li>不管是现在仍然广泛使用的JDK6，还是使用比例较多的JDK8中，默认都是HotSpot</li>
<li>Sun/Oracle JDK和 Open JDK的默认虚拟机</li>
</ul>
</li>
<li>从服务器、桌面到移动端、嵌入式都有应用</li>
<li>名称中的HotSpot指的就是它的热点代码探测技术<ul>
<li>通过计数器找到最具编译价值的代码，触发即时编译或栈上替换</li>
<li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li>
</ul>
</li>
</ul>
<h3 id="JRockit-VM"><a href="#JRockit-VM" class="headerlink" title="JRockit VM"></a>JRockit VM</h3><ul>
<li><p><strong>专注于服务器端应用</strong></p>
<ul>
<li>它可以不太关注程序启动速度，隐藏JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行</li>
</ul>
</li>
<li><p>大量的行业基准测试显示，<strong>JRockit VM是世界上最快的JVM</strong></p>
<ul>
<li>使用JRockit产品，客户已经体验到了显著的性能提高</li>
</ul>
</li>
<li><p>优势：全面的Java运行时解决方案组合</p>
<ul>
<li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微妙级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li>
<li>MissionController服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具</li>
</ul>
</li>
<li><p>2008年，BEA被Oracle收购</p>
</li>
<li><p>Oracle表达了整合两大优势虚拟机工作，大致在JDK 8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性</p>
</li>
</ul>
<h3 id="J9-VM"><a href="#J9-VM" class="headerlink" title="J9 VM"></a>J9 VM</h3><ul>
<li>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</li>
<li>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多种用途VM</li>
<li>广泛用于IBM的各种Java产品</li>
<li>目前，<strong>最有影响力的三大商用虚拟机之一</strong>，也号称世界上最快的Java虚拟机（HotSpot、JRockit、J9）</li>
<li>2017年左右，IBM发布了开源J9 VM，命名为OpenJ9，交给Eclipse基金会管理，也成为Eclipse OpenJ9</li>
</ul>
<h3 id="KVM、CDC、CLDC"><a href="#KVM、CDC、CLDC" class="headerlink" title="KVM、CDC、CLDC"></a>KVM、CDC、CLDC</h3><ul>
<li><p>Oracle在Java ME产品线上的两款虚拟机为：CDD/CLDC HotSpot Implementation VM</p>
</li>
<li><p>KVM（Kilobyte）是CLDC-HI早起产品</p>
</li>
<li><p>目前移动领域地位尴尬，智能手机被Android和iOS二分天下</p>
</li>
<li><p>KVM简单、清凉、高度可移植，面向更低端的设备上还维持自己的一篇市场</p>
<ul>
<li>智能控制器、传感器</li>
<li>老人手机、经济欠发达地区的功能手机</li>
</ul>
</li>
<li><p>所有虚拟机原则：一次编译，到处运行</p>
</li>
</ul>
<h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><ul>
<li>Azul Vm和BEA Liquid VM是与<strong>特定硬件平台绑定、软硬件配合的专有虚拟机</strong><ul>
<li>高性能JAva虚拟机中的战斗机</li>
</ul>
</li>
<li>Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司专有的硬件Vega系统上的Java虚拟机</li>
<li><strong>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性</strong></li>
<li>2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性</li>
</ul>
<h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><ul>
<li>高性能JAva虚拟机中的战斗机</li>
<li>BEA公司开发的，直接运行在自家Hypervisor系统上</li>
<li>Liquid VM即是现在的JRockit VE（Virtual Edition），Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用的操作系统的必要功能，如线程调度、文件系统、网络支持等</li>
<li>随着JRockit虚拟机终止开发，Liquid VM项目也停止了</li>
</ul>
<h3 id="Apache-Harmony"><a href="#Apache-Harmony" class="headerlink" title="Apache Harmony"></a>Apache Harmony</h3><ul>
<li>Apache也曾经推出过JDK 1.5和JDK 1.6兼容的Java运行平台 Apache Harmony</li>
<li>它是IBM和Intel联合开发的开源JVM，受到同样开源的OpenJDK的压榨，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</li>
<li>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK</li>
</ul>
<h3 id="Microsoft-JVM"><a href="#Microsoft-JVM" class="headerlink" title="Microsoft JVM"></a>Microsoft JVM</h3><ul>
<li>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM</li>
<li>只能在Windows平台下运行，的确是当时Windows下性能最好的Java VM</li>
<li>1997年，Sun以侵权商标、不正当竞争罪名指控微软成功。微软在WindowsXP SP3中抹掉了其VM，现在Windows上安装的jdk都是HotSpot</li>
</ul>
<h3 id="TaobaoJVM"><a href="#TaobaoJVM" class="headerlink" title="TaobaoJVM"></a>TaobaoJVM</h3><ul>
<li>由AliJVM团队发布</li>
<li><strong>基于OpenJDK开发了自己的定制版AlibabaJDK</strong>，简称AJDK，是整个阿里Java体系的基石</li>
<li>基于OpenJDK HotSpot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机<ul>
<li><strong>创新的GCIH（GC invisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收率的目的</strong></li>
<li><strong>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</strong></li>
<li>使用crc32指令实现JVM intrinsic 降低JNI的调用开销</li>
<li>PMU hardware的Java profiling tool和诊断协助给你</li>
<li>针对大数据场景的ZenGC</li>
</ul>
</li>
<li>taobao vm应用在阿里产品上的性能搞，硬件依赖intel的cpu，损失了兼容性，但是提高了性能<ul>
<li>目前已经在淘宝、天猫上，把Oracle官方的JVM版本全部替换了</li>
</ul>
</li>
</ul>
<h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><ul>
<li>谷歌开发的，应用于Android系统，并在Android 2.2中提供了JIT，发展迅猛</li>
<li>Dalvik VM只能称作虚拟机，而不能称作“Java 虚拟机”，它没遵循Java 虚拟机规范</li>
<li>不能直接执行Java的Class文件</li>
<li>基于寄存器架构，而不是jvm的栈架构</li>
<li>执行的是编译后的dex（Dalvik Executable）文件，执行效率高<ul>
<li>它执行的dex（Dalvik Executable）文件可以通过Class文件转化而来，它使用Java语法编写应用程序，可以直接使用大部分的Java API等</li>
</ul>
</li>
<li>Android 5.0使用支持提前编译（Ahead Of Time Compilation，AOT）的ARM VM替换Dalvik VM</li>
</ul>
<h3 id="其他JVM"><a href="#其他JVM" class="headerlink" title="其他JVM"></a>其他JVM</h3><p> Java Card VM、Squawk VM、JavaInJava、Maxine VM、Jikes RVM、IKVM.NET、Jam VM、Cacao VM、Sable VM、Kaffe、Jelatine JVM、Nano VM、MRP、Moxie JVM</p>
<blockquote>
<p>具体JVM内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定的差异。后续将以Oracle HotSpot VM为默认虚拟机进行讲解。</p>
</blockquote>
<h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><ul>
<li><p>2018年4月，Oracle Labs公开了Graal VM，号称“<strong>Run Programs Faster Anywhere</strong>”，野心勃勃。与1995年的java的“write once，run anywhere”遥相呼应</p>
</li>
<li><p>Graal VM在HotSpot VM基础上增强而成的跨语言全栈迅疾，可以<strong>作为“任何语言”的运行平台使用</strong>。语言包括：Java、Scala、Groovy、Kotlin；C、C++、JavaScript、Ruby、Python、R等</p>
</li>
<li><p>支持不同语言的源代码或者源代码编译后的中间格式，通过解释器转换成能被Graal VM接受的中间表示。Graal VM提供了Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率</p>
</li>
<li><p><strong>如果说HotSpot有一天真的被取代，Graal VM希望最大</strong>，但是Java的软件生态没有丝毫变化。</p>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622203503.png"  alt="Graal VM"></p>
<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h2><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200623202157.jpg"  alt="JVM架构"></p>
<h2 id="类加载器与类的加载过程"><a href="#类加载器与类的加载过程" class="headerlink" title="类加载器与类的加载过程"></a>类加载器与类的加载过程</h2><p><strong>类加载子系统作用</strong></p>
<ul>
<li>类加载子系统赋值从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识</li>
<li>ClassLoader只负责class文件的加载，至于它能否可以运行，则有Execution Engine决定</li>
<li>加载的类信息存放于一块称为<strong>方法区</strong>的内存空间。除了类的信息外，方法区还有存放<strong>运行时常量池</strong>信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li>
</ul>
<p>运行时常量池在Class字节码中的体现，通过反编译class文件：javap -v StackStruTest.class得到如下内容：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200623203204.png"  alt="反编译StackStruTest.class"></p>
<p><strong>类加载器ClassLoder角色</strong></p>
<ul>
<li>class file存在于本地硬盘或者网络上的文件，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是需要加载到JVM当中来，根据这个文件实例化n个一模一样的实例</li>
<li>class file加载到JVM中，被称为DNA元数据模板，放在方法区</li>
<li>在.class文件—&gt;JVM—&gt;最终成为元数据模板，此过程就要一个运输工具（类装在器Class Loder），扮演一个快递员的角色</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200623203704.png"  alt="Class Loader角色"></p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><ul>
<li>加载（Loading）</li>
<li>链接（Linking）<ul>
<li>验证（Verification）</li>
<li>准备（Preparetion）</li>
<li>解析（Resolution）</li>
</ul>
</li>
<li>初始化（Initialization）</li>
</ul>
<h4 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h4><ol>
<li>通过类的全限定名获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>补充：加载.class文件的方式</p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络获取，典型场景：Web Applet</li>
<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>
<li>运行时计算生成，使用最多的是：动态代理技术</li>
<li>由其他文件生成，典型场景：JSP应用</li>
<li>从专有的数据库中提取.class文件，比较少见</li>
<li>从加密文件中获取，典型的防止Class文件被反编译的保护措施</li>
</ul>
<h4 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a>链接（Linking）</h4><ul>
<li>验证（Verification）<ul>
<li>目的在于确保Class文件的字节流包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li>
<li>主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证，比如使用工具Binary Viewer查看class文件，会发现有<code>CAFEBABE</code>开头</li>
</ul>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200623211624.png"  alt="cafe babe"></p>
<ul>
<li>准备（Preparetion）<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值，<strong>类变量分配位置是在方法区中</strong></li>
<li>这里<strong>不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化</strong></li>
<li>这里不会为实例变量分配初始值，类变量会分配在方法区中，而<strong>实例变量是会随着对象一起分配到Java堆</strong>中</li>
</ul>
</li>
<li>解析（Resolution）<ul>
<li><strong>将常量池内的符号引用转换成为直接引用的过程</strong></li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化操作之后再执行</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个艰巨定位到目标的句柄</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodred_info等</li>
</ul>
</li>
</ul>
<h4 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h4><ul>
<li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li>
<li>此方法不需要定义，是javac编译器自动收集<strong>类中的所有类变量的赋值动作和静态代码块中的语句合并而来</strong></li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行</li>
<li><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li>
<li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行之前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li>
<li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li>
</ul>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>关于类变量初始化说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//Prepare：a = 0 ---&gt; Initialization : a = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类变量a在链接的准备阶段被初始化为0，到了第三个阶段初始化就被赋值为1了</p>
</blockquote>
<p>这一过程可以通过<code>jclasslib bytecode viewer</code>工具进行查看，在初始化阶段（Initialization）会执行类构造器方法<code>&lt;clinit&gt;()</code>会对变量a进行初始化：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624124116.png"  alt="Initialization阶段"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624124420.png"  alt="Initialization阶段"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624124916.png"  alt="Initialization阶段"></p>
<p>假如一个类中没有静态变量和静态方法块，则不会出现<code>&lt;clinit&gt;()</code>方法：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624125254.png"  alt="无类变量和静态方法块"></p>
<blockquote>
<p>注：任何一个类声明之后，内部至少存在一个类的构造器<code>&lt;init&gt;</code></p>
</blockquote>
<ul>
<li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行之前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624134444.png"  alt="加载子类前，先加载父类"></p>
<ul>
<li><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p>
<blockquote>
<p>就是一个类的字节码在加载进方法区（JDK8以后叫做元空间），也就是说虚拟机执行类加载过程中，只会调用一次<code>&lt;clinit&gt;()</code>方法，保证这个类只被初始化一次。</p>
</blockquote>
<p>代码演示：两个线程同时初始化一个类</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始"</span>);</span><br><span class="line">            DeadThread dead = <span class="keyword">new</span> DeadThread();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r, <span class="string">"线程1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r, <span class="string">"线程2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"初始化当前类"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>线程1开始<br>线程2开始<br>线程1初始化当前类</p>
</blockquote>
<p>或者：</p>
<blockquote>
<p>线程2开始<br>线程1开始<br>线程2初始化当前类</p>
</blockquote>
<p>然后程序没有停止，得出结论多线程情况下，初始一个类，<code>&lt;clinit&gt;()</code>只会被调用一次。</p>
<h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><ul>
<li>JVM支持两种类型的类加载器，分别为<strong>引导类加载器（Bootstrap ClassLoader）</strong>和<strong>自定义加载器（User-Defined ClassLoader）</strong></li>
<li>从概念上来讲，自定义加载器一般指的是程序中由开发人员自定义的一类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></li>
<li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624142154.png"  alt="类加载器分类"></p>
<blockquote>
<p>注：这里的四者之间的关系是包含关系，不是上层下层，也不是子父类继承关系</p>
</blockquote>
<p><strong>关于ClassLoader这个类</strong></p>
<p>java.lang.ClassLoader是一个抽象类</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624142654.png"  alt="ClassLoader类的继承关系"></p>
<h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul>
<li>这个类加载器使用C/C++语言实现的，嵌套在JVM内部</li>
<li>它用来加载Java的核心库（Java_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>
<li>并不继承java.lang.ClassLoader，没有父加载器</li>
<li>加载扩展类和应用程序类加载器，并指定他们的父类加载器</li>
</ul>
<h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ul>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统熟悉所指定的目录中加载类库，或从JDK的安装目录jre/lib/ext子目录下加载类库。如果用户创建的jar放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
<h4 id="应用程序类加载器（AppClassLoader）"><a href="#应用程序类加载器（AppClassLoader）" class="headerlink" title="应用程序类加载器（AppClassLoader）"></a>应用程序类加载器（AppClassLoader）</h4><ul>
<li>Java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统熟悉java.class.path指定路径下的类库</li>
<li>该类加载是程序中默认的类加载器，一般来说，Java语言的类都是由它来完成加载</li>
<li>通过ClassLoader#getSystemClassLoader()方法可以获取该类加载器</li>
</ul>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><ul>
<li>在Java的日常语言程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式</li>
<li>为什么要自定义类加载器？<ul>
<li>隔离加载类</li>
<li>修改类的加载方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ul>
</li>
<li>用户自定义类加载器实现步骤<ol>
<li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在JDK1.2之前，在自定义类加载器时，总会继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载器，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass方法中</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器更加简洁</li>
</ol>
</li>
</ul>
<h2 id="ClassLoader的使用说明"><a href="#ClassLoader的使用说明" class="headerlink" title="ClassLoader的使用说明"></a>ClassLoader的使用说明</h2><h3 id="虚拟机自带类加载器演示"><a href="#虚拟机自带类加载器演示" class="headerlink" title="虚拟机自带类加载器演示"></a>虚拟机自带类加载器演示</h3><p>关于ClassLoder的使用我们用一个程序来演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">        ClassLoader extensionClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extensionClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：获取不到引导类加载器</span></span><br><span class="line">        ClassLoader bootStrapClassLoader = extensionClassLoader.getParent();</span><br><span class="line">        System.out.println(bootStrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        ClassLoader userClassLoader = ClassLoaderTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(userClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        ClassLoader stringClassLoader = String<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(stringClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"************启动类加载器能够加载的api路径************"</span>);</span><br><span class="line">        <span class="comment">//获取Bootstrap ClassLoader能够加载的api路径</span></span><br><span class="line">        URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL url : urLs) &#123;</span><br><span class="line">            System.out.println(url.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// /jre/lib/rt.jar下面有一个类叫做AccessController，我们来验证一下他的类加载器是什么</span></span><br><span class="line">        ClassLoader acClassLoader = AccessController<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(<span class="string">"AccessController的类加载器为："</span> + acClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"************拓展类加载器能够加载的api路径************"</span>);</span><br><span class="line">        String extDirs = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">        System.out.println(extDirs);<span class="comment">//D:\develop\Java\jdk1.8.0_131\jre\lib\ext; C:\WINDOWS\Sun\Java\lib\ext</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// jre\lib\ext 目录下有一个sunec.jar文件，里面有一个类叫CurveDB，我们来验证一下这个类的加载器是什么</span></span><br><span class="line">        ClassLoader curveDBclassLoader = CurveDB<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(curveDBclassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">null</span><br><span class="line">************启动类加载器能够加载的api路径************</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;resources.jar</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;rt.jar</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;sunrsasign.jar</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;jsse.jar</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;jce.jar</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;charsets.jar</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;jfr.jar</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;classes</span><br><span class="line">AccessController的类加载器为：null</span><br><span class="line">************拓展类加载器能够加载的api路径************</span><br><span class="line">D:\develop\Java\jdk1.8.0_131\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1540e19d</span><br></pre></td></tr></table></figure>



<blockquote>
<p>sun.misc.Launcher它是一个java虚拟机的入口程序</p>
</blockquote>
<p>可以发现：</p>
<ul>
<li>Java的核心类库都是使用<strong>引导类加载器(BootStrap ClassLoader)</strong>进行加载的</li>
<li>对于用户自定义类来说，默认使用<strong>系统类加载器(App ClassLoader)</strong>进行加载</li>
</ul>
<h3 id="用户自定义加载类演示"><a href="#用户自定义加载类演示" class="headerlink" title="用户自定义加载类演示"></a>用户自定义加载类演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义用户类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassFromCustomPath(String name) &#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">"One"</span>, <span class="keyword">true</span>, customClassLoader);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取ClassLoader的几种途径"><a href="#获取ClassLoader的几种途径" class="headerlink" title="获取ClassLoader的几种途径"></a>获取ClassLoader的几种途径</h3><ul>
<li>方式一：获取当前类的ClassLoader<ul>
<li>clazz.getClassLoader()</li>
</ul>
</li>
<li>方式二：获取当前线程上线文的ClassLoader<ul>
<li>Thread.currentThread().getContextClassLoader()</li>
</ul>
</li>
<li>方式三：获取系统的ClassLoader<ul>
<li>ClassLoader.getSystemClassLoader</li>
</ul>
</li>
<li>方式四：获取调用者的ClassLoader<ul>
<li>DriverManager.getClasserLoader()</li>
</ul>
</li>
</ul>
<p>演示前三种获取方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1：获取当前类的ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = GetClassLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        ClassLoader stringClassLoader = Class.forName(<span class="string">"java.lang.String"</span>).getClassLoader();</span><br><span class="line">        System.out.println(stringClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2：获取当前线程上线文的ClassLoader</span></span><br><span class="line">        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(contextClassLoader);</span><br><span class="line">        <span class="comment">//3：获取系统的ClassLoader</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<blockquote>
<p>sun.misc.Launcher$AppClassLoader@18b4aac2<br>null<br>sun.misc.Launcher$AppClassLoader@18b4aac2<br>sun.misc.Launcher$AppClassLoader@18b4aac2</p>
</blockquote>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而加载某个类的class文件时，Java虚拟机是采用的<strong>双亲委派模式</strong>，即把请求交由父类处理，他是一种任务委派模式。</p>
<p>演示：自定义一个类java.lang.String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"我是自定义的String类中的静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//尝试加载自己写的String类，看静态代码块是否执行</span></span><br><span class="line">        String s = <span class="keyword">new</span> java.lang.String();</span><br><span class="line">        System.out.println(<span class="string">"测试自定义String类是否执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<blockquote>
<p>测试自定义String类是否执行</p>
</blockquote>
<p>可以发现自定义的String类中的静态代码块并没有被执行。</p>
<h3 id="双亲委派工作原理"><a href="#双亲委派工作原理" class="headerlink" title="双亲委派工作原理"></a>双亲委派工作原理</h3><ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己去加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终会到达顶层的启动类加载器</li>
<li>如果父类加载器可以完成类加载任务，就成功返回；倘若父类加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624160825.png"  alt="双亲委派机制"></p>
<p>思考：自定义的java.lang.String类是否能被正确加载和执行？</p>
<p>我们可以在此类中加入一个main方法进行测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"我是自定义的String类中的静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello String"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行报错：</p>
<blockquote>
<p>错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:<br>   public static void main(String[] args)<br>否则 JavaFX 应用程序类必须扩展javafx.application.Application</p>
</blockquote>
<p><strong>沙箱安全机制</strong></p>
<p>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p>
<h3 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h3><ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API随意篡改<ul>
<li>自定义类：java.lang.String</li>
<li>自定义类：java.lang.Hack</li>
</ul>
</li>
</ul>
<p>比如我自定义了一个java.lang.Hack的类，这个类因为是java.lang包下的按道理是应该会被启动类加载器进行加载的，经过测试我们发现程序不能执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"我是自定义的Hack类中的静态代码块,有可能包含这威胁JVM代码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HackTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//尝试加载自己写的Hack类，看静态代码块是否执行</span></span><br><span class="line">        Hack hack = <span class="keyword">new</span> Hack();</span><br><span class="line">        System.out.println(<span class="string">"测试自定义Hack类是否执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错信息：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624161529.png"  alt="报错信息"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="判断两个class对象是否为同一个类"><a href="#判断两个class对象是否为同一个类" class="headerlink" title="判断两个class对象是否为同一个类"></a>判断两个class对象是否为同一个类</h3><ul>
<li>在JVM中表示两个class对象是否为同一个类存在的两个必要条件<ul>
<li>类的全类名必须一致</li>
<li>加载这个类的ClassLoader（指ClassLoder实例对象）必须相同</li>
</ul>
</li>
<li>换句话说，在JVM中，即使两个类对象来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</li>
</ul>
<h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><p>JVM必须知道一个类是由启动加载器加载还是由用户类加载器加载的。如果一个类是由用户加载类加载的，那么JVM会<strong>将这个类加载器的一个引用作为类信息的一部分保存在方法区中（JDK8之后称为元数据区）</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
<h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为：主动使用和被动使用</p>
<ul>
<li>主动使用：分为7种情况<ul>
<li>创建类的实例</li>
<li>访问摸个类或者接口的静态变量</li>
<li>调用类的静态方法</li>
<li>反射(如：Class.forName)</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK 7开始提供动态语言支持：java.lang.invoke.MethodHandler实习的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化则初始化</li>
</ul>
</li>
<li>除了以上7种情况，其他使用Java类的方式都被看作是<strong>对类的被动使用，都不会导致类的初始化</strong></li>
</ul>
<h1 id="运行时数据区（Runtime-Data-Area）"><a href="#运行时数据区（Runtime-Data-Area）" class="headerlink" title="运行时数据区（Runtime Data Area）"></a>运行时数据区（Runtime Data Area）</h1><p>回顾一下JVM的架构图：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200623202157.jpg"  alt="JVM架构"></p>
<p>上一章节讲完了类加载子系统(Class Loader SubSystem)，回顾一下，简单的流程步骤：</p>
<ul>
<li>加载</li>
<li>链接<ul>
<li>准备</li>
<li>校验</li>
<li>解析</li>
</ul>
</li>
<li>初始化</li>
</ul>
<p>接下来讲一下运行时数据区(Runtime Data Areas)的引入：</p>
<blockquote>
<p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高些稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着差异</strong>，结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>
</blockquote>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624164723.png"  alt="运行时数据区"></p>
<p>详细图：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624164825.png"  alt="经典的JVM内存模型"></p>
<p>总结一下运行时数据区的划分如下：</p>
<ul>
<li>运行时数据区(Runtime Data Areas)<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>堆</li>
<li>方法区（JDK8之后为元数据区）</li>
<li>本地方法栈</li>
</ul>
</li>
</ul>
<p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁，具体而言：</p>
<ul>
<li>线程私有部分：各自包含程序计数器、栈、本地栈</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
<p><strong>JVM中的线程说明：</strong></p>
<ul>
<li>线程是一个程序里的运行单元。JVM运行一个应用有多个线程并行的执行</li>
<li>在HotSpot JVM里，每个线程都与操作系统的本地线程直接映射<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止之后，本地线程也会被回收</li>
</ul>
</li>
<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上，一旦本地线程初始化成功，它就会调用Java线程中的run方法</li>
</ul>
<p><strong>JVM系统线程</strong></p>
<ul>
<li>虚拟机线程</li>
<li>周期任务线程</li>
<li>GC线程</li>
<li>编译线程</li>
<li>信号调度线程</li>
</ul>
<h2 id="程序计数器-PC-Register"><a href="#程序计数器-PC-Register" class="headerlink" title="程序计数器(PC Register)"></a>程序计数器(PC Register)</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎取下一条指令。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li>
<li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，声明周期与线程的生命周期保持一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者。如果是在执行native方法，则是未指定值(undefined)</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>
<li>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况区域</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200628160252.png"  alt="PC寄存器"></p>
<p>演示PC寄存器的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line"></span><br><span class="line">        String s = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200628161515.png"  alt="PCRegisterTest"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200628161554.png"  alt="PC寄存器工作原理图"></p>
<h3 id="关于PC寄存器的两个常见问题"><a href="#关于PC寄存器的两个常见问题" class="headerlink" title="关于PC寄存器的两个常见问题"></a>关于PC寄存器的两个常见问题</h3><ul>
<li><p>使用PC寄存器存储字节码指令地址有什么用呢？</p>
<p>这道题目的变形是：为什么使用PC寄存器记录当前线程的执行地址呢？</p>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
</li>
<li><p>PC寄存器为什么会被设定为线程私有？</p>
<p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常的中断或恢复，如何保证分毫无差呢？为了准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在线程之间互不影响。</p>
</li>
</ul>
<h3 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h3><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，成为它的时间片。</p>
<p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>
<p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>
<h2 id="虚拟机栈-Java-Virtual-Machine-Stack"><a href="#虚拟机栈-Java-Virtual-Machine-Stack" class="headerlink" title="虚拟机栈(Java Virtual Machine Stack)"></a>虚拟机栈(Java Virtual Machine Stack)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>虚拟机栈出现的背景</strong></p>
<blockquote>
<p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台的CPU架构不同，所以不能设计为基于寄存器的。</p>
<p>基于栈的设计，优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
</blockquote>
<p><strong>内存中的栈和堆</strong></p>
<p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；–》栈管运行</p>
<p>堆是解决数据存储问题，即数据怎么放、放在哪儿。–》堆管存储</p>
<p><strong>虚拟机栈基本内容</strong></p>
<ul>
<li><p>Java虚拟机栈是什么？</p>
<p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧（Stack Frame），对应着一次次的Java方法调用，是线程私有的</p>
</li>
<li><p>生命周期</p>
<p>生命周期和线程一致</p>
</li>
<li><p>作用</p>
<p>主管Java程序的运行，它保存方法的<strong>局部变量</strong>（8中基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回</p>
</li>
<li><p>栈的特点（优点）</p>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li>JVM直接对Java栈的操作只有两个<ul>
<li>每个方法执行，伴随着进栈（入栈、压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
</li>
<li>对于栈来说不存在垃圾回收问题（GC）</li>
<li>回顾：<ul>
<li>pc寄存器：不存在gc和oom</li>
<li>虚拟机栈：存在oom，不存在gc</li>
</ul>
</li>
</ul>
</li>
<li><p>栈中可能存在的异常</p>
<ul>
<li>Java虚拟机规范允许Java栈的大小是<strong>动态的或者固定的</strong><ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机栈将会抛出一个<strong>StackOverflowError</strong>异常</li>
</ul>
</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机会抛出一个<strong>OutOfMemomoryError</strong>异常</li>
</ul>
</li>
<li><p>如何设置栈内存大小</p>
<ul>
<li>通过参数 <code>-Xss</code> 来进行设置，比如-Xss256k表示分配了256k的栈内存大小，栈的大小直接决定了函数调用的最大可达深度</li>
</ul>
</li>
</ul>
<p>这里我们通过配置来演示一下StackOverflowError的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);<span class="comment">//Exception in thread "main" java.lang.StackOverflowError</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在默认情况下，我们看到在控制台输出异常前最后一次count输出为11408，我们通过参数设置限制栈内存大小为256k，然后重新运行得到count最大为2457</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630154401.png"  alt="-Xss配置栈大小"></p>
<h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><p><strong>栈中存储什么</strong>？</p>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧(Stack Fragme)</strong>的格式存在</li>
<li>在这个线程上正在执行的每个方法都各自对应一个栈帧</li>
<li>栈帧是一块内存区域，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
<p><strong>栈运行原理</strong></p>
<ul>
<li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循“<strong>先进后出</strong>”的原则</li>
<li>在一条活动线程中，一个时间点上，只有有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类</li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧就会被创建出来，放在栈的顶端，成为新的当前帧</li>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
<li>Java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return指令</strong>；另外一种是<strong>抛出异常</strong>。不管使用哪种方式，都会导致栈帧被弹出</li>
</ul>
<p><strong>栈的内存结构</strong></p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）（或表达式栈）</li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630160503.png"  alt="栈帧结构"></p>
<h3 id="栈帧-局部变量表（local-variables）"><a href="#栈帧-局部变量表（local-variables）" class="headerlink" title="栈帧-局部变量表（local variables）"></a>栈帧-局部变量表（local variables）</h3><ul>
<li>局部变量表也被称为局部变量数组或者本地变量表</li>
<li>定义为一个数字数组，主要用于存储<strong>方法参数和定义在方法内部的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用，以及returnAddress类型</li>
<li>由于局部变量表是建立在线程上，是线程私有数据，因此<strong>不存在数据安全问题</strong></li>
<li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性maximum local variables数据项中。在方法运行期间是不会改变局部变量表大小的</li>
</ul>
<p>通过代码我们来看局部变量表的具体表示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariablesTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test1...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>javap -v LocalVariablesTest.class</code> 命令进行反编译</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630162117.png"  alt="反编译LocalVariablesTest"></p>
<p>可以发现通过反编译得到main方法的局部变量表数量为3，分别是参数args、局部变量test和num。</p>
<p>通过jclasslib也可以看到main方法的局部变量表数量：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630162428.png"  alt="jclasslib"></p>
<ul>
<li><strong>方法嵌套调用的次数由栈的大小决定。</strong>一般来说，栈越大，方法嵌套调用次数越多。对于一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用会占用更多的栈空间，导致其嵌套次数会减少</li>
<li><strong>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数列表的过程。</strong>当方法调用结束之后，随着方法栈帧的销毁，局部变量表也会随之销毁</li>
</ul>
<h4 id="变量槽Slot"><a href="#变量槽Slot" class="headerlink" title="变量槽Slot"></a>变量槽Slot</h4><ul>
<li><p>参数值存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</p>
</li>
<li><p>局部变了表，最基本的存储单元是slot（变量槽）</p>
</li>
<li><p>局部变量表中存放编译器可知的各种基本数据类型（8种），引用类型，returnAddress类型的变量</p>
</li>
<li><p>在局部变量表里，32位以内的类型只占一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot</p>
<ul>
<li>byte、short、char在存储前被专为int，boolean也被转成int，0表示false，非0表示true</li>
<li>long和double则占据两个slot</li>
</ul>
</li>
<li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
</li>
<li><p>当一个实例方法被调用的时候，它的方法参数和方法内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上</p>
</li>
<li><p>如果需要访问局部变量表中一个64bit的局部变量时，只需要使用前一个索引即可，比如long和double的访问（图中就分别使用索引1和4即可）</p>
</li>
<li><p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用的this将会存放在index为0的slot处，其余的按顺序继续排列</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630170329.png"  alt="Slot变量槽"></p>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630171159.png"  alt="Slot变量槽"></p>
<p><strong>变量槽Slot的重复利用</strong></p>
<blockquote>
<p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后声明的局部变量就很有可能会重复过期局部变量的槽位，从而达到节省资源的目的。</p>
</blockquote>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630172128.png"  alt="变量槽Slot复用"></p>
<p>下图可以发现变量b和变量c的index索引都为2</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630172257.png"  alt="变量槽Slot复用"></p>
<h4 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h4><ul>
<li><p>参数表分配完毕之后，再根据方法内定义的变量的顺序和作用域分配</p>
</li>
<li><p>类变量表有两次初始化的机会，第一次是在“<strong>准备阶段</strong>”，执行系统初始化，对类变量设置零值，另一次则是在“<strong>初始化</strong>”阶段，赋予程序员在代码中定义的初始值</p>
</li>
<li><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用</p>
</li>
<li><p>补充</p>
<ul>
<li>在栈帧中，与性能调优关系最为米钱的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li>
</ul>
</li>
</ul>
<p>回顾变量的分类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">变量的分类：按照数据类型分：① 基本数据类型  ② 引用数据类型</span><br><span class="line">          按照在类中声明的位置分：</span><br><span class="line">          ① 成员变量：在使用前，都经历过默认初始化赋值</span><br><span class="line">                    类变量： linking的prepare阶段：给类变量默认赋值  ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><br><span class="line">                    实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><br><span class="line">          ② 局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过</span><br></pre></td></tr></table></figure>



<h3 id="栈帧-操作数栈-Operand-Stack"><a href="#栈帧-操作数栈-Operand-Stack" class="headerlink" title="栈帧-操作数栈(Operand Stack)"></a>栈帧-操作数栈(Operand Stack)</h3><p>JVM中是操作树栈就是用数组实现的</p>
<h4 id="操作数栈说明"><a href="#操作数栈说明" class="headerlink" title="操作数栈说明"></a>操作数栈说明</h4><ul>
<li>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以称之为栈</li>
<li><strong>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop)</strong><ul>
<li>某些字节码指令将值压入操作数栈，其余字节码指令将操作数取出栈，使用它们后再把结果压入栈</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701172114.png"  alt="操作数栈"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701172332.png"  alt="代码举例"></p>
<ul>
<li><strong>如果被调用的方法有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令</li>
<li>操作数栈中元素的数据类型必须与自己吗指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类验证夹断的数据流分析阶段再次验证</li>
<li>另外，我们说<strong>Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong></li>
<li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间</strong></li>
<li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</li>
<li>每个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值</li>
<li>栈中的任何一个元素都可以是任意Java数据类型<ul>
<li>32bit的类型占用一个栈单位的深度</li>
<li>64bit的类型占用两个栈单位的深度</li>
</ul>
</li>
<li>操作数栈<strong>并非采用访问索引的方式来进行数据访问的</strong>，而是只能通过标准的入栈和出栈操作来完成一次数据的访问</li>
</ul>
<h4 id="操作数栈的字节码指令执行分析"><a href="#操作数栈的字节码指令执行分析" class="headerlink" title="操作数栈的字节码指令执行分析"></a>操作数栈的字节码指令执行分析</h4><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701175557.png"  alt="追踪操作数栈字节码指令"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">        <span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>bipush ：表示往操作数栈中压入数据</p>
<p>istore_1：表示将操作数栈中数据<strong>转存</strong>到局部变量表中</p>
<p> iload_1：将局部变量表中的数据<strong>读入</strong>到操作数栈中，此时局部变量表中依旧有该值</p>
</blockquote>
<p>下面放一张代码追踪的图</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701182405.png"  alt="操作数栈的字节码指令追踪"></p>
<p>面试题：i++和++i的区别，放到字节码篇章时结束，这里先简单看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">        <span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = m + n;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span></span><br><span class="line">        <span class="keyword">int</span> i = getSum();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    程序员面试过程中， 常见的i++和++i 的区别，放到字节码篇章时再介绍。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第1类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">10</span>;</span><br><span class="line">        i1++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">10</span>;</span><br><span class="line">        ++i2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第2类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i4 = i3++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i5 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i6 = ++i5;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第3类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i7 = <span class="number">10</span>;</span><br><span class="line">        i7 = i7++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i8 = <span class="number">10</span>;</span><br><span class="line">        i8 = ++i8;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第4类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i9 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i10 = i9++ + ++i9;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法add对应的字节码指令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> 0 bipush 10</span><br><span class="line"> 2 istore_1</span><br><span class="line"> 3 iinc 1 by 1</span><br><span class="line"> 6 bipush 10</span><br><span class="line"> 8 istore_2</span><br><span class="line"> 9 iinc 2 by 1</span><br><span class="line">12 bipush 10</span><br><span class="line">14 istore_3</span><br><span class="line">15 iload_3</span><br><span class="line">16 iinc 3 by 1</span><br><span class="line">19 istore 4</span><br><span class="line">21 bipush 10</span><br><span class="line">23 istore 5</span><br><span class="line">25 iinc 5 by 1</span><br><span class="line">28 iload 5</span><br><span class="line">30 istore 6</span><br><span class="line">32 bipush 10</span><br><span class="line">34 istore 7</span><br><span class="line">36 iload 7</span><br><span class="line">38 iinc 7 by 1</span><br><span class="line">41 istore 7</span><br><span class="line">43 bipush 10</span><br><span class="line">45 istore 8</span><br><span class="line">47 iinc 8 by 1</span><br><span class="line">50 iload 8</span><br><span class="line">52 istore 8</span><br><span class="line">54 bipush 10</span><br><span class="line">56 istore 9</span><br><span class="line">58 iload 9</span><br><span class="line">60 iinc 9 by 1</span><br><span class="line">63 iinc 9 by 1</span><br><span class="line">66 iload 9</span><br><span class="line">68 iadd</span><br><span class="line">69 istore 10</span><br><span class="line">71 return</span><br></pre></td></tr></table></figure>



<h4 id="栈顶缓存（Top-Of-Stack-Cashing）技术"><a href="#栈顶缓存（Top-Of-Stack-Cashing）技术" class="headerlink" title="栈顶缓存（Top-Of-Stack Cashing）技术"></a>栈顶缓存（Top-Of-Stack Cashing）技术</h4><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数</p>
<p>由于操作数是查重在内存中的，隐藏频繁地执行内存读写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos,Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率</strong></p>
<h3 id="栈帧-动态链接-Dynamic-Linking"><a href="#栈帧-动态链接-Dynamic-Linking" class="headerlink" title="栈帧-动态链接(Dynamic Linking)"></a>栈帧-动态链接(Dynamic Linking)</h3><ul>
<li>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态链接（Dynamic Linking）</strong>，比如invokedynamic指令</li>
<li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicLinkingTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"methodA()...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"methodB()...."</span>);</span><br><span class="line">        methodA();</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701192501.png"  alt="动态链接"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701192542.png"  alt="动态链接"></p>
<p>指向运行时常量池的方法引用我们称为动态链接。</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701192635.png"  alt="动态链接"></p>
<p>为什么需要常量池呢？</p>
<blockquote>
<p>常量池的作用，就是为了提供一些符号和常量，便于指令的识别</p>
</blockquote>
<h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><p>在JVM中，将符号引用转换成为调用方法的直接引用与方法的绑定机制相关。</p>
<ul>
<li>静态链接<ul>
<li>当一个字节码文件被装载进JVM内部时，如果被<strong>调用的目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称为静态链接</li>
</ul>
</li>
<li>动态链接<ul>
<li>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此称为动态链接</li>
</ul>
</li>
</ul>
<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<ul>
<li>早期绑定<ul>
<li>早期绑定就是指被调用的目<strong>标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用</li>
</ul>
</li>
<li>晚期绑定<ul>
<li>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称为晚期绑定</li>
</ul>
</li>
</ul>
<p>演示早期绑定和晚期绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"动物进食"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗吃骨头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"捕食耗子，多管闲事"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eat();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"捕食耗子，天经地义"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAnimal</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHunt</span><span class="params">(Huntable h)</span> </span>&#123;</span><br><span class="line">        h.hunt();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701194425.png"  alt="动态绑定"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701194456.png"  alt="静态绑定"></p>
<p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显示定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p>
<p><strong>虚方法与非虚方法</strong></p>
<ul>
<li>非虚方法<ul>
<li>如果方法在编译期就能确定了具体的调用版本，这个版本在运行时不可变的，这样的方法称为非虚方法</li>
<li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</li>
<li>其他放称为虚方法</li>
</ul>
</li>
</ul>
<p>虚拟机提供了以下几条方法调用指令：</p>
<ul>
<li>普通调用指令<ol>
<li><strong>invokestatic：调用静态方法，解析阶段确定唯一方法版本</strong></li>
<li><strong>invokespecial：调用<init>方法、私有方法以及父类放，解析阶段确定唯一方法版本</strong></li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ol>
</li>
<li>动态调用指令<ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法</p>
<p><strong>关于invokedynamic指令</strong></p>
<ul>
<li>JVM字节码指令集一直比较稳定，一直到Java7中财增加了invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进</li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具类生成invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方法</li>
<li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规范的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器</li>
</ul>
<p><strong>动态语言类型和静态语言类型</strong></p>
<p>​    两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之就是动态类型语言。</p>
<p>​    <strong>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</strong>，这是动态语言的一个重要特性</p>
<p><strong>方法重写的本质</strong></p>
<p>​    Java语言中方法重写的本质：</p>
<pre><code>1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C
 2. 如果在类型C中找到与常量中的描述符合简单名称都符合的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常
 3. 否则按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程
 4. 如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError异常</code></pre><p>IllegalAccessError介绍：</p>
<p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明了一个类发生了不兼容的改变</p>
<p><strong>虚方法表</strong></p>
<ul>
<li>在面向对象的编程中，会很频繁的使用到动态分配，如果每次动态分配的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（Virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来替代查找</li>
<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</li>
<li>那么虚方法表什么时候被创建呢？<ul>
<li>虚方法表会在类加载的<strong>链接阶段</strong>创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕</li>
</ul>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701201830.png"  alt="类的链接过程"></p>
<blockquote>
<p>后续再补充虚方法表相关知识</p>
</blockquote>
<h3 id="栈帧-返回地址-return-address"><a href="#栈帧-返回地址-return-address" class="headerlink" title="栈帧-返回地址(return address)"></a>栈帧-返回地址(return address)</h3><ul>
<li>存放调用该方法的pc寄存器的值</li>
<li>一个方法的结束有两种方式<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论通过哪一种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧一般不会保存这些信息</li>
</ul>
<p>​    本质上，方法的返回就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p>​    <strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p>
<p><strong>正常完成出口</strong></p>
<p>​    在字节码指令中，返回指令包含ireturn(当返回值手机boolean、byte、char、short和int类型时使用)、lreturn、freturn、dreturn以及areturn，另外还有一个return指令提供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</p>
<p><strong>异常完成出口</strong></p>
<p>​    在方法执行过程中遇到了异常，并且这个异常没有在方法内部进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p>
<p>​    方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在放生 异常的时候找到处理异常的代码。</p>
<h3 id="栈帧-一些附加信息"><a href="#栈帧-一些附加信息" class="headerlink" title="栈帧-一些附加信息"></a>栈帧-一些附加信息</h3><blockquote>
<p>栈帧中还运行携带与Java虚拟机实现相关的一些附加信息，例如，对程序调试提供支持的信息。</p>
</blockquote>
<h3 id="关于栈的一些面试题"><a href="#关于栈的一些面试题" class="headerlink" title="关于栈的一些面试题"></a>关于栈的一些面试题</h3><ul>
<li>举例栈溢出的情况（StackOverflowError）</li>
<li>通过-Xss设置栈的大小；OOM</li>
<li>调整栈大小，就能保住不出现溢出吗？不能</li>
<li>分配的栈内存越大越好吗？不是</li>
<li>垃圾回收是否涉及到虚拟机栈？不会</li>
<li>方法中定义的局部变量是否是线程安全？具体问题具体分析</li>
</ul>
<p>何为线程安全？</p>
<ul>
<li>如果只有一个线程才可以操作此数据，则必是线程安全的</li>
<li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder本身是线程不安全</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(StringBuilder sBuilder)</span></span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        sBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">"a"</span>);</span><br><span class="line">            s.append(<span class="string">"b"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        method2(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="本地方法接口-不属于运行时数据区"><a href="#本地方法接口-不属于运行时数据区" class="headerlink" title="本地方法接口(不属于运行时数据区)"></a>本地方法接口(不属于运行时数据区)</h2><p>本地方法接口本身是不属于运行时数据区的，但为了讲解本地方法栈，我们先讲解本地方法接口，先看下它在JVM中的位置。</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200702100946.png"  alt="本地方法接口"></p>
<h3 id="什么是本地方法接口"><a href="#什么是本地方法接口" class="headerlink" title="什么是本地方法接口"></a>什么是本地方法接口</h3><p>简单地讲，<strong>一个Native Method就是一个Java调用非Java代码的接囗</strong>。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如<br>c。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在c++中，你可以用extern “C” 告知c++编译器去调用一个c的函数。</p>
<p>“A native mehod is a Java method whose implementation is provided by non-java code.”</p>
<p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface)，因为其实现体是由非java语言在外面实现的。</p>
<p>本地接囗的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200702102055.png"  alt="Thread中的native方法"></p>
<p>注：java层面上的线程都会转化成操作系统的本地线程。</p>
<p>标识符native可以与其他所有java表示符连用，但是abstract除外：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IHaveNatives</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native4</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//abstract native void Native5(int[] ary) throws Exception;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="为什么要使用Native-Method"><a href="#为什么要使用Native-Method" class="headerlink" title="为什么要使用Native Method"></a>为什么要使用Native Method</h3><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<ul>
<li>与Java环境外交互<br><strong>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。</strong>你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li>
<li>与操作系统交互<br>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。<strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</strong>。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
<li>Sun’SJava<br><strong>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互</strong>。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java．lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用c实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Winn32 setPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library)提供，然后被JVM调用。</li>
</ul>
<h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印或者Java系统管理生产设备，在企业级应用中己经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>
<h2 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈(Native Method Stack)"></a>本地方法栈(Native Method Stack)</h2><p>本地方法栈的位置：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200702104125.png"  alt="本地方法栈的位置"></p>
<ul>
<li><p><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong></p>
</li>
<li><p>本地方法栈也是线程私有的</p>
</li>
<li><p>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面是相同的）</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li>
<li>如果本地方法栈可以<strong>动态拓展</strong>，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个 <strong>OutOfMemoryError</strong> 异常</li>
</ul>
</li>
<li><p>本地方法是使用C语言实现的</p>
</li>
<li><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库</p>
</li>
<li><p>当某个线程调用了一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有同样的权限</p>
<ul>
<li>本地方法可以通过本地方法接口<strong>来访问虚拟机内部的运行时数据区</strong></li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ul>
</li>
<li><p>并不是所有JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈</p>
</li>
<li><p>在HotSpot JVM中，直接将本地方法栈和虚拟机栈合二为一</p>
</li>
</ul>
<h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><p><strong>参考大纲</strong></p>
<p>堆核心概述</p>
<p>设置堆内存大小与OOM</p>
<p>年轻代与老年代</p>
<p>对象分配过程</p>
<p>Minor GC、Major GC、Full GC</p>
<p>堆空间分配思想</p>
<p>内存分配策略</p>
<p>为对象分配内存：TLAB</p>
<h3 id="堆核心概述"><a href="#堆核心概述" class="headerlink" title="堆核心概述"></a>堆核心概述</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200703175652.png"  alt="堆的位置"></p>
<ul>
<li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域</li>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就被确定了，它是JVM管理的最大一块内存空间<ul>
<li>堆内存的大小是可以调整的，栈的大小也是可以调整的，命令是 -Xss</li>
</ul>
</li>
<li>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的</li>
<li>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）</li>
<li>设置堆大小命令：-Xms -Xmx，如 -Xms10m -Xmx10m</li>
<li>调试工具：jvisualvm，插件安装参考：<a href="https://blog.csdn.net/qq_21299835/article/details/90649338" target="_blank" rel="noopener">https://blog.csdn.net/qq_21299835/article/details/90649338</a></li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms10m -Xmx10m</span></span><br><span class="line"><span class="comment"> * -Xms20m -Xmx20m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  16:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面程序，分别配置VM参数为<code>-Xms10m -Xmx10m</code>和<code>-Xms20m -Xmx20m</code>，通过工具jvisualvm来进行监测如下：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200703181712.png"  alt="-Xms10m -Xmx10m"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200703181825.png"  alt="-Xms20m -Xmx20m"></p>
<p><strong>堆的核心概述</strong></p>
<ul>
<li>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应该在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）<ul>
<li>我们要说的是：“几乎”所有的对象实例都在这里分配内存——从实际使用角度看的</li>
</ul>
</li>
<li>数组和对象永远不会存储在栈上，因为栈帧中保存引用，这个引用执行对象或者数组在堆中的位置</li>
<li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除</li>
<li>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//属性、成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleHeap</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"My ID is "</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHeap sl = <span class="keyword">new</span> SimpleHeap(<span class="number">1</span>);</span><br><span class="line">        SimpleHeap s2 = <span class="keyword">new</span> SimpleHeap(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        Object[] arr1 = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200703185051.png"  alt="SimpleHeap"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200703185126.png"  alt="对象分配"></p>
<h3 id="堆的细分内存结构（重点）"><a href="#堆的细分内存结构（重点）" class="headerlink" title="堆的细分内存结构（重点）"></a>堆的细分内存结构（重点）</h3><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706162345.png"  alt="堆：内存细分"></p>
<p>堆空间内部结构JDK7：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706162615.png"  alt="堆空间内部结构：JDK7"></p>
<p>堆空间内部结构JDK8：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706162750.png"  alt="堆空间内部结构JDK8"></p>
<p>通过命令来打印Simple的堆栈信息，分为JDK8和JDK7，依次看一下</p>
<blockquote>
<p>-Xms20m -Xmx20m -XX:+PrintGCDetails</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms20m -Xmx20m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//属性、成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleHeap</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"My ID is "</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHeap s1 = <span class="keyword">new</span> SimpleHeap(<span class="number">1</span>);</span><br><span class="line">        SimpleHeap s2 = <span class="keyword">new</span> SimpleHeap(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        Object[] arr1 = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">        System.out.println(s1.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8的日志输出：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706163425.png"  alt="PrintGCDetails"></p>
<p>换成1.7的运行环境：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706165112.png"  alt="PrintGCDetails"></p>
<h3 id="设置堆的大小"><a href="#设置堆的大小" class="headerlink" title="设置堆的大小"></a>设置堆的大小</h3><ul>
<li>Java堆区用于存储Java对象实例，那么堆的大小在启动时就己经设定好了，大家可以通过选项“-Xms“和“-Xmx“来进行设置：<ul>
<li>“-Xms“用于表示堆区的起始内存，等价于-XX:InitialHeapSize</li>
<li>“-Xmx“则用于表示堆区的最大内存，等价于-XX：MaxHeapSize</li>
</ul>
</li>
<li>一旦堆区中的内存大小超过“-Xmx“所指定的最大内存时，将会抛出OutOfMemoryError异常</li>
<li>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong></li>
<li>默认情况下，初始内存大小：物理电脑内存大小/64，最大内存大小：物理电脑内存大小/4</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/7/6 16:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：获取JVM默认的堆内存大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总大小</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用最大的堆内存大小</span></span><br><span class="line">        <span class="keyword">long</span> max = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-Xms:"</span> + initialMemory + <span class="string">"MB"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-Xmx:"</span> + initialMemory + <span class="string">"MB"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"系统内存大小为："</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">"G"</span>);</span><br><span class="line">        System.out.println(<span class="string">"系统内存大小为："</span> + max * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">"G"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<blockquote>
<p>-Xms:489MB<br>-Xmx:7246MB<br>系统内存大小为：30.5625G<br>系统内存大小为：28.3046875G</p>
</blockquote>
<p>可以手动设置 -Xms200m -Xmx200m -XX:+PrintGCDetails</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706170852.png"  alt="手动设置堆内存大小"></p>
<p>可以发现（新生代+老年代）/1024 = 192M</p>
<p>或者通过jps命令进行证明：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706171203.png"  alt="jps指令"></p>
<h4 id="OOM演示"><a href="#OOM演示" class="headerlink" title="OOM演示"></a>OOM演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(20);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            list.add(<span class="keyword">new</span> Picture(<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Picture</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] pixels;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Picture</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pixels = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.github.jvm.part06_heap.java1.Picture.&lt;init&gt;(OOMTest.java:27)</span><br><span class="line">	at com.github.jvm.part06_heap.java1.OOMTest.main(OOMTest.java:18)</span><br></pre></td></tr></table></figure>

<p>通过jvisualvm可以观察到内存变化：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706172249.gif"  alt="OOM测试"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706172458.png"  alt="OOM演示"></p>
<h3 id="新生代与老年代"><a href="#新生代与老年代" class="headerlink" title="新生代与老年代"></a>新生代与老年代</h3><p>存储在JVM中的对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬间对象，这类对象的创建和消亡都非常迅速</li>
<li>另一类对象的生命周期却很长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>
</ul>
<p>Java堆区进一步细分的话，可以划分为年轻代和老年代，其中年轻代又可以划分为Eden空间、Survivor0空间、Survivor1空间（有时也叫做from区、to区）</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706173032.png"  alt="新生代与老年代"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706173542.png"  alt="新生代与老年代占比"></p>
<p>下面的参数在开发中一般不会去调整：</p>
<ul>
<li><p>配置新生代与老年代在堆结构的占比</p>
<ul>
<li>默认 -XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li>
<li>可以修改 -XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li>
</ul>
</li>
<li><p>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1</p>
</li>
<li><p>可以通过选项“-XX:SurvivorRatio”调整Eden空间和另外两个Survivor空间比例，比如-XX:SurvivorRatio=8</p>
</li>
<li><p><strong>几乎所有</strong>的Java对象都是在Eden区被new出来的</p>
</li>
<li><p>绝大部分的Java对象的销毁都在新生代进行了</p>
<ul>
<li>IBM公司专门的研究表明，新生代中80%的对象都是“朝生夕死”的</li>
</ul>
</li>
<li><p>可以使用选项“-Xmn”设置新生代最大内存大小</p>
<ul>
<li>这个参数一般使用默认值就可以了</li>
</ul>
</li>
</ul>
<p>JVM参数：-Xms600m -Xmx600m</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdenSurvivorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我只是来打个酱油~"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706174716.png"  alt="查看比例"></p>
<p>可以发现OC老年代大小为 409600KB=400MB</p>
<p>S0C+S1C+EC：25600+25600+153600= 204800KB=200MB</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706175427.png"  alt="新生代和老年代空间分配"></p>
<p>说明：还有一个参数选项没有用到，-XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）</p>
<h3 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ol>
<li><p>new的对象先放伊甸园区,此区有大小限制：</p>
</li>
<li><p>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(<strong>Minor GC</strong>)，将伊甸园区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到伊甸园区</p>
</li>
<li><p>然后将伊甸园中的剩余对象移动到幸存者0区</p>
</li>
<li><p>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区</p>
</li>
<li><p>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区</p>
</li>
<li><p>啥时候能去养老区呢？可以设置次数，默认是15次</p>
<blockquote>
<p>可以设置参数：-XX：MaxTenuringThreshold=<N>进行设置</p>
</blockquote>
</li>
<li><p>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：<strong>Major GC</strong>，进行养老区的内存清理</p>
</li>
<li><p>若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常</p>
<ul>
<li>java.lang.OutOfMemoryError：Java heap space</li>
</ul>
</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706181306.png"  alt="对象分配过程"></p>
<p><strong>小结对象分配过程</strong></p>
<ul>
<li>针对幸存者s0、s1区的总结：复制之后有交换，谁空谁是to</li>
<li>关于垃圾回收：频繁在新生区收集，很少在老年区收集，几乎不在永久区/元空间收集</li>
</ul>
<p><strong>对象分配的特殊情况</strong></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706181632.png"  alt="对象分配的特殊情况"></p>
<p>代码演示内存分配过程，结合JVisualVM</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapInstanceTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//变量作用是占据空间</span></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">200</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;HeapInstanceTest&gt; list = <span class="keyword">new</span> ArrayList&lt;HeapInstanceTest&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> HeapInstanceTest());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706182404.gif"  alt="对象分配过程"></p>
<p>同样使用JProfiler分析工具也是能看到内存的分配过程的，JProfiler使用参考：<a href="https://www.jb51.net/softjc/608655.html" target="_blank" rel="noopener">https://www.jb51.net/softjc/608655.html</a></p>
<h3 id="Minor-GC、Major-GC与Full-GC"><a href="#Minor-GC、Major-GC与Full-GC" class="headerlink" title="Minor GC、Major GC与Full GC"></a>Minor GC、Major GC与Full GC</h3><p>JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代、永久区|方法区|元空间）区域一起回收的，大部分时候回收的都是指新生代。<br>针对Hotspotv VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集(Partial GC)，一种是整堆收集(Full GC)</p>
<ul>
<li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul>
<li>新生代收集（Minor GC／Young GC)：只是新生代(Eden\S0,S1)的垃圾收集</li>
<li>老年代收集(Major GC / Old GC）：只是老年代的垃圾收集<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为</li>
<li>注意，<strong>很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收</strong></li>
</ul>
</li>
<li>混合收集(Mixed GC)：收集整个新生代以及部分老年代的垃圾收集<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集(Full GC)收集整个java堆和方法区的垃圾收集</li>
</ul>
<h4 id="年轻代GC（Minor-GC-Young-GC）触发机制"><a href="#年轻代GC（Minor-GC-Young-GC）触发机制" class="headerlink" title="年轻代GC（Minor GC/Young GC）触发机制"></a>年轻代GC（Minor GC/Young GC）触发机制</h4><ul>
<li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，survivor满不会引发GC（每次Minor GC会清理年轻<br>代的内存）</li>
<li>因为Java对象<strong>大多都具备朝生夕灭</strong>的特性，所以MinorGC非常频繁，一般回收速度也比较快，这一定义既清晰又易于理解</li>
<li>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706185616.png"  alt="Minor GC"></p>
<h4 id="老年代GC（Major-GC-Old-GC）触发机制"><a href="#老年代GC（Major-GC-Old-GC）触发机制" class="headerlink" title="老年代GC（Major GC/Old GC）触发机制"></a>老年代GC（Major GC/Old GC）触发机制</h4><ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说”Major GC”或”Full GC”发生了。</li>
<li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发MajorGC</li>
</ul>
</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长</li>
<li>如果Major GC后，内存还不足，就报OOM了</li>
</ul>
<h4 id="整堆收集Full-GC触发机制"><a href="#整堆收集Full-GC触发机制" class="headerlink" title="整堆收集Full GC触发机制"></a>整堆收集Full GC触发机制</h4><p>触发Full GC执行的情况有如下五种（后面会详细讲）：</p>
<p>1、调用System.gc()时，系统建议执行Full GC，但是不必然执行</p>
<p>2、老年代空间不足</p>
<p>3、方法区空间不足</p>
<p>4、通过Minor GC后进入老年代的平均大小小于老年代的可用内存</p>
<p>5、有Eden区、Survivor0（From Space）区向Survivor1（To Space）区复制时，对象大小大于To Space可用内存，则把对象转存为老年代，且老年代的可用内存大小小于该对象大小</p>
<p>说明：full gc是开发或调优中尽量要避免的，这样短暂时间会短一些</p>
<h4 id="GC举例与日志分析"><a href="#GC举例与日志分析" class="headerlink" title="GC举例与日志分析"></a>GC举例与日志分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试MinorGC 、 MajorGC、FullGC</span></span><br><span class="line"><span class="comment"> * -Xms9m -Xmx9m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String a = <span class="string">"hello world!"</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"遍历次数为："</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706191607.png"  alt="GC Test"></p>
<h3 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h3><p>思考：为什么需要把Java堆分代？不分带就不能正常工作了吗？</p>
<ul>
<li>经研究，不同对象的生命周期不同，70%-90%的对象都是临时对象<ul>
<li>新生代：有Eden、两块大小相同的Survivor（又称from/to，s0/s1）构成，to总为空</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象</li>
</ul>
</li>
<li>其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</li>
</ul>
<h3 id="内存分配策略（或对象提升promotion规则）"><a href="#内存分配策略（或对象提升promotion规则）" class="headerlink" title="内存分配策略（或对象提升promotion规则）"></a>内存分配策略（或对象提升promotion规则）</h3><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为巧岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。</p>
<p>对象晋升老年代的年龄阈值，可以通过选项来设置 -XX:MaxTenuringThreshold来设置</p>
<p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到Eden</li>
<li>大对象直接分配到老年代<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断<ul>
<li>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄</li>
</ul>
</li>
<li>空间分配担保<ul>
<li>-XX:HandlePromotionFailure</li>
</ul>
</li>
</ul>
<h4 id="测试：大对象直接进入老年代"><a href="#测试：大对象直接进入老年代" class="headerlink" title="测试：大对象直接进入老年代"></a>测试：大对象直接进入老年代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：大对象直接进入老年代</span></span><br><span class="line"><span class="comment"> * -Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungOldAreaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">20</span>];<span class="comment">//20m</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先分配1MB空间看下日志输出：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706195451.png"  alt="大对象直接进入老年代"></p>
<p>eden：16384 16M</p>
<p>from/to：2048  2M</p>
<p>old：40960 40M</p>
<p>当分配了1M的buffer空间，由于小于eden区可存放大小，所以数据就存放在了Eden区，接下来我们分配20M看下日志：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706195837.png"  alt="大对象直接进入老年代"></p>
<p>注意，上一张图中YoungGen use 3674，这个use 2650，相减正是1024K。</p>
<h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><h4 id="为什么会有TLAB（Thread-Local-Allocation-Buffer）"><a href="#为什么会有TLAB（Thread-Local-Allocation-Buffer）" class="headerlink" title="为什么会有TLAB（Thread Local Allocation Buffer）?"></a>为什么会有TLAB（Thread Local Allocation Buffer）?</h4><ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<h4 id="什么是TLAB？"><a href="#什么是TLAB？" class="headerlink" title="什么是TLAB？"></a>什么是TLAB？</h4><ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略</li>
<li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706200457.png"  alt="TLAB"></p>
<h4 id="TLAB补充说明"><a href="#TLAB补充说明" class="headerlink" title="TLAB补充说明"></a>TLAB补充说明</h4><ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分的首选</strong></li>
<li>在程序中，开发人员可以通过选项”-XX:UseTLAB”设置是否开启TLAB空间</li>
<li>默认情况下，TLAB空间的内存非常小，<strong>仅占有整个Eden空间的1%</strong>，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配内存</li>
<li>参考文章：<a href="https://www.cnblogs.com/mutong1228/p/10294706.html" target="_blank" rel="noopener">https://www.cnblogs.com/mutong1228/p/10294706.html</a></li>
</ul>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试-XX:UseTLAB参数是否开启的情况:默认情况是开启的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TLABArgsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我只是来打个酱油~"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>验证程序是默认开启TLAB的：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706201612.png"  alt="TLAB"></p>
<p>加入TLAB之后的对象分配过程为：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706201754.png"  alt="TLAB对象分配过程"></p>
<p>问题：堆空间一定是内存共享的吗？答案不一定，以为有TLAB，是对每个线程私有的空间。</p>
<h3 id="堆空间的参数设置小结"><a href="#堆空间的参数设置小结" class="headerlink" title="堆空间的参数设置小结"></a>堆空间的参数设置小结</h3><ul>
<li><p>官网说明</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></li>
</ul>
</li>
<li><p>-XX:+PrintFlagsInitial：查看所有的参数的默认初始值</p>
</li>
<li><p>-XX:+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p>
</li>
<li><p>-Xms：初始堆空间内存（默认为物理内存的1／64）</p>
</li>
<li><p>-Xmx：最大堆空间内存（默认为物理内存的1/4）</p>
</li>
<li><p>-Xmn：设置新生代的大小。〈初始值及最大值）</p>
</li>
<li><p>-XX:NewRatio：配置新生代与老年代在堆结构的占比</p>
</li>
<li><p>-XX:survivorRatio：设置新生代中Eden和S0/S1空间的比例</p>
</li>
<li><p>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</p>
</li>
<li><p>-XX:+PrintGCDetails：输出详细的GC处理日志</p>
<ul>
<li>打印gc简要信息：①-XX:+PrintGC  ②-verbose：gc</li>
</ul>
</li>
<li><p>-XX：HandlePromotionFailure：是否设置空间分配担保</p>
</li>
</ul>
<p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p>
<ul>
<li>如果大于，则此次Minor GC是安全的</li>
<li>如果小于，则虚拟机会查看-XX:HandlepromotionFaiIure设置值是否允许担保失败<ul>
<li>如果HandlepromotionFaiIure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。<ul>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的</li>
<li>如果小于，则改为进行一次Full FC</li>
</ul>
</li>
<li>如果HandlepromotionFaiIure=faIse，则改为进行一次FullGC</li>
</ul>
</li>
</ul>
<p>在JDK6 Update24之后，HandlepromotionFaiIure参数不会再影响到虚拟机的空间分配担保策略，观察OpenJDK中的源码变化，虽然源码中还定义了<br>HandlepromotionFaiIure参数，但是在代码中己经不会再使用它。JDK6 Update24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小</strong>或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p><strong>堆是分配对象的唯一选择吗？</strong></p>
<p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：<br>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配</strong>、<strong>标量替换优化</strong>技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap)技术实现off-heap，将生命周期较长的Java对象从heap中移到heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
<h4 id="逃逸分析概念"><a href="#逃逸分析概念" class="headerlink" title="逃逸分析概念"></a>逃逸分析概念</h4><ul>
<li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li>
<li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li>
<li>通过逃逸分析，Java HotSpot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li>
<li>逃逸分析的基本行为就是分析对象动态作用域：<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
</li>
</ul>
<p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706230200.png"  alt="逃逸分析"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706230242.png"  alt="逃逸分析"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span> ? <span class="keyword">new</span> EscapeAnalysis() : obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在JDK 6u23版本之后，HotSpot中默认就已经开启了逃逸分析</li>
<li>如果使用的是较早的版本，开发人员则可以通过：<ul>
<li>选项“-XX:DoEscapeAnalysis”显式开启逃逸分析</li>
<li>通过选项“-XX:+PrintEscapeAnylysis”查看逃逸分析的筛选结果</li>
</ul>
</li>
<li>结论：开发中能使用局部变量的，就不要使用在方法外定义</li>
</ul>
<h4 id="利用逃逸分析进行代码优化"><a href="#利用逃逸分析进行代码优化" class="headerlink" title="利用逃逸分析进行代码优化"></a>利用逃逸分析进行代码优化</h4><p>利用逃逸分析，编译器可以对代码做如下优化：</p>
<ul>
<li>栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</li>
<li>同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li>分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>
</ul>
<h5 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h5><ul>
<li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后一程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li>
<li>常见的栈上分配的场景<ul>
<li>在逃逸分析中，己经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配测试</span></span><br><span class="line"><span class="comment"> * -Xmx256M -Xms256M -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"花费的时间为： "</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过命令：<code>-Xmx256M -Xms256M -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</code>不使用内存逃逸分析，日志输出为：</p>
<blockquote>
<p>[GC (Allocation Failure) [PSYoungGen: 65536K-&gt;776K(76288K)] 65536K-&gt;784K(251392K), 0.0039222 secs] [Times: user=0.00 sys=0.00, real=0.02 secs]<br>[GC (Allocation Failure) [PSYoungGen: 66312K-&gt;744K(76288K)] 66320K-&gt;752K(251392K), 0.0007021 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>花费的时间为： 54 ms</p>
</blockquote>
<p>可以发现已经用了两次YoungGC了</p>
<p>Java VisualVM工具分析：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706234913.png"  alt="不使用逃逸分析"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706234954.png"  alt="不使用逃逸分析"></p>
<p>接下来使用逃逸分析：<code>-Xmx256M -Xms256M -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</code></p>
<p>日志输出：</p>
<blockquote>
<p>花费的时间为： 4 ms</p>
</blockquote>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706235146.png"  alt="使用逃逸分析"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200706235209.png"  alt="使用逃逸分析"></p>
<h5 id="同步省略（消除）"><a href="#同步省略（消除）" class="headerlink" title="同步省略（消除）"></a>同步省略（消除）</h5><ul>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li>
<li>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<strong>锁消除</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步省略说明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以JIT编译阶段就会被优化掉，优化成： </span></span><br><span class="line"><span class="comment">     public void f() &#123;</span></span><br><span class="line"><span class="comment">        Object hollis = new Object();</span></span><br><span class="line"><span class="comment">        System.out.println(hollis);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span> (hollis) &#123;</span><br><span class="line">            System.out.println(hollis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707000206.png"  alt="同步省略"></p>
<h5 id="分离对象（标量替换）"><a href="#分离对象（标量替换）" class="headerlink" title="分离对象（标量替换）"></a>分离对象（标量替换）</h5><p><strong>标量(Scalar)</strong>是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>
<p>相对的，那些还可以分解的数据叫做<strong>聚合量（Aggregate）</strong>，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是<strong>标量替换</strong>。</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707000503.png"  alt="标量替换"></p>
<p>上述代码，经过标量替换之后，就会变成：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707000551.png"  alt="标量替换"></p>
<p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p>
<p>标量替换参数设置：<br>参数 <code>-XX:+EliminatateAllocations</code>，默认是打开状态，允许将对象打散分配在栈上。</p>
<p>演示一下开启与关闭的效果对比：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标量替换测试</span></span><br><span class="line"><span class="comment"> * -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScalarReplace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">        u.id = <span class="number">5</span>;</span><br><span class="line">        u.name = <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"花费的时间为： "</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 ：-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</p>
<p>输出日志：</p>
<blockquote>
<p>[GC (Allocation Failure)  25600K-&gt;752K(98304K), 0.0009017 secs]<br>[GC (Allocation Failure)  26352K-&gt;768K(98304K), 0.0009036 secs]<br>……<br>[GC (Allocation Failure)  33468K-&gt;700K(101888K), 0.0002327 secs]<br>[GC (Allocation Failure)  33468K-&gt;700K(101888K), 0.0002410 secs]<br>花费的时间为： 372 ms</p>
</blockquote>
<p>参数 ：-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC +XX:-EliminateAllocations</p>
<blockquote>
<p>花费的时间为： 4 ms</p>
</blockquote>
<p>可以发现，当开启了栈上逃逸，打开标量替换之后，程序的执行速度显著提高了。</p>
<p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p>
<blockquote>
<p>-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC +XX:-EliminateAllocations</p>
</blockquote>
<p>这里使用参数如下：</p>
<ul>
<li>参数-server：启动server模式，因为在server模式下，才可以启用逃逸分析。</li>
<li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li>
<li>参数-Xmx100m：指定了堆空间最大为100MB</li>
<li>参数-XX:+PrintGC：将打印GC日志</li>
<li>参数+XX:-EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配。</li>
</ul>
<h4 id="逃逸分析小结"><a href="#逃逸分析小结" class="headerlink" title="逃逸分析小结"></a>逃逸分析小结</h4><ul>
<li>关于逃逸分析的论文在1999年就己经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的</li>
<li>其根本原因就是<strong>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></li>
<li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li>
<li>虽然这项技术并不十分成熟，但是<strong>它也是即时编译器优化技术中一个十分重要的手段</strong>。</li>
<li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，<strong>这一点在逃逸分析相关的文档里己经说明，所以可以明确所有的对象实例都是创建在堆上</strong>。</li>
<li>目前很多书籍还是基于JDK 7以前的版本，JDK己经发生了很大变化，<strong>intern字符串的缓存和静态变量曾经都被分配在永久代上</strong>，而永久代己经被元数据区取代。但是，<strong>intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配</strong>，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</li>
</ul>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><ul>
<li>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命</li>
<li>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代</li>
<li>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。当GC发生在老年代时则被称为Major GC或者Full GC。一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代</li>
</ul>
<h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区的位置：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707003021.png"  alt="方法区的位置"></p>
<h3 id="栈、堆、、方法区的交互关系"><a href="#栈、堆、、方法区的交互关系" class="headerlink" title="栈、堆、、方法区的交互关系"></a>栈、堆、、方法区的交互关系</h3><p>从线程共享与否的角度去看运行时数据区结构图：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707140625.png"  alt="运行时数据区"></p>
<p>堆、栈、方法区交互关系：<br><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707142003.png"  alt="堆、栈、方法区交互关系"></p>
<p>《Java虚拟机规范》中明确说明：”尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpot JVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。所以<strong>，方法区看作是一块独立于Java堆的内存空间</strong>。</p>
<h3 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h3><ul>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError：PermGen space 或者 java.lang.OutOfMemoryError：Meta space<ul>
<li>加载大量的第三方的jar包；Tomcat部署的工程过多（30一50个）；大量动态的生成反射类</li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存</li>
</ul>
<h4 id="方法区大小与OOM"><a href="#方法区大小与OOM" class="headerlink" title="方法区大小与OOM"></a>方法区大小与OOM</h4><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jdk7及以前：</span><br><span class="line">-Xmx600m -Xms600m -XX:PermSize&#x3D;100m -XX:MaxPermSize&#x3D;100m</span><br><span class="line"></span><br><span class="line">jdk8及以后：</span><br><span class="line">-Xmx600m -Xms600m -XX:MetaspaceSize&#x3D;100m -XX:MaxMetaspaceSize&#x3D;100m</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试设置方法区大小参数的默认值</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * jdk7及以前：</span></span><br><span class="line"><span class="comment"> * -Xmx600m -Xms600m -XX:PermSize=100m -XX:MaxPermSize=100m</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * jdk8及以后：</span></span><br><span class="line"><span class="comment"> * -Xmx600m -Xms600m -XX:MetaspaceSize=100m -XX:MaxMetaspaceSize=100m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK7的情况下Java VisualVM分析：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707144813.png"  alt="JDK7情况"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707144857.png"  alt="JDK7情况"></p>
<p>接下来看下JDK8的情况：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707145042.png"  alt="JDK8情况"></p>
<p>发现并没有设置成功。</p>
<p><strong>HotSpot中方法区的演进</strong></p>
<ul>
<li>在JDK7及以前，习惯上把方法区成为永久代。JDK8开始，使用元空间取代了永久代。</li>
<li>本质上，方法区和永久代并不等价，仅是针对HotSpot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit、IBM J9中不存在永久代的概念<ul>
<li>现在来看，当年使用永久代，不是很好的idea，导致Java程序更容易OOM（超过-XX:MaxPermSize上限）</li>
</ul>
</li>
<li>而到了JDK 8，纵欲完全废弃了永久代的概念，改用与JRockit、J9一样的本地内存中实现的元空间（Meta Space）来代替</li>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不再虚拟机设置的内存中，而是使用本地内存</strong></li>
<li>永久代、元空间二者并不是名字变了，内部结构也调整了</li>
<li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707150206.png"  alt="不同版本的方法区"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707150237.png"  alt="JDK8中的方法区"></p>
<h3 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h3><p>方法区的大小不必是固定的，jvm可以根据应用的需要动态调整</p>
<p><strong>jdk7及以前：</strong></p>
<ul>
<li>通过 -XX:PermSize来设置永久代初始分配空间，默认是20.75M</li>
<li>-XX:MaxPermSize来设置永久代最大可分配空间，32位机器默认是64M，64位机器默认是82M</li>
<li>当JVM加载的类信息容量超过这个值，就会报OutOfMemoryError：PermGen Space</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707152203.png"  alt="JDK7环境下的方法区大小"></p>
<p>21757952B=20.75M</p>
<p>85983232B=82M</p>
<p><strong>jdk8及以后：</strong></p>
<ul>
<li>元数据区大小可以使用参数<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>指定，替代上述原有的两个参数</li>
<li>默认值依赖于平台。windows下，<strong>XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制</strong></li>
<li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError：MetaSpace</li>
<li>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21M。这就是初始的高水位线，一旦触及这个水位线，FullGC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值</li>
<li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值</li>
</ul>
<p>参数配置：-Xmx600m -Xms600m -XX:MetaspaceSize=100m -XX:MaxMetaspaceSize=100m</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707153209.png"  alt="JDK8"></p>
<p>其中，104857600B=100MB</p>
<h4 id="演示OOM"><a href="#演示OOM" class="headerlink" title="演示OOM"></a>演示OOM</h4><p>借助CGlib使得方法区出现内存溢出异常，同时为了看到效果我们手动将方法区大小设置为10M。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6/7中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OOMTest test = <span class="keyword">new</span> OOMTest();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">"Class"</span> + i, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">"Class"</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK8日志输出：</p>
<blockquote>
<p>8531<br>Exception in thread “main” java.lang.OutOfMemoryError: <strong>Metaspace</strong><br>    at java.lang.ClassLoader.defineClass1(Native Method)<br>    at java.lang.ClassLoader.defineClass(ClassLoader.java:763)<br>    at java.lang.ClassLoader.defineClass(ClassLoader.java:642)<br>    at com.github.jvm.part07_method_area.OOMTest.main(OOMTest.java:26)</p>
</blockquote>
<p>JDK7日志输出（10000个对象并没有报异常，我们改为50000）：</p>
<blockquote>
<p>10266</p>
<p>Exception in thread “Reference Handler” Exception in thread “main” java.lang.OutOfMemoryError: PermGen space<br>​    at java.lang.ClassLoader.defineClass(Unknown Source)<br>​    at java.lang.ClassLoader.defineClass(Unknown Source)<br>​    at com.github.jvm7.part07_method_area.OOMTest.main(OOMTest.java:26)</p>
<p>Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread “Reference Handler”</p>
</blockquote>
<h4 id="如何解决OOM？"><a href="#如何解决OOM？" class="headerlink" title="如何解决OOM？"></a>如何解决OOM？</h4><p>1、要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer)对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak)还是内存溢出(Memory Overflow）</p>
<p>2、如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置</p>
<p>3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms)，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<h3 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707154907.png"  alt="方法区内部结构"></p>
<h4 id="方法区（Method-Area）存储什么？"><a href="#方法区（Method-Area）存储什么？" class="headerlink" title="方法区（Method Area）存储什么？"></a>方法区（Method Area）存储什么？</h4><p>《深入理解Java虚拟机》书中对方法区(Method Area）存储内容描述如下：它用于存储己被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓</strong><br><strong>存</strong>等。</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707160828.png"  alt="方法区存储的内容"></p>
<h5 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h5><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息：</p>
<ul>
<li>这个类型的完整有效名（全名：包名．类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li>
<li>这个类型的修饰符(public,abstract,且的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<h5 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h5><ul>
<li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li>
<li>域的相关信息包括：域名称、域类型、域修饰符(public,private,protected,static,final,volatile,transient的某个子集）</li>
</ul>
<h5 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h5><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型（或void)<br>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符(public,private,protected,static,final,synchronized,native,abstract的一个子集）</li>
<li>方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外）</li>
<li>异常表(abstract和native方法除外）<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String str = <span class="string">"测试方法的内部结构"</span>;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">"count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> cal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译之后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">Classfile &#x2F;D:&#x2F;workspace&#x2F;Github&#x2F;jvm_study&#x2F;out&#x2F;production&#x2F;jvm_study&#x2F;com&#x2F;github&#x2F;jvm&#x2F;part07_method_area&#x2F;java1&#x2F;MethodInnerStrucTest.class</span><br><span class="line">  Last modified 2020-7-7; size 1672 bytes</span><br><span class="line">  MD5 checksum 83f0fa190a8ba0c4397e145e8d67edfb</span><br><span class="line">  Compiled from &quot;MethodInnerStrucTest.java&quot;</span><br><span class="line">public class com.github.jvm.part07_method_area.java1.MethodInnerStrucTest extends java.lang.Object implements java.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializabl</span><br><span class="line">e</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #18.#52        &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Fieldref           #17.#53        &#x2F;&#x2F; com&#x2F;github&#x2F;jvm&#x2F;part07_method_area&#x2F;java1&#x2F;MethodInnerStrucTest.num:I</span><br><span class="line">   #3 &#x3D; Fieldref           #54.#55        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">   #4 &#x3D; Class              #56            &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">   #5 &#x3D; Methodref          #4.#52         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #6 &#x3D; String             #57            &#x2F;&#x2F; count &#x3D;</span><br><span class="line">   #7 &#x3D; Methodref          #4.#58         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">   #8 &#x3D; Methodref          #4.#59         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">   #9 &#x3D; Methodref          #4.#60         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #10 &#x3D; Methodref          #61.#62        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #11 &#x3D; Class              #63            &#x2F;&#x2F; java&#x2F;lang&#x2F;Exception</span><br><span class="line">  #12 &#x3D; Methodref          #11.#64        &#x2F;&#x2F; java&#x2F;lang&#x2F;Exception.printStackTrace:()V</span><br><span class="line">  #13 &#x3D; Class              #65            &#x2F;&#x2F; java&#x2F;lang&#x2F;String</span><br><span class="line">  #14 &#x3D; Methodref          #17.#66        &#x2F;&#x2F; com&#x2F;github&#x2F;jvm&#x2F;part07_method_area&#x2F;java1&#x2F;MethodInnerStrucTest.compareTo:(Ljava&#x2F;lang&#x2F;String;)I</span><br><span class="line">  #15 &#x3D; String             #67            &#x2F;&#x2F; 测试方法的内部结构</span><br><span class="line">  #16 &#x3D; Fieldref           #17.#68        &#x2F;&#x2F; com&#x2F;github&#x2F;jvm&#x2F;part07_method_area&#x2F;java1&#x2F;MethodInnerStrucTest.str:Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #17 &#x3D; Class              #69            &#x2F;&#x2F; com&#x2F;github&#x2F;jvm&#x2F;part07_method_area&#x2F;java1&#x2F;MethodInnerStrucTest</span><br><span class="line">  #18 &#x3D; Class              #70            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">  #19 &#x3D; Class              #71            &#x2F;&#x2F; java&#x2F;lang&#x2F;Comparable</span><br><span class="line">  #20 &#x3D; Class              #72            &#x2F;&#x2F; java&#x2F;io&#x2F;Serializable</span><br><span class="line">  #21 &#x3D; Utf8               num</span><br><span class="line">  #22 &#x3D; Utf8               I</span><br><span class="line">  #23 &#x3D; Utf8               str</span><br><span class="line">  #24 &#x3D; Utf8               Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #25 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">  #26 &#x3D; Utf8               ()V</span><br><span class="line">  #27 &#x3D; Utf8               Code</span><br><span class="line">  #28 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #29 &#x3D; Utf8               LocalVariableTable</span><br><span class="line">  #30 &#x3D; Utf8               this</span><br><span class="line">  #31 &#x3D; Utf8               Lcom&#x2F;github&#x2F;jvm&#x2F;part07_method_area&#x2F;java1&#x2F;MethodInnerStrucTest;</span><br><span class="line">  #32 &#x3D; Utf8               test1</span><br><span class="line">  #33 &#x3D; Utf8               count</span><br><span class="line">  #34 &#x3D; Utf8               test2</span><br><span class="line">  #35 &#x3D; Utf8               (I)I</span><br><span class="line">  #36 &#x3D; Utf8               value</span><br><span class="line">  #37 &#x3D; Utf8               e</span><br><span class="line">  #38 &#x3D; Utf8               Ljava&#x2F;lang&#x2F;Exception;</span><br><span class="line">  #39 &#x3D; Utf8               cal</span><br><span class="line">  #40 &#x3D; Utf8               result</span><br><span class="line">  #41 &#x3D; Utf8               StackMapTable</span><br><span class="line">  #42 &#x3D; Class              #63            &#x2F;&#x2F; java&#x2F;lang&#x2F;Exception</span><br><span class="line">  #43 &#x3D; Utf8               compareTo</span><br><span class="line">  #44 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)I</span><br><span class="line">  #45 &#x3D; Utf8               o</span><br><span class="line">  #46 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;Object;)I</span><br><span class="line">  #47 &#x3D; Utf8               &lt;clinit&gt;</span><br><span class="line">  #48 &#x3D; Utf8               Signature</span><br><span class="line">  #49 &#x3D; Utf8               Ljava&#x2F;lang&#x2F;Object;Ljava&#x2F;lang&#x2F;Comparable&lt;Ljava&#x2F;lang&#x2F;String;&gt;;Ljava&#x2F;io&#x2F;Serializable;</span><br><span class="line">  #50 &#x3D; Utf8               SourceFile</span><br><span class="line">  #51 &#x3D; Utf8               MethodInnerStrucTest.java</span><br><span class="line">  #52 &#x3D; NameAndType        #25:#26        &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #53 &#x3D; NameAndType        #21:#22        &#x2F;&#x2F; num:I</span><br><span class="line">  #54 &#x3D; Class              #73            &#x2F;&#x2F; java&#x2F;lang&#x2F;System</span><br><span class="line">  #55 &#x3D; NameAndType        #74:#75        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #56 &#x3D; Utf8               java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">  #57 &#x3D; Utf8               count &#x3D;</span><br><span class="line">  #58 &#x3D; NameAndType        #76:#77        &#x2F;&#x2F; append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #59 &#x3D; NameAndType        #76:#78        &#x2F;&#x2F; append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #60 &#x3D; NameAndType        #79:#80        &#x2F;&#x2F; toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #61 &#x3D; Class              #81            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #62 &#x3D; NameAndType        #82:#83        &#x2F;&#x2F; println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #63 &#x3D; Utf8               java&#x2F;lang&#x2F;Exception</span><br><span class="line">  #64 &#x3D; NameAndType        #84:#26        &#x2F;&#x2F; printStackTrace:()V</span><br><span class="line">  #65 &#x3D; Utf8               java&#x2F;lang&#x2F;String</span><br><span class="line">  #66 &#x3D; NameAndType        #43:#44        &#x2F;&#x2F; compareTo:(Ljava&#x2F;lang&#x2F;String;)I</span><br><span class="line">  #67 &#x3D; Utf8               测试方法的内部结构</span><br><span class="line">  #68 &#x3D; NameAndType        #23:#24        &#x2F;&#x2F; str:Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #69 &#x3D; Utf8               com&#x2F;github&#x2F;jvm&#x2F;part07_method_area&#x2F;java1&#x2F;MethodInnerStrucTest</span><br><span class="line">  #70 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">  #71 &#x3D; Utf8               java&#x2F;lang&#x2F;Comparable</span><br><span class="line">  #72 &#x3D; Utf8               java&#x2F;io&#x2F;Serializable</span><br><span class="line">  #73 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line">  #74 &#x3D; Utf8               out</span><br><span class="line">  #75 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #76 &#x3D; Utf8               append</span><br><span class="line">  #77 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #78 &#x3D; Utf8               (I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #79 &#x3D; Utf8               toString</span><br><span class="line">  #80 &#x3D; Utf8               ()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #81 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #82 &#x3D; Utf8               println</span><br><span class="line">  #83 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #84 &#x3D; Utf8               printStackTrace</span><br><span class="line">&#123;</span><br><span class="line">  public int num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  public com.github.jvm.part07_method_area.java1.MethodInnerStrucTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: bipush        10</span><br><span class="line">         7: putfield      #2                  &#x2F;&#x2F; Field num:I</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 12: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      11     0  this   Lcom&#x2F;github&#x2F;jvm&#x2F;part07_method_area&#x2F;java1&#x2F;MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  public void test1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;3, locals&#x3D;2, args_size&#x3D;1</span><br><span class="line">         0: bipush        20</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: getstatic     #3                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         6: new           #4                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">         9: dup</span><br><span class="line">        10: invokespecial #5                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        13: ldc           #6                  &#x2F;&#x2F; String count &#x3D;</span><br><span class="line">        15: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        18: iload_1</span><br><span class="line">        19: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        22: invokevirtual #9                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        25: invokevirtual #10                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">        28: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 17: 0</span><br><span class="line">        line 18: 3</span><br><span class="line">        line 19: 28</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      29     0  this   Lcom&#x2F;github&#x2F;jvm&#x2F;part07_method_area&#x2F;java1&#x2F;MethodInnerStrucTest;</span><br><span class="line">            3      26     1 count   I</span><br><span class="line"></span><br><span class="line">  public static int test2(int);</span><br><span class="line">    descriptor: (I)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: iconst_0</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: bipush        30</span><br><span class="line">         4: istore_2</span><br><span class="line">         5: iload_2</span><br><span class="line">         6: iload_0</span><br><span class="line">         7: idiv</span><br><span class="line">         8: istore_1</span><br><span class="line">         9: goto          17</span><br><span class="line">        12: astore_2</span><br><span class="line">        13: aload_2</span><br><span class="line">        14: invokevirtual #12                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Exception.printStackTrace:()V</span><br><span class="line">        17: iload_1</span><br><span class="line">        18: ireturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             2     9    12   Class java&#x2F;lang&#x2F;Exception</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 21: 0</span><br><span class="line">        line 23: 2</span><br><span class="line">        line 24: 5</span><br><span class="line">        line 27: 9</span><br><span class="line">        line 25: 12</span><br><span class="line">        line 26: 13</span><br><span class="line">        line 28: 17</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            5       4     2 value   I</span><br><span class="line">           13       4     2     e   Ljava&#x2F;lang&#x2F;Exception;</span><br><span class="line">            0      19     0   cal   I</span><br><span class="line">            2      17     1 result   I</span><br><span class="line">      StackMapTable: number_of_entries &#x3D; 2</span><br><span class="line">        frame_type &#x3D; 255 &#x2F;* full_frame *&#x2F;</span><br><span class="line">          offset_delta &#x3D; 12</span><br><span class="line">          locals &#x3D; [ int, int ]</span><br><span class="line">          stack &#x3D; [ class java&#x2F;lang&#x2F;Exception ]</span><br><span class="line">        frame_type &#x3D; 4 &#x2F;* same *&#x2F;</span><br><span class="line"></span><br><span class="line">  public int compareTo(java.lang.String);</span><br><span class="line">    descriptor: (Ljava&#x2F;lang&#x2F;String;)I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;2, args_size&#x3D;2</span><br><span class="line">         0: iconst_0</span><br><span class="line">         1: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 33: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       2     0  this   Lcom&#x2F;github&#x2F;jvm&#x2F;part07_method_area&#x2F;java1&#x2F;MethodInnerStrucTest;</span><br><span class="line">            0       2     1     o   Ljava&#x2F;lang&#x2F;String;</span><br><span class="line"></span><br><span class="line">  public int compareTo(java.lang.Object);</span><br><span class="line">    descriptor: (Ljava&#x2F;lang&#x2F;Object;)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;2, args_size&#x3D;2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: aload_1</span><br><span class="line">         2: checkcast     #13                 &#x2F;&#x2F; class java&#x2F;lang&#x2F;String</span><br><span class="line">         5: invokevirtual #14                 &#x2F;&#x2F; Method compareTo:(Ljava&#x2F;lang&#x2F;String;)I</span><br><span class="line">         8: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  this   Lcom&#x2F;github&#x2F;jvm&#x2F;part07_method_area&#x2F;java1&#x2F;MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;0, args_size&#x3D;0</span><br><span class="line">         0: ldc           #15                 &#x2F;&#x2F; String 测试方法的内部结构</span><br><span class="line">         2: putstatic     #16                 &#x2F;&#x2F; Field str:Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">&#125;</span><br><span class="line">Signature: #49                          &#x2F;&#x2F; Ljava&#x2F;lang&#x2F;Object;Ljava&#x2F;lang&#x2F;Comparable&lt;Ljava&#x2F;lang&#x2F;String;&gt;;Ljava&#x2F;io&#x2F;Serializable;</span><br><span class="line">SourceFile: &quot;MethodInnerStrucTest.java&quot;</span><br></pre></td></tr></table></figure>



<p><strong>non-final的类变量</strong></p>
<ul>
<li>静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分</li>
<li>类变量被类的所有实例共享，即使没有类实例时，也可以访问它</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * non-final的类变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>全局变量：static final</strong></p>
<p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就被分配了，我们反编译上面的Order类代码可以发现number在编译期就已经赋值了：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707165700.png"  alt="static final"></p>
<h4 id="运行时常量池vs常量池"><a href="#运行时常量池vs常量池" class="headerlink" title="运行时常量池vs常量池"></a>运行时常量池vs常量池</h4><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707165821.png"  alt="运行时常量池vs常量池"></p>
<ul>
<li>方法区，内部包含了<strong>运行时常量池</strong></li>
<li>字节码文件，内部包含了<strong>常量池</strong></li>
<li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区</li>
<li>需要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的 常量池</li>
<li>参考官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1</a></li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707170222.png"  alt="ClassFile"></p>
<p>常量池在class文件中的位置：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707170354.png"  alt="常量池在class文件中的位置"></p>
<blockquote>
<p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p>
</blockquote>
<h5 id="为什么需要常量池？"><a href="#为什么需要常量池？" class="headerlink" title="为什么需要常量池？"></a>为什么需要常量池？</h5><blockquote>
<p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。</p>
</blockquote>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707170756.png"  alt="常量池说明"></p>
<h5 id="常量池中都有什么？"><a href="#常量池中都有什么？" class="headerlink" title="常量池中都有什么？"></a>常量池中都有什么？</h5><p>几种在常量池内存储的数据类型包括：</p>
<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<p>例如下面一段代码：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707171036.png"  alt="常量池说明"></p>
<p><strong>小结常量池</strong></p>
<p>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p>
<h5 id="运行时常量的理解"><a href="#运行时常量的理解" class="headerlink" title="运行时常量的理解"></a>运行时常量的理解</h5><ul>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分</li>
<li>常量池表(Constant Pool Table)是Class文件的一部分，<strong>用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</strong></li>
<li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池</li>
<li>JVM为每个己加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就己经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址<ul>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是：具各动态性</li>
</ul>
</li>
<li>运行时常量池类似于传统编程语言中的符号表(symbol table)，但是它所包含的数据却比符号表要更加丰富一些</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常</li>
</ul>
<h3 id="方法区使用举例"><a href="#方法区使用举例" class="headerlink" title="方法区使用举例"></a>方法区使用举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaRunDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x / y;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  public com.github.jvm.part07_method_area.java1.MethodAreaRunDemo();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom&#x2F;github&#x2F;jvm&#x2F;part07_method_area&#x2F;java1&#x2F;MethodAreaRunDemo;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;3, locals&#x3D;5, args_size&#x3D;1</span><br><span class="line">         0: sipush        500</span><br><span class="line">         3: istore_1</span><br><span class="line">         4: bipush        100</span><br><span class="line">         6: istore_2</span><br><span class="line">         7: iload_1</span><br><span class="line">         8: iload_2</span><br><span class="line">         9: idiv</span><br><span class="line">        10: istore_3</span><br><span class="line">        11: bipush        50</span><br><span class="line">        13: istore        4</span><br><span class="line">        15: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">        18: iload_3</span><br><span class="line">        19: iload         4</span><br><span class="line">        21: iadd</span><br><span class="line">        22: invokevirtual #3                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V</span><br><span class="line">        25: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">        line 10: 4</span><br><span class="line">        line 11: 7</span><br><span class="line">        line 12: 11</span><br><span class="line">        line 13: 15</span><br><span class="line">        line 14: 25</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      26     0  args   [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">            4      22     1     x   I</span><br><span class="line">            7      19     2     y   I</span><br><span class="line">           11      15     3     a   I</span><br><span class="line">           15      11     4     b   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;MethodAreaRunDemo.java&quot;</span><br></pre></td></tr></table></figure>

<p>图解方法执行（图片10M，后期考虑压缩这张图片）：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707173914.png"  alt="图解方法执行"></p>
<h3 id="方法区的演进"><a href="#方法区的演进" class="headerlink" title="方法区的演进"></a>方法区的演进</h3><ul>
<li>首先声明，只有HotSopt才有永久代。BEA JRockit、IBM J9等来说，是不存在永久代概念的。原则上如何实现方法区属于虚拟机细节，不受《Java虚拟机规范》管束，并不要求统一</li>
<li>HotSpot中方法区的变化</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707174449.png"  alt="HotSpot中方法区的变化"></p>
<p>JDK6：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707174613.png"  alt="JDK6"></p>
<p>JDK7：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707174640.png"  alt="JDK7"></p>
<p>JDK8：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707174723.png"  alt="JDK8"></p>
<h4 id="永久代为什么要被元空间替换"><a href="#永久代为什么要被元空间替换" class="headerlink" title="永久代为什么要被元空间替换"></a>永久代为什么要被元空间替换</h4><ul>
<li>随着Java8的到来，Hotspot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）</li>
<li>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空这项改动是很有必要的，原因有：<ul>
<li>1）为永久代设置空间大小是很难确定的<br>在某些场景下，如果动态加载类过多，容易产生Perm的OOM。比如某个实际web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。<strong>Exception in thread ‘dubbo client x.x connector’ java.lang.OutOfMemoryError:PermGenspace</strong><br>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</li>
<li>2）对永久代进行调优是很困难的。</li>
</ul>
</li>
</ul>
<h4 id="StringTable为什么要调整位置"><a href="#StringTable为什么要调整位置" class="headerlink" title="StringTable为什么要调整位置"></a>StringTable为什么要调整位置</h4><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<h3 id="静态变量放在哪里？"><a href="#静态变量放在哪里？" class="headerlink" title="静态变量放在哪里？"></a>静态变量放在哪里？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk7：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * jdk 8：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFieldTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];<span class="comment">//100MB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line">        <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">            Thread.sleep(1000000);</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>JDK6和JDK7日志打印一样,发现6和7都是放在老年代里面的：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707180407.png"  alt="JDK6&amp;JDK7"></p>
<p>JDK8:</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707180545.png"  alt="JDK8"></p>
<p>说明：为什么JDK8也在老年代？因为上面讲的存储位置是指的<strong>变量名存储的位置</strong>发生了改变，而new出来的对象依旧是在堆里。</p>
<p>思考题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 《深入理解Java虚拟机》中的案例：</span></span><br><span class="line"><span class="comment"> * staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticObjTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ObjectHolder staticObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">        ObjectHolder instanceObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectHolder localObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">            System.out.println(<span class="string">"done"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> StaticObjTest.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>staticObj随着Test的类型信息存放在方法区，instanceObj随着Test的对象实例存放在Java堆区，localObj则是存放在foo方法栈的局部变量表中</p>
</blockquote>
<p>使用jhsdb工具进行分析：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707181138.png"  alt="jhsdb"></p>
<p>测试发现：三个对象的数据在内存中的地址都落在Eden区范围，所以结论：只要是对象必然会在Java堆中分配</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707181401.png"  alt="JHSDB"></p>
<h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</p>
<p>一般来说<strong>这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻</strong>。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
<p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量</strong>和<strong>不再使用的类型</strong>。</p>
<ul>
<li>先来说说方法区内常量池之中主要存放的两大类常量：字而量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：<ul>
<li>1、类和接口的全限定名</li>
<li>2、字段的名称和描述符</li>
<li>3、方法的名称和描述符</li>
</ul>
</li>
<li>HotSpot虚拟机对常量池的回收策略是很明确的，<strong>只要常量池中的常量没有被任何地方引用，就可以被回收</strong>。</li>
<li>回收废弃常量与回收Java堆中的对象非常类似。</li>
</ul>
<ul>
<li>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：<ul>
<li>该类所有的例都己经被回收，也就是Java堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的类加载器己经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
</li>
<li>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，Hotspot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息</li>
<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，<u>通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</u></li>
</ul>
<h2 id="运行时数据区总结"><a href="#运行时数据区总结" class="headerlink" title="运行时数据区总结"></a>运行时数据区总结</h2><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707182652.png"  alt="运行时数据区总结"></p>
<p>PCRegister:PC计数器<br>Native Stack：本地方法栈<br>Stack：虚拟机栈</p>
<p>StackFrame栈帧<br>Return Value：返回值<br>Local Variables：本地变量表（局部变量表）<br>Operand Stack：操作数栈<br>Current Class Constant Pool Reference：动态链接</p>
<h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707183100.png"  alt="常见面试题"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200707183144.png"  alt="常见面试题"></p>
<h2 id="对象的实例化、内存布局与访问定位（补充）"><a href="#对象的实例化、内存布局与访问定位（补充）" class="headerlink" title="对象的实例化、内存布局与访问定位（补充）"></a>对象的实例化、内存布局与访问定位（补充）</h2><p>思考：</p>
<p>对象在JVM中是怎么存储的？</p>
<p>对象头信息里面有哪些东西？</p>
<p>Java对象头里都有什么？</p>
<h3 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200708141045.png"  alt="对象的实例化"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200708141121.png"  alt="创建对象的方式"></p>
<h4 id="从字节码角度去看对象创建过程"><a href="#从字节码角度去看对象创建过程" class="headerlink" title="从字节码角度去看对象创建过程"></a>从字节码角度去看对象创建过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译之后的内容：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200708141514.png"  alt="反编译"></p>
<h4 id="从代码执行步骤的角度去看对象创建过程"><a href="#从代码执行步骤的角度去看对象创建过程" class="headerlink" title="从代码执行步骤的角度去看对象创建过程"></a>从代码执行步骤的角度去看对象创建过程</h4><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200708141637.png"  alt="对象创建步骤"></p>
<ol>
<li><p><strong>判断对象对应的类是否加载、链接、初始化</strong></p>
<p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否己经被加载、解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象</p>
</li>
<li><p><strong>为对象分配内存</strong></p>
<p>首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。<br>如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。</p>
<ul>
<li>如果内存规整，使用指针碰撞<br>如果内存是规整的，那么虚拟机将采用的是指针碰撞法(Bump The Pointer)来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact（整理）过程的收集器时，使用指针碰撞。</li>
<li>如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配<br>如果内存不是规整的，己使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为“空闲列表（FreeList）“</li>
</ul>
<p>说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
</li>
<li><p><strong>处理并发安全问题</strong></p>
<p>在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用了两种方式解决并发问题：</p>
<ul>
<li>CAS（compare And swap）失败重试、区域加锁：保证指针更新操作的原子性；</li>
<li>TLAB把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB，Thread Local Allocation Buffer)虚拟机是否使用TLAB，可以通过<code>-XX:+/-UseTLAB</code>参数来设定。</li>
</ul>
</li>
<li><p><strong>初始化分配到的课件</strong></p>
<p>内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
</li>
<li><p><strong>设置对象的对象头</strong></p>
<p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
</li>
<li><p><strong>执行init方法进行初始化</strong></p>
<p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。<br>因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p>
</li>
</ol>
<p>测试对象实例化的过程:</p>
<p>① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）- ⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化</p>
<p>给对象的属性赋值的操作：</p>
<p>① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200708143637.png"  alt="对象的内存布局"></p>
<p>程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Customer cust = <span class="keyword">new</span> Customer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">"匿名客户"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> Account();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200708143930.png"  alt="对象的内存布局"></p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>JVM是如何通过栈帧中的对象引用访问到对象实例的呢？</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200708145032.png"  alt="对象定位访问"></p>
<h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200708145145.png"  alt="句柄访问"></p>
<blockquote>
<p>reference中存储文档句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p>
</blockquote>
<h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>HotSpot采用直接指针方式</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200708145346.png"  alt="直接指针"></p>
<h2 id="直接内存（补充）"><a href="#直接内存（补充）" class="headerlink" title="直接内存（补充）"></a>直接内存（补充）</h2><h3 id="直接内存概述"><a href="#直接内存概述" class="headerlink" title="直接内存概述"></a>直接内存概述</h3><ul>
<li>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</li>
<li>直接内存是在Java堆外的、直接向系统申请的内存区间。</li>
<li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li>
<li>通常，访问直接内存的速度会优于Java堆。即读写性能高。<ul>
<li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存</li>
<li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li>
</ul>
</li>
</ul>
<p><strong>查看直接内存的占用与释放</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//1GB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//直接分配本地内存空间</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">        System.out.println(<span class="string">"直接内存分配完毕，请求指示！"</span>);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        scanner.next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"直接内存开始释放！"</span>);</span><br><span class="line">        byteBuffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200708150329.png"  alt="直接内存"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200708150449.png"  alt="非直接缓冲区"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200708150531.png"  alt="直接缓冲区"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TO = <span class="string">"F:\\test\\异界BD中字.mp4"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _100Mb = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        String src = <span class="string">"F:\\test\\异界BD中字.mp4"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            String dest = <span class="string">"F:\\test\\异界BD中字_"</span> + i + <span class="string">".mp4"</span>;</span><br><span class="line"><span class="comment">//            sum += io(src,dest);//54606</span></span><br><span class="line">            sum += directBuffer(src, dest);<span class="comment">//50244</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"总花费的时间为："</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">directBuffer</span><span class="params">(String src, String dest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        FileChannel inChannel = <span class="keyword">null</span>;</span><br><span class="line">        FileChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inChannel = <span class="keyword">new</span> FileInputStream(src).getChannel();</span><br><span class="line">            outChannel = <span class="keyword">new</span> FileOutputStream(dest).getChannel();</span><br><span class="line"></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_100Mb);</span><br><span class="line">            <span class="keyword">while</span> (inChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">                byteBuffer.flip();<span class="comment">//修改为读数据模式</span></span><br><span class="line">                outChannel.write(byteBuffer);</span><br><span class="line">                byteBuffer.clear();<span class="comment">//清空</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">io</span><span class="params">(String src, String dest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(dest);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[_100Mb];</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = fis.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="直接内存的OOM与内存大小的设置"><a href="#直接内存的OOM与内存大小的设置" class="headerlink" title="直接内存的OOM与内存大小的设置"></a>直接内存的OOM与内存大小的设置</h3><ul>
<li>直接内存也可能导致OutOfMemoryError异常</li>
<li>由于直接内存存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是优先的，Java堆和直接内存的总和依旧受限于操作系统能给出的最大内存</li>
<li>缺点<ul>
<li>分配回收成本较高</li>
<li>不受JVM内存回收管理</li>
</ul>
</li>
<li>直接内存大小可以通过MaxDirectMemorySize设置</li>
<li>如果不知道，默认与堆的最大值-Xmx参数值一致</li>
</ul>
<p>演示OOM：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">20</span>;<span class="comment">//20MB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;ByteBuffer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">                list.add(byteBuffer);</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>设置直接内存大小：<code>-Xmx20m -XX:MaxDirectMemorySize=10m</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xmx20m -XX:MaxDirectMemorySize=10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxDirectMemorySizeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200708151436.png"  alt="直接内存OOM异常"></p>
<h1 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h1><h1 id="执行引擎（Execution-Engine）"><a href="#执行引擎（Execution-Engine）" class="headerlink" title="执行引擎（Execution Engine）"></a>执行引擎（Execution Engine）</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200709175433.png"  alt="执行引擎的位置"></p>
<ul>
<li>执行引擎是Java虚拟机核心的组成部分之一</li>
<li>Interpretr：解释器，JIT Compiler：编译器，Garbage Collection：垃圾收集器</li>
<li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此不受物理条件制约地制定指令集与执行引擎的结构体系，<strong>能够执行那些不被硬件直接支持的指令集格式</strong></li>
</ul>
<p>JVM的主要任务是<strong>负责装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</p>
<p>那么，如果想要让一个Java程序运行起来，执行引擎(Execution Engine)的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVW中的<strong>执行引擎充当了将高级语言翻译为机器语言的译者</strong>。</p>
<p><strong>执行引擎工作过程：</strong></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200709180207.png"  alt="执行引擎工作过程"></p>
<p>1）执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于pc寄存器</p>
<p>2）每当执行完一项指令操作后，pc寄存器就会更新下一条需要被执行的指令地址</p>
<p>3）当然方法在执行的过程中，执行引擎有可能会通过存储在<strong>局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息</strong>，以及通过<strong>对象头中的元数据指针定位到目标对象的类型信息</strong></p>
<p>从外观上来看，所有Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果</p>
<h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200709180629.png"  alt="Java代码编译和执行过程"></p>
<p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图的各个步骤。</p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>Java代码编译是由Java源码<strong>编译器</strong>来完成，流程图如下：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200709180830.png"  alt="Java代码编译过程"></p>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200709180919.png"  alt="Java字节码执行过程"></p>
<p><strong>问题：什么是解释器（Interpreter），什么是JIT编译器？</strong></p>
<p>解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行</p>
<p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言</p>
<p><strong>问题：为什么说Java是半编译半解释型语言？</strong></p>
<p>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常会将解释执行与编译执行二者结合起来进行</p>
<p><strong>问题：方法区（Method Area存储）什么？</strong></p>
<p>《深入理解Java虚拟机》树中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200709181950.png"  alt="方法区存放的内容"></p>
<h2 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h2><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200709182116.png"  alt="代码执行过程"></p>
<h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><ul>
<li>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</li>
<li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li>
<li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li>
<li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li>
</ul>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul>
<li>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令</li>
<li>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</li>
<li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov)，对应的机器码也可能不同</li>
</ul>
<h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><ul>
<li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</li>
<li>如常见的：<ul>
<li>x86指令集，对应的是x86架构的平台</li>
<li>ARM指令集，对应的是ARM架构的平台</li>
</ul>
</li>
</ul>
<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ul>
<li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li>
<li>在汇编语言中，用<strong>助记符</strong>(Mnemonics)代替机器指令的<strong>操作码</strong>，用<strong>地址符号（Symbol)或标号(Label)</strong>代替<strong>指令或操作数的地址</strong></li>
<li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。<ul>
<li>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</li>
</ul>
</li>
</ul>
<h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ul>
<li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</li>
<li>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做<strong>解释程序</strong>或<strong>编译程序</strong>。</li>
</ul>
<h4 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h4><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200709183445.png"  alt="C、C++程序执行过程"></p>
<p>编译过程又可以分成两个阶段：编译和汇编</p>
<ul>
<li>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</li>
<li>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程</li>
</ul>
<h3 id="字节码-1"><a href="#字节码-1" class="headerlink" title="字节码"></a>字节码</h3><ul>
<li>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</li>
<li>字节码主要为了实现特定软件运行和软件环境、<strong>与硬件环境无关</strong></li>
<li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令<ul>
<li>字节码的典型应用为Java bytecode</li>
</ul>
</li>
</ul>
<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>设计者们的初衷仅仅只是单纯地<strong>为了满足Java程序实现跨平台特性</strong>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>
<h3 id="解释器工作机制（工作任务）"><a href="#解释器工作机制（工作任务）" class="headerlink" title="解释器工作机制（工作任务）"></a>解释器工作机制（工作任务）</h3><ul>
<li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行</li>
<li>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作</li>
</ul>
<h3 id="解释器分类"><a href="#解释器分类" class="headerlink" title="解释器分类"></a>解释器分类</h3><p>在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p>
<ul>
<li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</li>
<li>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。<ul>
<li>在Hotspot VM中，解释器主要由Interpreter模块和code模块构成<ul>
<li>Interpreter模块：实现了解释器的核心功能</li>
<li>code模块：用于管理Hotspot VM在运行时生成的本地机器指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="现状-1"><a href="#现状-1" class="headerlink" title="现状"></a>现状</h3><ul>
<li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行己经沦落为低效的代名词，并且时常被一些c/c++程序员所调侃。</li>
<li>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</li>
<li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li>
</ul>
<h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><h3 id="Java代码执行分类"><a href="#Java代码执行分类" class="headerlink" title="Java代码执行分类"></a>Java代码执行分类</h3><ul>
<li>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</li>
<li>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术(JIT,Just In Time）将方法编译成机器码后再执行</li>
<li>Hotspot VM是目前市面上高性能虚拟机的代表作之一。它<strong>采用解释器与即时编译器并存</strong>的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</li>
<li>在今天，Java程序的运行性能早己脱胎换骨，己经达到了可以和c/c++程序一较高下的地步。</li>
</ul>
<p><strong>问题：</strong></p>
<p>有些开发人员会感觉到诧异，既然Hotspot中己经内置JIT编译器了，那么<strong>为什么还需要再使用解释器来“拖累”程序的执行性能呢？</strong>比如。Ck主t内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p>
<p>首先明确，当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
<p>所以，尽管JRockit中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</p>
<p>在此模式下，<strong>当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</strong></p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”</p>
<h3 id="HotSpot-JVM的执行方式"><a href="#HotSpot-JVM的执行方式" class="headerlink" title="HotSpot JVM的执行方式"></a>HotSpot JVM的执行方式</h3><p>当虚拟机启动的时候，<strong>解释器可以首先发挥作用</strong>，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的<br>推移，即时编译器逐渐发挥作用，根据热点探测功能，<strong>将有价值的字节码编译为本地机器指令</strong>，以换取更高的程序执行效率。</p>
<p><strong>案例：</strong></p>
<p>注意解释执行与编译执行在线上环境微妙的辩证关糸。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p>
<p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。一阿里团队</p>
<h3 id="JIT相关概念"><a href="#JIT相关概念" class="headerlink" title="JIT相关概念"></a>JIT相关概念</h3><ul>
<li>Java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个<strong>前端编译器</strong>（其实叫“编译器的前端”更准确一些）把 .java文件转变成.class文件的过程</li>
<li>也可能是指虚拟机的<strong>后端运行期编译器</strong>JIT编译器(Just In Time Compiler)把字节码转变成机器码的过程</li>
<li>还可能是指使用<strong>静态提前编译器</strong>(AOT编译器，Ahead Of Time Compiler)直接把 .java文件编译成本地机器代码的过程</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200709195010.png"  alt="不同的编译器"></p>
<h3 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h3><p><strong>热点代码：</strong></p>
<p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<strong>执行的频率</strong>而定。关于那些需要被编译为本地代码的字节码，也被称之为“<strong>热点代码</strong>”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p>
<p><strong>探测方式：</strong></p>
<ul>
<li><strong>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</strong>，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为<strong>OSR（On Stack Replacement)编译</strong>。</li>
<li>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能</li>
<li>目前Hotspot VM所采用的热点探测方式是<strong>基于计数器的热点探测</strong></li>
<li>采用基于计数器的热点探测，Hotspot VM将会为每一个方法都建立2个不同类型的计数器，分别为<strong>方法调用计数器</strong>（Invocation Counter）和<strong>回边计数器</strong>(Back Edge Counter)<ul>
<li>方法调用计数器用于统计方法的调用次数</li>
<li>回边计数器则用于统计循环体执行的循环次数</li>
</ul>
</li>
</ul>
<h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><ul>
<li>这个计数器就用于统计方法被调用的次数，它的默认阈值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</li>
<li>这个阈值可以通过虚拟机参数 <code>-XX:CompileThreshold</code>来人为设定。</li>
<li>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在己被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果己超过阈值，那么将会向即<br>时编译器提交一个该方法的代码编译请求。</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200709195943.png"  alt="解释执行+及时编译"></p>
<p><strong>热度衰减</strong></p>
<ul>
<li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<strong>衰减（Counter Decay)</strong>，而这段时间就称为此方法统计的半衰周期(Counter Half Life Time)。</li>
<li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<code>-XX:UseCounterDecay</code>来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码</li>
<li>另外，可以使用<code>-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</li>
</ul>
<h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Egde）。显然，<strong>建立回边计数器统计的目的就是为了出发OSR编译</strong></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200709200550.png"  alt="回边计数器"></p>
<h3 id="设置HotSpot-VM程序执行方式"><a href="#设置HotSpot-VM程序执行方式" class="headerlink" title="设置HotSpot VM程序执行方式"></a>设置HotSpot VM程序执行方式</h3><p>缺省情况下Hotspot是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p>
<ul>
<li>-Xint：完全采用解释器模式执行程序</li>
<li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li>
<li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试解释器模式和JIT编译模式</span></span><br><span class="line"><span class="comment"> * -Xint  : 6975ms</span></span><br><span class="line"><span class="comment"> * -Xcomp : 1054ms</span></span><br><span class="line"><span class="comment"> * -Xmixed : 1103ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntCompTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        testPrimeNumber(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"花费的时间为："</span> + (end - start) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPrimeNumber</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">//计算100以内的质数</span></span><br><span class="line">            label:</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= Math.sqrt(j); k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j % k == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span> label;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="HotSpot-VM中JIT分类"><a href="#HotSpot-VM中JIT分类" class="headerlink" title="HotSpot VM中JIT分类"></a>HotSpot VM中JIT分类</h3><p>在Hotspot中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<ul>
<li>-client：指定Java虚拟机运行在Client模式下，并使用Cl编译器<ul>
<li>C1编译器会对字节码进行<strong>简单和可靠的优化，耗时短，以达到更快的编译速度</strong></li>
</ul>
</li>
<li>-server：指定Java虚拟机运行在Server模式下，并使用C2编译器<ul>
<li>C2进行<strong>耗时较长的优化，以及激进优化，但优化的代码执行效率更高</strong></li>
</ul>
</li>
</ul>
<h4 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h4><ul>
<li>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、冗余消除<ul>
<li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li>
<li>去虚拟化：对唯一的实现类进行内联</li>
<li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
</li>
<li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：<ul>
<li>标量替换：用标量值代替聚合对象的属性值</li>
<li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li>
<li>同步消除：清除同步操作，通常指synchronized</li>
</ul>
</li>
</ul>
<h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p><strong>分层编译(Tiered Compilation)策略</strong>：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p>
<p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令”-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>一般来讲，JIT编译出来的机器码性能比解释器高</li>
<li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器</li>
</ul>
<h2 id="拓展：Graal编译器和AOT编译器"><a href="#拓展：Graal编译器和AOT编译器" class="headerlink" title="拓展：Graal编译器和AOT编译器"></a>拓展：Graal编译器和AOT编译器</h2><h3 id="Graal编译器"><a href="#Graal编译器" class="headerlink" title="Graal编译器"></a>Graal编译器</h3><ul>
<li>自JDK10起，HotSpot又加入一个全新的即时编译器：Graal编译器</li>
<li>编译效果短短几年时间就追平了C2编译器，未来可期</li>
<li>目前，带着“实验状态”标签，需要使用开关参数<ul>
<li>-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiIer 去激活，才可以使用</li>
</ul>
</li>
</ul>
<h3 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h3><ul>
<li>jdk9引入了AOT编译器（静态提前编译器，Ahead Of Time Compiler)</li>
<li>Java9引入了实验性AOT编译工具jaotco，它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中</li>
<li>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部<br>署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</li>
<li>最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验</li>
<li>缺点：<ul>
<li>破坏了Java“一次编译，到处运行”，必须为每个不同硬件、OS编译对应的发行包</li>
<li>降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知</li>
<li>还需要继续优化中，最初只支持Linux x64 java base</li>
</ul>
</li>
</ul>
<h1 id="垃圾回收器（Garbage-Collection）"><a href="#垃圾回收器（Garbage-Collection）" class="headerlink" title="垃圾回收器（Garbage Collection）"></a>垃圾回收器（Garbage Collection）</h1><h2 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h2><h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h3><ul>
<li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生</li>
<li>关于垃圾收集有三个经典问题：<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
</li>
<li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃<br>圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点</li>
</ul>
<p><strong>GC相关面试题</strong></p>
<p><strong>蚂蚁金服：</strong><br>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和g1<br>一面：JVM GC算法有哪些，目前的JDK版本采用什么回收算法<br>一面：G1回收器讲下回收过程<br>GC是什么？为什么要有GC？<br>一面：GC的两种判定方法？CMS收集器与G1收集器的特点<br><strong>百度：</strong><br>说一下GC算法，分代回收说下<br>垃圾收集策略和算法<br><strong>天猫：</strong><br>一面：jvm GC原理，JVM怎么回收内存<br>一面：CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？<br><strong>滴滴：</strong><br>一面：java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的<br><strong>京东：</strong><br>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点<br>垃圾回收算法的实现原理<br><strong>阿里：</strong><br>讲一讲垃圾回收算法。<br>什么情况下触发垃圾回收？<br>如何选择合适的垃圾收集算法？<br>JVM有哪三种垃圾回收器？<br><strong>字节跳动：</strong><br>常见的垃圾回收器算法有哪些，各有什么优劣？<br>system.gc()和runtime.gc()会做什么事情？<br>一面：JavaGC机制？GC Roots有哪些？<br>二面：Java对象的回收方式，回收算法<br>CMS和G1了解么，CMS解决什么问题，说一下回收的过程<br>CMS回收停顿了几次，为什么要停顿两次</p>
<p><strong>什么是垃圾？</strong></p>
<ul>
<li>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾</li>
<li>An object is considered garbage when it can no longer be reached from any pointer in the running program.</li>
<li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用，甚至可能导致内存溢出</li>
</ul>
<h3 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h3><p><strong>想要学习GC，首先需理解为什么需要GC？</strong></p>
<ul>
<li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样</li>
<li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便将整理出的内存分配给新的对象</li>
<li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化</li>
</ul>
<h3 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h3><ul>
<li><p>在早期的c/c++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200710112503.png"  alt="早起垃圾回收"></p>
</li>
<li><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问題忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。在有了垃圾回收机制后，上述代码块极有可能变成这样：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200710112529.png"  alt="有了垃圾回收机制之后"></p>
</li>
<li><p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准</p>
</li>
</ul>
<h3 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h3><ul>
<li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样<strong>降低内存泄漏和内存溢出的风险</strong><ul>
<li>没有垃圾回收器，java也会和cpp—样，各种悬垂指针，野指针，池露问题让你头疼不已</li>
</ul>
</li>
<li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</li>
<li>Oracle官网关于垃圾回收的介绍：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/tochtml" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/tochtml</a></li>
</ul>
<p><strong>担忧</strong></p>
<ul>
<li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问題和解决问題的能力。</li>
<li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见Out Of MemoryError时，快速地根据错误异常日志定位问题和解决问题</li>
<li>当需要排查各种内存溢出、内存泄漏问題时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节</li>
</ul>
<p><strong>GC回收的区域</strong></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200710113015.png"  alt="GC回收的区域"></p>
<ul>
<li>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区回收<ul>
<li>其中，Java堆是垃圾收集器的工作重点</li>
</ul>
</li>
<li>从次数上来讲<ul>
<li>频繁收集Young区</li>
<li>较少收集Old区</li>
<li>基本不动Perm区（元空间）</li>
</ul>
</li>
</ul>
<h2 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h2><h3 id="垃圾标记阶段"><a href="#垃圾标记阶段" class="headerlink" title="垃圾标记阶段"></a>垃圾标记阶段</h3><p>垃圾标记阶段就是对象判活的阶段</p>
<ul>
<li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是己经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</li>
<li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象己经不再被任何的存活对象继续引用时，就可以宣判为己经死亡。</li>
<li>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</li>
</ul>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><ul>
<li>引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况</li>
<li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收</li>
<li>优点：实现简单，垃圾对象便于辨识，判定效率高，回收没有延迟性</li>
<li>缺点：<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong></li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增<strong>加了时间开销</strong></li>
<li>引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法</li>
</ul>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200710114117.png"  alt="循环引用"></p>
<p>如何证明Java不是使用引用计数法的呢？可以通过GC日志查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 证明：java使用的不是引用计数算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefCountGC</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个成员属性唯一的作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//5MB</span></span><br><span class="line"></span><br><span class="line">    Object reference = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RefCountGC obj1 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        RefCountGC obj2 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line"></span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line">        obj2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//显式的执行垃圾回收行为</span></span><br><span class="line">        <span class="comment">//这里发生GC，obj1和obj2能否被回收？</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试不发生GC行为的时候日志打印</span></span><br><span class="line">        <span class="comment">//System.gc();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测不打开System.gc();的日志情况：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200710115419.png"  alt="不回收的情况"></p>
<p>可以发现在不主动gc的情况下，对象obj1和obj2分配在了年轻代的伊甸园区，使用量20M</p>
<p>打开System.gc();的日志情况：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200710115628.png"  alt="打开gc主动回收"></p>
<p>可以发现打开gc回收之后，年轻代空间使用量已经1M左右，放不下obj对象了，所以证明对象已经被回收了。因此可以说java使用的不是引用计数算法。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul>
<li><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p>
</li>
<li><p>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集(Tracing Garbage Collection)。</p>
</li>
<li><p>所谓”GC Roots”根集合就是一组必须活跃的引用。</p>
</li>
<li><p>基本思路：</p>
<ul>
<li>可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达</li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)</li>
<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象</li>
</ul>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200710121313.png"  alt="可达性分析算法"></p>
<p><strong>GC Roots可以包含以下几类元素</strong></p>
<ul>
<li>虚拟机栈中引用的对象<ul>
<li>比如：各个线程被调用方法中使用到的参数、局部变量等</li>
</ul>
</li>
<li>本地方法栈内JNI（通常说的本地方法）引用的对象</li>
<li>方法区中类静态属性引用的对象<ul>
<li>比如：Java类的引用类型静态变量</li>
</ul>
</li>
<li>方法区中常量引用的对象<ul>
<li>比如：字符串常量池(String Table)里的引用</li>
</ul>
</li>
<li>所有被同步锁synchrnized持有的对象</li>
<li>Java虚拟机内部的引用<ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError)，系统类加载器</li>
</ul>
</li>
<li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
<li>除了这些固定的Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收(Partial GC)<ul>
<li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性</li>
</ul>
</li>
<li>小技巧：<br>由于Root采用方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证</li>
<li>这点也是导致GC进行时必须”Stop The World“的一个重要原因<ul>
<li>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的</li>
</ul>
</li>
</ul>
<h3 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h3><ul>
<li>Java语言提供了对象终止(finalization)机制来允许开发人员提供对象被销毁之前的自定义处理逻辑</li>
<li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</li>
<li>finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等</li>
<li>这个方法应该交给垃圾回收机制调用。理山包括下面三点：永远不要主动调用某个对象的finalize0方法<ul>
<li>在finalize0时可能会导致对象复活</li>
<li>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会</li>
<li>一个糟糕的finalize()会严重影响GC的性能</li>
</ul>
</li>
<li>从功能上来说，finalize0方法与c++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize0方法在本质上不同于c++中的析构函数。</li>
<li>由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态</li>
</ul>
<h4 id="对象的三种存在状态"><a href="#对象的三种存在状态" class="headerlink" title="对象的三种存在状态"></a>对象的三种存在状态</h4><ul>
<li>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：<ul>
<li>可触及的：从根节点开始，可以到达这个对象</li>
<li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize0中复活</li>
<li>不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。<strong>不可触及的对象不可能被复活</strong>，因为finalize()只会被调用一次</li>
</ul>
</li>
<li>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收</li>
</ul>
<p><strong>具体过程：</strong></p>
<p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p>
<ol>
<li>如果对象objA到GC Roots没有引用链，则进行第一次标记</li>
<li>进行筛选，判断此对象是否有必要执行finalize()方法<ol>
<li>如果对象objA没有重写finalize()方法，或者finalize()方法己经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li>
<li>如果对象obj重写了finalze()方法，且还未执行过，那么objA会被插入到F-Queue队列中，生一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行</li>
<li><strong>finalize()方法是对象逃脱死亡的最后机会</strong>，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，<strong>一个对象的finalize方法只会被调用一次</strong></li>
</ol>
</li>
</ol>
<p><strong>代码演示可复活的对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Object类中finalize()方法，即对象的finalization机制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanReliveObj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj;<span class="comment">//类变量，属于 GC Root</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法只能被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"调用当前类重写的finalize()方法"</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> CanReliveObj();</span><br><span class="line">            <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc();<span class="comment">//调用垃圾回收器</span></span><br><span class="line">            System.out.println(<span class="string">"第1次 gc"</span>);</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第2次 gc"</span>);</span><br><span class="line">            <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<blockquote>
<p>调用当前类重写的finalize()方法<br>第1次 gc<br>obj is still alive<br>第2次 gc<br>obj is dead</p>
</blockquote>
<p>如果将方法<code>finalize</code>中<code>obj=this</code>这个注释了，则日志输出：</p>
<blockquote>
<p>第1次 gc<br>调用当前类重写的finalize()方法<br>obj is dead<br>第2次 gc<br>obj is dead</p>
</blockquote>
<h3 id="垃圾清除阶段"><a href="#垃圾清除阶段" class="headerlink" title="垃圾清除阶段"></a>垃圾清除阶段</h3><ul>
<li>标记-清除算法</li>
<li>复制算法</li>
<li>标记整理算法</li>
</ul>
<p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。<br>目前在JVM中比较常见的三种垃圾收集算法是标记-清除算法（Mark-sweep）、复制算法（Copying）、标记-压缩算法（Mark-Compact）</p>
<h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>背景：<br>标记一清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于Lisp语言。</p>
<p>执行过程：<br>当堆中的有效内存空间(available memory)被耗尽的时候，就会停止整个程序（也被称stop the world)，然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<ul>
<li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</li>
<li>清除：Colllector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200710142641.png"  alt="标记清除算法"></p>
<p>标记清除算法的缺点：</p>
<ul>
<li>效率不高</li>
<li>在进行GC的时候，需要停止整个应用程序，导致用户体验差</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内存碎片，需要维护一个空闲表</li>
</ul>
<p>何为清除？</p>
<ul>
<li>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲地址表里，下次有新对象需要加载时，判断垃圾的位置空间是否足够，如果够就存放，回顾上一节中讲对象的实例化，创建对象的步骤-为对象分配内存的两种方式（指针碰撞、空闲列表分配）</li>
</ul>
<h4 id="复制算法（Coping）"><a href="#复制算法（Coping）" class="headerlink" title="复制算法（Coping）"></a>复制算法（Coping）</h4><p>背景：<br>为了解决标记-清除算法在垃圾收集效率方面的缺陷M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial SecondaryStorage）“。 M.L.Minsky在该论文中描述的算法被人们称为复制(Copying)算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p>
<p>核心思想：<br>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200710143408.png"  alt="复制算法"></p>
<p>优点：</p>
<ul>
<li><p>没有标记和清除过程，实现简单，运行高效</p>
</li>
<li><p>复制过去以后保证空间的连续性，不会出现“碎片”问题</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间</li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。特别的，<br>如果系统中的垃圾对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。【待验证这种说法】</li>
</ul>
<p>应用场景：</p>
<p>在新生代，对常规应用的垃圾回收，一次通常可以回收70%-99%的内存空间。回收性价比很高，所以现在的商业虚拟机都是用这种收集算法回收新生代</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200710143954.png"  alt="新生代垃圾回收"></p>
<h4 id="标记-整理算法（Mark-Compat）"><a href="#标记-整理算法（Mark-Compat）" class="headerlink" title="标记-整理算法（Mark-Compat）"></a>标记-整理算法（Mark-Compat）</h4><p><strong>背景：</strong><br>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基了老年代垃圾回收的特性，需要使用其他的算法。</p>
<p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进，标记-压缩(Mark_Compact）算法由此诞生。</p>
<p>1970年前后，G.L.Steele、c.J.Chene和D.S.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记一压缩算法或其改进版本。</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200710144318.png"  alt="标记-整理算法"></p>
<p><strong>执行过程：</strong></p>
<ul>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li>
<li>第二阶段将所有的存活对象压缩到内存的一段，按照顺序排放</li>
<li>之后，清理边界外的所有空间</li>
</ul>
<p><strong>回顾指针碰撞（Bump the Pointer）：</strong></p>
<p>如果内存空间以规整和有序的方式分布，即己用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，<br>只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump the Pointer)。</p>
<p><strong>标记-整理算法优缺点</strong></p>
<ul>
<li>优点<ul>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新分配的对象分配内存时，JVM只需要持有一个内存的起始地址即可</li>
<li>消除了复制算法当中，内存减半的高额代价</li>
</ul>
</li>
<li>缺点<ul>
<li>从效率上来说，标记-整理算法要低于复制算法</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li>
<li>移动过程中国，需要全程暂停用户程序，即STW</li>
</ul>
</li>
</ul>
<h3 id="三种清除算法对比"><a href="#三种清除算法对比" class="headerlink" title="三种清除算法对比"></a>三种清除算法对比</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200710145038.png"  alt="三种清除算法对比"></p>
<p>效率上来讲，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>
<p>而为了进来兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存阶段</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点，分代收集算法应运而生。</p>
<p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<strong>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率</strong>。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p><strong>目前几乎所有的GC都是采用分代收集（Generational Collecting）算法执行垃圾回收的。</strong></p>
<p>在Hotspot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ul>
<li>年轻代(Young Gen)<br>年轻代特点:区域相对老年代较小，对象生命周期短、存活率低，回收频繁<br>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复到算法内存利用不高的问题，通过hotspot中的两个Survivor的设计得到缓解。</li>
<li>老年代(Tenured Gen)<br>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁<br>这种情况存在大量存活率高的对象，复制算法明显变得不合适，一般是由标记-清除或者是标记-清除与标记-整理的混合实现<ul>
<li>Mark阶段的开销与存活对象的数量成正比</li>
<li>Sweep阶段的开销与所管理区域的大小成正相关</li>
<li>Compat阶段的开销与存活对象的数据成正比</li>
</ul>
</li>
</ul>
<p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old<br>回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p>
<h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种STW的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting)算法的诞生。</p>
<p><strong>基本思想：</strong><br>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p>
<p><strong>缺点：</strong></p>
<p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
<h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
<p><strong>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间</strong>。</p>
<p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200710150945.png"  alt="分区算法"></p>
<blockquote>
<p>最后，注意这些只是基本的算法死了，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>
</blockquote>
<h2 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h2><h3 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a>System.gc()的理解</h3><p><strong>System.gc()的理解</strong></p>
<ul>
<li>在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，<strong>会显式触发Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</li>
<li>然而system.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。</li>
<li>JVM实现者可以通过system.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemGCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemGCTest();</span><br><span class="line">        System.gc();<span class="comment">//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc</span></span><br><span class="line">        <span class="comment">//与Runtime.getRuntime().gc();的作用一样。</span></span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"SystemGCTest 重写了finalize()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次运行发现日志有时候会打印，“SystemGCTest 重写了finalize()”，有时候什么也不输出。</p>
<p>可以通过调用“System.runFinalization()”，强制调用使用引用的对象的finalize()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemGCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemGCTest();</span><br><span class="line">        System.gc();<span class="comment">//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc</span></span><br><span class="line">        <span class="comment">//与Runtime.getRuntime().gc();的作用一样。</span></span><br><span class="line">        System.runFinalization();<span class="comment">//强制调用使用引用的对象的finalize()方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"SystemGCTest 重写了finalize()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>手动GC理解不可达对象的回收行为</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVarGC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10MB</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        localvarGC1();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVarGC local = <span class="keyword">new</span> LocalVarGC();</span><br><span class="line"><span class="comment">//        local.localvarGC1();//没有回收</span></span><br><span class="line"><span class="comment">//        local.localvarGC2();//回收了</span></span><br><span class="line"><span class="comment">//        local.localvarGC3();//没有回收</span></span><br><span class="line"><span class="comment">//        local.localvarGC4();//没有回收</span></span><br><span class="line">        local.localvarGC5();<span class="comment">////回收了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h3><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul>
<li><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一</p>
</li>
<li><p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收己经跟不上内存消耗的速度，否则不太容易出现OOM的情况</p>
</li>
<li><p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用</p>
</li>
<li><p>javadoc中对OutofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存</p>
</li>
<li><p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二<br>（1）Java虚拟机的堆内存设置不够。</p>
<p>​            比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定堆大小或者指定数值偏小。我们可以通过参数-Xms、-Xmx来调整</p>
<p>（2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p>
<p>​        对于老版本的OracleJDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题：对应的异常倌息，会标记出来和永久代相关：”java.lang.OutOfMemoryError：PermGen space”。</p>
<p>随着元数据区的引入，方法区内存己经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：”java.lang.OutOfMemoryError:Metaspace”。直接内存不足，也会导致OOM。</p>
</li>
<li><p>这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间</p>
<ul>
<li>例如：在引用机制分析中，涉及到JVM会去尝回收软引用指向的对象等</li>
<li>在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间</li>
</ul>
</li>
<li><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>
<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError</li>
</ul>
</li>
</ul>
<h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”</p>
<p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃</p>
<p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>
<p><strong>内存泄露举例</strong></p>
<p>1、单例模式<br>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生<br>2、一些提供close的资源未关闭导致内存泄漏<br>数据库连接（datasourse.getConnection），网络连接（socket）和IO连接必须手动close，否则是不能被回收的</p>
<h3 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop the World"></a>Stop the World</h3><ul>
<li>Stop-the-world，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。<ul>
<li>可达性分析算法中枚举根节点（GCRoots）会导致所有Java执行线程停顿。<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</li>
</ul>
</li>
</ul>
</li>
<li>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生</li>
<li>STW事件和采用哪款GC无关，所有的GC都有这个事件</li>
<li>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间</li>
<li>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</li>
<li>开发中不要用System.gc()；会导致Stop-the-world的发生。</li>
</ul>
<p>代码演示STW：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopTheWorldDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++)&#123;</span><br><span class="line">                        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        list.add(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(list.size() &gt; <span class="number">10000</span>)&#123;</span><br><span class="line">                        list.clear();</span><br><span class="line">                        System.gc();<span class="comment">//会触发full gc，进而会出现STW事件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 每秒打印时间信息</span></span><br><span class="line">                    <span class="keyword">long</span> t = System.currentTimeMillis() - startTime;</span><br><span class="line">                    System.out.println(t / <span class="number">1000</span> + <span class="string">"."</span> + t % <span class="number">1000</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WorkThread w = <span class="keyword">new</span> WorkThread();</span><br><span class="line">        PrintThread p = <span class="keyword">new</span> PrintThread();</span><br><span class="line">        w.start();</span><br><span class="line">        p.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>0.1<br>1.7<br>2.10<br>3.12<br>4.13<br>5.15<br>6.16<br>7.17<br>8.18<br>9.19</p>
</blockquote>
<h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><h4 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h4><ul>
<li>在操作系统中，是指一个时间段中有几个程序都除以已启动运行到运行完毕之间，且这几个程序都是在同一处理器上运行的</li>
<li>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成为几个时间片段（时间区间），然后在这个几个时间区间上来回切换，由于CPU处理速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200714150421.png"  alt="并发"></p>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><ul>
<li>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占源，可以同时进行，我们称之为并行(Parallel）</li>
<li>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行</li>
<li>适合科学计算，后台处理等弱交互场景</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200714151124.png"  alt="并行"></p>
<p><strong>二者对比：</strong><br>并发，指的是多个事情，在同一时间段内同时发生了。<br>并行，指的是多个事情，在同一时间点上同时发生了。</p>
<p>并发的多个任务之间是互相抢占资源的。<br>并行的多个任务之间是不互相抢占资源的。</p>
<p>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</p>
<p><strong>垃圾回收的并行与并发：</strong></p>
<p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<ul>
<li>并行(Parallel)：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<ul>
<li>如ParNew、Parallel Scavenge、Parallel Old</li>
</ul>
</li>
<li>串行(Serial)<ul>
<li>相较于并行的概念，单线程执行</li>
<li>如果内存不够，则程序暂停，启动垃圾回收器进行垃圾回收。回收完，再启动程序的线程</li>
</ul>
</li>
<li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。<ul>
<li>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上</li>
<li>如：CMS、G1</li>
</ul>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200714152509.png"  alt="并行和串行"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200714152530.png"  alt="STW与并发"></p>
<h3 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h3><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点(Safe Point）</p>
<p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p>
<p>如何在发生时，检查所有线程跑到最近的安全点停顿下来呢？</p>
<ul>
<li>抢先式中断：（目前没有虚拟机采用了）<br>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li>
<li>主动式中断：<br>设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</li>
</ul>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>Safe Point机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safe Point。但是，程序“不执行”的时候呢？例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。</p>
<p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safe Point</p>
<p><strong>实际执行时：</strong></p>
<p>1、当线程运行到Safe Region的代码时，首先标识己经进入了safe Region,如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程；<br>2、当线程即将离开Safe Region时，会检查JVM是否己经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中：如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>
<p>〖既偏门又非常高频的面试题〗强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p>
<p>在JDK1．2版之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference）、软引用（SoftReference)、弱引用(WeakReference)和虚引用(Phantom Reference)4种，这4种引用强度依次逐渐减弱。</p>
<p>除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200714155412.png"  alt="引用"></p>
<p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p>
<ul>
<li>强引用(StrongReference)：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似”Object obj=new Object()”这种引用关系：无论任何情况下，只要强引用关糸还存在，垃圾收集器就永远不会回收掉被引用的对象</li>
<li>软引用(SoftReference)：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常</li>
<li>弱引用(WeakReference)：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象</li>
<li>虚引用(PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
<h4 id="强引用—不回收"><a href="#强引用—不回收" class="headerlink" title="强引用—不回收"></a>强引用—不回收</h4><p>在Java程序中，最常见的引用类型是强引用（普通系统99％以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p>
<p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
<p>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强引用的测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello,World"</span>);</span><br><span class="line">        StringBuffer str1 = str;</span><br><span class="line"></span><br><span class="line">        str = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强引用特点：</p>
<ul>
<li>强引用可以直接访问目标对象</li>
<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指对象</li>
<li>强引用可能导致内存泄露</li>
</ul>
<h4 id="软引用—内存不足即回收"><a href="#软引用—内存不足即回收" class="headerlink" title="软引用—内存不足即回收"></a>软引用—内存不足即回收</h4><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue)。</p>
<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得己才清理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软引用的测试：内存不足即回收</span></span><br><span class="line"><span class="comment"> * -Xms10m -Xmx10m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[id="</span> + id + <span class="string">", name="</span> + name + <span class="string">"] "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象，建立软引用</span></span><br><span class="line">     	<span class="comment">//SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1, "song"));</span></span><br><span class="line">        <span class="comment">//上面的一行代码，等价于如下的三行代码</span></span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"song"</span>);</span><br><span class="line">        SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> SoftReference&lt;User&gt;(u1);</span><br><span class="line">        u1 = <span class="keyword">null</span>;<span class="comment">//取消强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从软引用中重新获得强引用对象</span></span><br><span class="line">        System.out.println(<span class="string">"从软引用中获得强引用对象:"</span>+userSoftRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"After GC:"</span>);</span><br><span class="line">        <span class="comment">//垃圾回收之后获得软引用中的对象</span></span><br><span class="line">        System.out.println(<span class="string">"GC之后从软引用中获得强引用对象:"</span>+userSoftRef.get());<span class="comment">//由于堆空间内存足够，所以不会回收软引用的可达对象。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200714203333.png"  alt="软引用"></p>
<p>结论是：由于内存足够，即使GC也不会回收软引用的对象。</p>
<p>这里我们模拟内存资源紧张、不够的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软引用的测试：内存不足即回收</span></span><br><span class="line"><span class="comment"> * -Xms10m -Xmx10m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[id="</span> + id + <span class="string">", name="</span> + name + <span class="string">"] "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象，建立软引用</span></span><br><span class="line">        <span class="comment">//SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1, "song"));</span></span><br><span class="line">        <span class="comment">//上面的一行代码，等价于如下的三行代码</span></span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"song"</span>);</span><br><span class="line">        SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> SoftReference&lt;User&gt;(u1);</span><br><span class="line">        u1 = <span class="keyword">null</span>;<span class="comment">//取消强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从软引用中重新获得强引用对象</span></span><br><span class="line">        System.out.println(<span class="string">"从软引用中获得强引用对象:"</span> + userSoftRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"After GC:"</span>);</span><br><span class="line">        <span class="comment">//垃圾回收之后获得软引用中的对象</span></span><br><span class="line">        System.out.println(<span class="string">"GC之后从软引用中获得强引用对象:"</span> + userSoftRef.get());<span class="comment">//由于堆空间内存足够，所以不会回收软引用的可达对象。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//让系统认为内存资源紧张、不够</span></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">7168</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//再次从软引用中获取数据</span></span><br><span class="line">            System.out.println(userSoftRef.get());<span class="comment">//在报OOM之前，垃圾回收器会回收软引用的可达对象。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码是：byte[] b = new byte[1024 * 7168];</p>
<p>日志输入：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200714203718.png"  alt="软引用"></p>
<p>没有报OOM的情况下，也有可能出现gc回收软引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//让系统认为内存资源紧张、不够</span></span><br><span class="line">    <span class="comment">//byte[] b = new byte[1024 * 7168];</span></span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">7168</span> - <span class="number">649</span> * <span class="number">1024</span>];</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//再次从软引用中获取数据</span></span><br><span class="line">    System.out.println(<span class="string">"finally中获取user:"</span>+userSoftRef.get());<span class="comment">//在报OOM之前，垃圾回收器会回收软引用的可达对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200714204024.png"  alt="软引用"></p>
<h4 id="弱引用—发现即回收"><a href="#弱引用—发现即回收" class="headerlink" title="弱引用—发现即回收"></a>弱引用—发现即回收</h4><p>弱引用也是用来描述那些非必需对象，被弱引用关联的对像只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此,并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
<p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
<p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 弱引用的测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[id="</span> + id + <span class="string">", name="</span> + name + <span class="string">"] "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造了弱引用</span></span><br><span class="line">        WeakReference&lt;User&gt; userWeakRef = <span class="keyword">new</span> WeakReference&lt;User&gt;(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"song"</span>));</span><br><span class="line">        <span class="comment">//从弱引用中重新获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 不管当前内存空间足够与否，都会回收它的内存</span></span><br><span class="line">        System.out.println(<span class="string">"After GC:"</span>);</span><br><span class="line">        <span class="comment">//重新尝试从弱引用中获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<blockquote>
<p>[id=1, name=song]<br>After GC:<br>null</p>
</blockquote>
<h4 id="虚引用—对象回收跟踪"><a href="#虚引用—对象回收跟踪" class="headerlink" title="虚引用—对象回收跟踪"></a>虚引用—对象回收跟踪</h4><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。</p>
<p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p>
<ul>
<li>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</li>
<li>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</li>
<li>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚引用的测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;<span class="comment">//当前类对象的声明</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="keyword">null</span>;<span class="comment">//引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"追踪垃圾回收过程：PhantomReferenceTest实例被GC了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; <span class="comment">//finalize()方法只能被调用一次！</span></span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"调用当前类的finalize()方法"</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> CheckRefQueue();</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> ReferenceQueue&lt;PhantomReferenceTest&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> PhantomReferenceTest();</span><br><span class="line">        <span class="comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> PhantomReference&lt;PhantomReferenceTest&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//不可获取虚引用中的对象</span></span><br><span class="line">            System.out.println(phantomRef.get());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将强引用去除</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj 是 null"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj 可用"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第 2 次 gc"</span>);</span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc(); <span class="comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj 是 null"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"obj 可用"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<blockquote>
<p>null<br>调用当前类的finalize()方法<br>obj 可用<br>第 2 次 gc<br>追踪垃圾回收过程：PhantomReferenceTest实例被GC了<br>obj 是 null</p>
</blockquote>
<h4 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h4><ul>
<li>它用以实现对象的finalize()方法，也可以称为终结器引用</li>
<li>无需手动编码，其内部配合引用队列使用</li>
<li>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象</li>
</ul>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h3><h4 id="垃圾回收器概述"><a href="#垃圾回收器概述" class="headerlink" title="垃圾回收器概述"></a>垃圾回收器概述</h4><ul>
<li>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现</li>
<li>由于JDK的版本处于高速迭代过程中，因此Java发展至今己经衍生了众多的GC版本</li>
<li>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</li>
</ul>
<p>Java不同版本的新特性研究角度：</p>
<ol>
<li>语法层面：Lambda表达式、switch、自动装箱拆箱、</li>
<li>API层面：Stream API、Optional、String、集合框架</li>
<li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池等</li>
</ol>
<h4 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h4><ul>
<li>按<strong>线程数</strong>分，可以分为<strong>串行垃圾回收器</strong>和<strong>并行垃圾回收器</strong></li>
<li>按<strong>工作模式</strong>分，可以分为<strong>并发式</strong>垃圾回收器和<strong>独占式</strong>垃圾回收器</li>
<li>按<strong>碎片处理</strong>方式分，可分为<strong>压缩式</strong>垃圾回收器和<strong>非压缩式</strong>垃圾回收器</li>
<li>按<strong>工作的内存区</strong>间分，可分为<strong>年轻代</strong>垃圾回收器和<strong>老年代</strong>垃圾回收器</li>
</ul>
<ul>
<li><p>按<strong>线程数</strong>分，可以分为<strong>串行垃圾回收器</strong>和<strong>并行垃圾回收器</strong></p>
<ul>
<li>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。<ul>
<li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用客户端的Client模式下的JVM中</li>
<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li>
</ul>
</li>
<li>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了 “Stop-the-world”机制。</li>
</ul>
</li>
<li><p>按<strong>工作模式</strong>分，可以分为<strong>并发式</strong>垃圾回收器和<strong>独占式</strong>垃圾回收器</p>
<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li>
<li>独占式垃圾回收器(Stop the world)一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束</li>
</ul>
</li>
<li><p>按<strong>碎片处理</strong>方式分，可分为<strong>压缩式</strong>垃圾回收器和<strong>非压缩式</strong>垃圾回收器</p>
<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片<ul>
<li>再分配对象空间使用：指针碰撞</li>
</ul>
</li>
<li>非压缩式的垃圾回收器不进行这步操作<ul>
<li>再分配对象空间使用：空闲列表</li>
</ul>
</li>
</ul>
</li>
<li><p>按<strong>工作的内存区</strong>间分，可分为<strong>年轻代</strong>垃圾回收器和<strong>老年代</strong>垃圾回收器</p>
</li>
</ul>
<h4 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h4><ul>
<li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例<ul>
<li>（总运行时间=程序的运行时间+内存回收的时间）</li>
</ul>
</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例</li>
<li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率</li>
<li><strong>内存占用</strong>：Java堆区所占的内存大小</li>
<li>快速：一个对象从埏生到被回收所经历的时间</li>
</ul>
<p>这三者（吞吐量、暂停时间、内存占用）共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好，一款优秀的收集器通常最多同时满足其中的两项。</p>
<p>这三项里，<strong>暂停时间</strong>的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p>
<p>简单来说，主要抓住两点：</p>
<ul>
<li>吞吐量</li>
<li>暂停时间</li>
</ul>
<h5 id="吞吐量-throughput"><a href="#吞吐量-throughput" class="headerlink" title="吞吐量(throughput)"></a>吞吐量(throughput)</h5><ul>
<li>吞吐量就是CPU用于运行用户码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）<ul>
<li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99％</li>
</ul>
</li>
<li>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</li>
<li>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=0.4</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200715203012.png"  alt="吞吐量"></p>
<h5 id="暂停时间-pause-time"><a href="#暂停时间-pause-time" class="headerlink" title="暂停时间(pause time)"></a>暂停时间(pause time)</h5><ul>
<li>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态<ul>
<li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</li>
</ul>
</li>
<li>暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1+0.1+0.1+0.1=0.5</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200715203242.png"  alt="暂停时间"></p>
<h5 id="吞吐量vs暂停时间"><a href="#吞吐量vs暂停时间" class="headerlink" title="吞吐量vs暂停时间"></a>吞吐量vs暂停时间</h5><ul>
<li>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快</li>
<li>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序</li>
<li>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）<ul>
<li>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收</li>
<li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降</li>
</ul>
</li>
</ul>
<p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折中。</p>
<p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p>
<h3 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h3><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。那么Java常见的垃圾收集器有哪些呢？</p>
<h4 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h4><p>有了虚拟机，就一定需要收集垃圾机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector</p>
<ul>
<li>1999年，随着JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li>
<li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布</li>
<li>Parallel GC在JDK6之后成为Hotspot默认GC</li>
<li>2012年，在JDK1.7u4版本中，G1可用</li>
<li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS</li>
<li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟</li>
<li>2018年9月，JDK11发布。引入Epsilon垃圾回收器，又被称为”No-Op（无操作）“回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器(Experimental)</li>
<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC(Experimental)</li>
<li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统</li>
<li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macos和Windows上的应用</li>
</ul>
<p><strong>7款经典的垃圾收集器</strong></p>
<p>串行回收器：Serial、Serial Old</p>
<p>并行回收器：ParNew、Parallel Scavenge、Parallel Old</p>
<p>并发回收器：CMS、G1</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200715204918.png"  alt="经典的垃圾收集器"></p>
<h4 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h4><p>this.</p>
<h3 id="Serial回收器（串行回收）"><a href="#Serial回收器（串行回收）" class="headerlink" title="Serial回收器（串行回收）"></a>Serial回收器（串行回收）</h3><h3 id="ParNew回收器（并行回收）"><a href="#ParNew回收器（并行回收）" class="headerlink" title="ParNew回收器（并行回收）"></a>ParNew回收器（并行回收）</h3><h3 id="Parallel回收器（吞吐量优先）"><a href="#Parallel回收器（吞吐量优先）" class="headerlink" title="Parallel回收器（吞吐量优先）"></a>Parallel回收器（吞吐量优先）</h3><h3 id="CMS回收器（低延迟）"><a href="#CMS回收器（低延迟）" class="headerlink" title="CMS回收器（低延迟）"></a>CMS回收器（低延迟）</h3><h3 id="G1回收器（区域化分代式）"><a href="#G1回收器（区域化分代式）" class="headerlink" title="G1回收器（区域化分代式）"></a>G1回收器（区域化分代式）</h3><h3 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h3><h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><h3 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h3><p><strong>END.</strong></p>
<p><strong>END.</strong></p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收</a></div><div class="post_share"><div class="social-share" data-image="https://pic4.zhimg.com/v2-eb05d8524374771337ecde8cca28cfff_1440w.jpg?source=172ae18b" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/23/%E4%BD%9C%E4%B8%9A%EF%BC%9AAndroid%20so%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">作业：Android so文件的解析</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/11/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><img class="next_cover lazyload" data-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1591889310669&amp;di=be6eb09cee916539f259689f061f7862&amp;imgtype=0&amp;src=http%3A%2F%2Fimg14.360buyimg.com%2Fn0%2Fjfs%2Ft9730%2F40%2F847174291%2F365589%2F2c1c4949%2F59d88418N7ab46c0e.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《深入理解计算机系统》读书笔记</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Kai</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>