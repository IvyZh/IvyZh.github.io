<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM学习之内存与垃圾回收篇 | K的小屋</title><meta name="description" content="JVM学习之内存与垃圾回收篇"><meta name="keywords" content="JVM,垃圾回收"><meta name="author" content="Kai"><meta name="copyright" content="Kai"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM学习之内存与垃圾回收篇"><meta name="twitter:description" content="JVM学习之内存与垃圾回收篇"><meta name="twitter:image" content="https://gitee.com/vxo/img/raw/master/blog/20200622205247.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="JVM学习之内存与垃圾回收篇"><meta property="og:url" content="https://www.google.com/2020/06/22/JVM%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/"><meta property="og:site_name" content="K的小屋"><meta property="og:description" content="JVM学习之内存与垃圾回收篇"><meta property="og:image" content="https://gitee.com/vxo/img/raw/master/blog/20200622205247.jpeg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://www.google.com/2020/06/22/JVM%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/"><link rel="prev" title="作业：Android so文件的解析" href="https://www.google.com/2020/06/23/%E4%BD%9C%E4%B8%9A%EF%BC%9AAndroid%20so%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90/"><link rel="next" title="《深入理解计算机系统》读书笔记" href="https://www.google.com/2020/06/11/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">24</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#说明"><span class="toc-number">1.1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#推荐书籍"><span class="toc-number">1.2.</span> <span class="toc-text">推荐书籍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM与Java体系结构"><span class="toc-number">2.</span> <span class="toc-text">JVM与Java体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#跨平台的语言Java和跨语言的平台JVM"><span class="toc-number">2.1.</span> <span class="toc-text">跨平台的语言Java和跨语言的平台JVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字节码"><span class="toc-number">2.2.</span> <span class="toc-text">字节码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多语言混合编程"><span class="toc-number">2.3.</span> <span class="toc-text">多语言混合编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java发展的重大事件"><span class="toc-number">2.4.</span> <span class="toc-text">Java发展的重大事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Open-JDK和Oracle-JDK"><span class="toc-number">2.5.</span> <span class="toc-text">Open JDK和Oracle JDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机与Java虚拟机"><span class="toc-number">2.6.</span> <span class="toc-text">虚拟机与Java虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM的整体结构"><span class="toc-number">2.7.</span> <span class="toc-text">JVM的整体结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM架构模型"><span class="toc-number">2.8.</span> <span class="toc-text">JVM架构模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM生命周期"><span class="toc-number">2.9.</span> <span class="toc-text">JVM生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM的发展历程"><span class="toc-number">2.10.</span> <span class="toc-text">JVM的发展历程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sun-Classic-VM"><span class="toc-number">2.10.1.</span> <span class="toc-text">Sun Classic VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exact-VM"><span class="toc-number">2.10.2.</span> <span class="toc-text">Exact VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HotSpot-VM"><span class="toc-number">2.10.3.</span> <span class="toc-text">HotSpot VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JRockit-VM"><span class="toc-number">2.10.4.</span> <span class="toc-text">JRockit VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J9-VM"><span class="toc-number">2.10.5.</span> <span class="toc-text">J9 VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KVM、CDC、CLDC"><span class="toc-number">2.10.6.</span> <span class="toc-text">KVM、CDC、CLDC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Azul-VM"><span class="toc-number">2.10.7.</span> <span class="toc-text">Azul VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Liquid-VM"><span class="toc-number">2.10.8.</span> <span class="toc-text">Liquid VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Apache-Harmony"><span class="toc-number">2.10.9.</span> <span class="toc-text">Apache Harmony</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Microsoft-JVM"><span class="toc-number">2.10.10.</span> <span class="toc-text">Microsoft JVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TaobaoJVM"><span class="toc-number">2.10.11.</span> <span class="toc-text">TaobaoJVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dalvik-VM"><span class="toc-number">2.10.12.</span> <span class="toc-text">Dalvik VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他JVM"><span class="toc-number">2.10.13.</span> <span class="toc-text">其他JVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graal-VM"><span class="toc-number">2.10.14.</span> <span class="toc-text">Graal VM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类加载子系统"><span class="toc-number">3.</span> <span class="toc-text">类加载子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存结构概述"><span class="toc-number">3.1.</span> <span class="toc-text">内存结构概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器与类的加载过程"><span class="toc-number">3.2.</span> <span class="toc-text">类加载器与类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类的加载过程"><span class="toc-number">3.2.1.</span> <span class="toc-text">类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#加载（Loading）"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">加载（Loading）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链接（Linking）"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">链接（Linking）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化（Initialization）"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">初始化（Initialization）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码演示"><span class="toc-number">3.2.2.</span> <span class="toc-text">代码演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器分类"><span class="toc-number">3.3.</span> <span class="toc-text">类加载器分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟机自带的加载器"><span class="toc-number">3.3.1.</span> <span class="toc-text">虚拟机自带的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">启动类加载器（引导类加载器，Bootstrap ClassLoader）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展类加载器（Extension-ClassLoader）"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">扩展类加载器（Extension ClassLoader）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#应用程序类加载器（AppClassLoader）"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">应用程序类加载器（AppClassLoader）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户自定义类加载器"><span class="toc-number">3.3.2.</span> <span class="toc-text">用户自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassLoader的使用说明"><span class="toc-number">3.4.</span> <span class="toc-text">ClassLoader的使用说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟机自带类加载器演示"><span class="toc-number">3.4.1.</span> <span class="toc-text">虚拟机自带类加载器演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户自定义加载类演示"><span class="toc-number">3.4.2.</span> <span class="toc-text">用户自定义加载类演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取ClassLoader的几种途径"><span class="toc-number">3.4.3.</span> <span class="toc-text">获取ClassLoader的几种途径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双亲委派机制"><span class="toc-number">3.5.</span> <span class="toc-text">双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委派工作原理"><span class="toc-number">3.5.1.</span> <span class="toc-text">双亲委派工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委派机制的优势"><span class="toc-number">3.5.2.</span> <span class="toc-text">双亲委派机制的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">3.6.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#判断两个class对象是否为同一个类"><span class="toc-number">3.6.1.</span> <span class="toc-text">判断两个class对象是否为同一个类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对类加载器的引用"><span class="toc-number">3.6.2.</span> <span class="toc-text">对类加载器的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的主动使用和被动使用"><span class="toc-number">3.6.3.</span> <span class="toc-text">类的主动使用和被动使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运行时数据区"><span class="toc-number">4.</span> <span class="toc-text">运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#程序计数器"><span class="toc-number">4.1.</span> <span class="toc-text">程序计数器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用"><span class="toc-number">4.1.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍"><span class="toc-number">4.1.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于PC寄存器的两个常见问题"><span class="toc-number">4.1.3.</span> <span class="toc-text">关于PC寄存器的两个常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU时间片"><span class="toc-number">4.1.4.</span> <span class="toc-text">CPU时间片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机栈"><span class="toc-number">4.2.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">4.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈的存储单位"><span class="toc-number">4.2.2.</span> <span class="toc-text">栈的存储单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧-局部变量表（local-variables）"><span class="toc-number">4.2.3.</span> <span class="toc-text">栈帧-局部变量表（local variables）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#变量槽Slot"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">变量槽Slot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态变量与局部变量的对比"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">静态变量与局部变量的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧-操作数栈-Operand-Stack"><span class="toc-number">4.2.4.</span> <span class="toc-text">栈帧-操作数栈(Operand Stack)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#操作数栈说明"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">操作数栈说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#操作数栈的字节码指令执行分析"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">操作数栈的字节码指令执行分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈顶缓存（Top-Of-Stack-Cashing）技术"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">栈顶缓存（Top-Of-Stack Cashing）技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧-动态链接-Dynamic-Linking"><span class="toc-number">4.2.5.</span> <span class="toc-text">栈帧-动态链接(Dynamic Linking)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法的调用"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">方法的调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧-返回地址-return-address"><span class="toc-number">4.2.6.</span> <span class="toc-text">栈帧-返回地址(return address)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧-一些附加信息"><span class="toc-number">4.2.7.</span> <span class="toc-text">栈帧-一些附加信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于栈的一些面试题"><span class="toc-number">4.2.8.</span> <span class="toc-text">关于栈的一些面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地方法接口-不属于运行时数据区"><span class="toc-number">4.3.</span> <span class="toc-text">本地方法接口(不属于运行时数据区)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是本地方法接口"><span class="toc-number">4.3.1.</span> <span class="toc-text">什么是本地方法接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要使用Native-Method"><span class="toc-number">4.3.2.</span> <span class="toc-text">为什么要使用Native Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#现状"><span class="toc-number">4.3.3.</span> <span class="toc-text">现状</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地方法栈-Native-Method-Stack"><span class="toc-number">4.4.</span> <span class="toc-text">本地方法栈(Native Method Stack)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆"><span class="toc-number">4.5.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区"><span class="toc-number">4.6.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的实例化、内存布局与访问定位"><span class="toc-number">4.7.</span> <span class="toc-text">对象的实例化、内存布局与访问定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直接内存"><span class="toc-number">4.8.</span> <span class="toc-text">直接内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringTable"><span class="toc-number">4.9.</span> <span class="toc-text">StringTable</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#执行引擎"><span class="toc-number">5.</span> <span class="toc-text">执行引擎</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#垃圾回收概述"><span class="toc-number">6.</span> <span class="toc-text">垃圾回收概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#垃圾回收相关算法"><span class="toc-number">7.</span> <span class="toc-text">垃圾回收相关算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#垃圾回收相关概念"><span class="toc-number">8.</span> <span class="toc-text">垃圾回收相关概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#垃圾回收器"><span class="toc-number">9.</span> <span class="toc-text">垃圾回收器</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://gitee.com/vxo/img/raw/master/blog/20200622205247.jpeg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">K的小屋</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">JVM学习之内存与垃圾回收篇</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-22 20:30:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-22</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-02 10:51:58"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-02</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">20.7k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 69 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Java语言规范和JVM虚拟机规范可以从官方地址进行下载：<a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/index.html</a></p>
<p>picgo端口号：36677</p>
<h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p>《Java虚拟机规范》</p>
<p><strong>《深入理解Java虚拟机》</strong>：推荐</p>
<p>《深入理解JVM&amp;G1 GC》</p>
<p>《解密Java虚拟机》</p>
<p>《Java虚拟机基础教程》</p>
<p>《实战Java虚拟机》</p>
<p>《Java虚拟机精讲》</p>
<p>《码出高效Java开发手册》</p>
<p>《自己动手写Java虚拟机》</p>
<h1 id="JVM与Java体系结构"><a href="#JVM与Java体系结构" class="headerlink" title="JVM与Java体系结构"></a>JVM与Java体系结构</h1><h2 id="跨平台的语言Java和跨语言的平台JVM"><a href="#跨平台的语言Java和跨语言的平台JVM" class="headerlink" title="跨平台的语言Java和跨语言的平台JVM"></a>跨平台的语言Java和跨语言的平台JVM</h2><p>TIOBE语言热度排行榜：<a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener">https://www.tiobe.com/tiobe-index/</a></p>
<blockquote>
<p>世界上没有最好的编程语言，只有最适合于具体应用场景的编程语言。</p>
</blockquote>
<p><strong>Java生态圈</strong></p>
<p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大，Java也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p>
<ul>
<li>作为一个平台，Java虚拟机扮演着举足轻重的作用<ul>
<li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li>
</ul>
</li>
<li>作为一种文化，Java几乎成为了“开源”的代名词<ul>
<li>第三方开源软件和框架，如Tomcat、MyBatis、Spring等</li>
<li>就连JDK和JVM自身也有不少开源的实现，如OpenJDK、Harmony</li>
</ul>
</li>
<li>作为一个社区，Java拥有全世界最多的技术拥护者和开源社区的支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式指复杂、参与人数之众多也令人咋舌</li>
</ul>
<p><strong>Java：跨平台的语言</strong></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622170015.png"  alt="Java一次编译到处运行"></p>
<p><strong>JVM官方介绍</strong></p>
<blockquote>
<p>The Java Virtual Machine is the cornerstone of the Java platform. <strong>It is the component of the technology responsible for its hardware- and operating system-independence</strong>, the small size of its compiled code, and its ability to protect users from malicious programs.</p>
<p>The Java Virtual Machine is an abstract computing machine. Like a real computing machine, it has an instruction set and manipulates various memory areas at run time. It is reasonably common to implement a programming language using a virtual machine; the best-known virtual machine may be the P-Code machine of UCSD Pascal.</p>
</blockquote>
<p>Google翻译：</p>
<blockquote>
<p>Java虚拟机是Java平台的基石。它是技术的组成部分，负责硬件和操作系统的独立性，编译代码的小巧大小以及保护用户免受恶意程序侵害的能力。</p>
<p>Java虚拟机是抽象的计算机。像真正的计算机一样，它具有指令集，并在运行时操作各种内存区域。使用虚拟机实现编程语言是相当普遍的。最知名的虚拟机可能是UCSD Pascal的P代码计算机。</p>
</blockquote>
<p>小结：Java是跨平台的语言，JVM是跨语言的平台</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622171157.png"  alt="JVM-跨语言的平台"></p>
<p>解释“JVM是跨语言的平台”：</p>
<ul>
<li>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现<strong>在Java虚拟机平台上运行非Java语言编写的程序</strong></li>
<li>Java虚拟机根部不关系运行在其内部的程序到底是使用何种编程语言编写的，<strong>它只关心“字节码”文件</strong>。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机内部指令集、符号表以及其他辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</li>
</ul>
<blockquote>
<p>Java不是最强大的语言，但是JVM是最强大的虚拟机</p>
</blockquote>
<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><ul>
<li>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：<strong>jvm字节码</strong></li>
<li>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行</li>
<li>Java虚拟机与Java语言并没有必然的联系，它只与特点的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者成为字节码、Bytecodes）和符号表，还有一些辅助信息</li>
</ul>
<h2 id="多语言混合编程"><a href="#多语言混合编程" class="headerlink" title="多语言混合编程"></a>多语言混合编程</h2><p>​    <strong>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方法</strong>。</p>
<p>​    试想一些，在一个项目之中，并行处理使用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都使用不同的编程语言来完成，并且接口对每一层的开发者都是透明的，<strong>各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上</strong>。</p>
<p>​    对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Davinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），<strong>推动Java虚拟机从“Java语言的虚拟机”向“多语言虚拟机”的方法发展</strong>。</p>
<h2 id="Java发展的重大事件"><a href="#Java发展的重大事件" class="headerlink" title="Java发展的重大事件"></a>Java发展的重大事件</h2><ul>
<li>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出新的程序语言，命名为Oak，后期命名为Java</li>
<li>1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相</li>
<li>1996年1月23日Sun Microsystems发布了JDK 1.0</li>
<li>1998年，JDK 1.2版本发布。同时，Sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动应用3大领域挺进</li>
<li>2000年，JDK 1.3发布，<strong>Java HotSpot Virtual Machine正式发布，成为Java默认的虚拟机</strong></li>
<li>2002年，JDK 1.4发布，古老的Classic虚拟机退出历史舞台</li>
<li>2003年底<strong>，Java平台Scala正式发布，同年Groovy也加入了Java阵营</strong></li>
<li>2004年，JDK 1.5发布，同时JDK 1.5改名成为Java SE 5.0</li>
<li>2006年，JDK 6发布，同年<strong>Java开源并建立了OpenJDK</strong>。顺理成章，<strong>Hotspot虚拟机也成为了OpenJDK中默认的虚拟机</strong></li>
<li>2007年，<strong>Java平台迎来了新伙伴Clojure</strong></li>
<li>2008年，Oracle收购了BEA，<strong>得到了JRockit虚拟机</strong></li>
<li>2009男，Twitter宣布把后台大部分程序从Ruby迁移到Scala，这是Java平台的又一次大规模应用</li>
<li>2010年，Oracale收购了Sun，<strong>获得了Java商标和最具价值的HotSpot虚拟机</strong>。此时，Orcale拥有市场率最高的两款虚拟机HotSpot和JRockit，并计划在未来对他们进行整合：HotRockit</li>
<li>2011年，JDK7发布，在JDK1.7u4中，<strong>正式启用了新的垃圾回收期G1</strong></li>
<li>2017年，JDK9发布，<strong>并将G1设置为默认GC，替代CMS</strong>。同年，IBM的J9开源，形成了现在的Open J9社区</li>
<li>2018年，Android的Java侵权案判决，Google赔偿Oracle计88亿美元</li>
<li>2018年，Oracle宣布JavaEE成为历史名词，JDBC、JMS、Servlet赠予Eclipse基金会</li>
<li>2018年，JDK11发布，LTS版本的JDK，<strong>发布革命性的ZGC，调整JDK授权许可</strong></li>
<li>2019年，JDK12发布，加入Redhat领导开发的<strong>Shenandoah GC</strong></li>
</ul>
<h2 id="Open-JDK和Oracle-JDK"><a href="#Open-JDK和Oracle-JDK" class="headerlink" title="Open JDK和Oracle JDK"></a>Open JDK和Oracle JDK</h2><blockquote>
<p>Oracle JDK与OpenJDK里的JVM都是HotSpot VM。从源码层面说，两者基本上是同一个东西。</p>
<p>从JDK7开始，Oracle JDK里的HotSpot VM，在研发的时候其实就是用放在OpenJDK的Mercurial代码库。也就是说跟大家从外部能实时看到的OpenJDK用的是同一个代码库。</p>
<p>Java SE的主要版本大约每两年发布一次，直到Java SE 7.从Java SE 6开始花了五年时间，之后又花了三年时间到达Java SE 8。</p>
<p>自Java SE 10以来，我们可以期待每六个月发布一次新版本。但是，并非所有版本都是长期支持（LTS）版本。</p>
<p>由于Oracle的发布计划，LTS产品发布仅每三年发布一次。Java SE 11是最新的LTS版本，Java SE 8将在2020年12月之前获得免费的公共更新，用于非商业用途。</p>
</blockquote>
<p>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一 次；</p>
<p>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是 OpenJDK的一个实现，并不是完全开源的；</p>
<p>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎 相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发 企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和 稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应 用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</p>
<p>顶级公司正在使用Oracle JDK，例如Android Studio，Minecraft和 IntelliJ IDEA开发工具，其中Open JDK不太受欢迎；</p>
<p>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的 性能；</p>
<p>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过 更新到最新版本获得支持来获取最新版本；</p>
<p>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</p>
<h2 id="虚拟机与Java虚拟机"><a href="#虚拟机与Java虚拟机" class="headerlink" title="虚拟机与Java虚拟机"></a>虚拟机与Java虚拟机</h2><p><strong>虚拟机</strong></p>
<ul>
<li><p>所谓虚拟机，就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<strong>系统虚拟机</strong>和<strong>程序虚拟机</strong></p>
<ul>
<li>大名鼎鼎的Visual Box，VMware就属于系统虚拟机，它们<strong>完全是对物理计算机的仿真</strong>，提供了一个可运行完整操作系统的软件平台</li>
<li>程序虚拟机典型的代码就是<strong>Java虚拟机</strong>，它<strong>专门执行单个计算机程序而设计</strong>，在Java虚拟机中执行的指令我们称为Java字节码指令</li>
</ul>
</li>
<li><p>无论系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中</p>
</li>
</ul>
<p><strong>Java虚拟机</strong></p>
<ul>
<li>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成</li>
<li>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器</li>
<li><strong>Java技术的核心就是Java虚拟机</strong>（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部</li>
<li>作用<ul>
<li><strong>Java虚拟机就是二进制字节码的运行环境</strong>，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细的定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里</li>
</ul>
</li>
<li>特点<ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
</li>
</ul>
<p><strong>JVM的位置</strong></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622172747.png"  alt="JVM的位置"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622172933.png"  alt="JVM位置"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622173122.png"  alt="Google的Android系统结构"></p>
<h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h2><ul>
<li>HotSpot VM是目前市面上高性能虚拟机的代表作之一</li>
<li>它采用解释器与即时编译器并存的架构</li>
<li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步</li>
</ul>
<p>可以参考这个：<a href="https://www.processon.com/view/5ea7a1b9e401fd21c196eb17?fromnew=1" target="_blank" rel="noopener">https://www.processon.com/view/5ea7a1b9e401fd21c196eb17?fromnew=1</a></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622174536.png"  alt="JVM整体结构"></p>
<h2 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h2><p>Java编译器输入的指令流基本上是一种基于<strong>栈的指令集架构</strong>，另外一种指令集架构则是基于<strong>寄存器的指令集架构</strong>。</p>
<p>具体来说，两种架构的区别如下：</p>
<ul>
<li>基于栈式架构的特点<ul>
<li>设计和实现更简单，适用于资源受限的系统</li>
<li>避开了寄存器的分配难题：使用零地址指令方式分配</li>
<li>指令流中的指令大部分都是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器更容易实现</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
</li>
<li>基于寄存器架构的特点<ul>
<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机</li>
<li>指令集架构则完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令去完成一项操作</li>
<li>在大部分情况下，基于寄存器架构的指令往往都是以一地址指令、二地址指令和三地址指令为主，而基于栈式的指令集往往是以零地址指令为主</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Github</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2020/6/22 17:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述：演示基于栈的计算流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackStruTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译class字节码文件的指令：</p>
<blockquote>
<p>javap -v StackStruTest.class</p>
</blockquote>
<p>反编译后的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Classfile &#x2F;D:&#x2F;workspace&#x2F;Github&#x2F;jvm_study&#x2F;out&#x2F;production&#x2F;jvm_study&#x2F;com&#x2F;github&#x2F;jvm&#x2F;StackStruTest.class</span><br><span class="line">  Last modified 2020-6-22; size 478 bytes</span><br><span class="line">  MD5 checksum 888fe6cb592e62f71306c7f159c77feb</span><br><span class="line">  Compiled from &quot;StackStruTest.java&quot;</span><br><span class="line">public class com.github.jvm.StackStruTest</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #3.#21         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Class              #22            &#x2F;&#x2F; com&#x2F;github&#x2F;jvm&#x2F;StackStruTest</span><br><span class="line">   #3 &#x3D; Class              #23            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">   #4 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">   #5 &#x3D; Utf8               ()V</span><br><span class="line">   #6 &#x3D; Utf8               Code</span><br><span class="line">   #7 &#x3D; Utf8               LineNumberTable</span><br><span class="line">   #8 &#x3D; Utf8               LocalVariableTable</span><br><span class="line">   #9 &#x3D; Utf8               this</span><br><span class="line">  #10 &#x3D; Utf8               Lcom&#x2F;github&#x2F;jvm&#x2F;StackStruTest;</span><br><span class="line">  #11 &#x3D; Utf8               main</span><br><span class="line">  #12 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #13 &#x3D; Utf8               args</span><br><span class="line">  #14 &#x3D; Utf8               [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #15 &#x3D; Utf8               i</span><br><span class="line">  #16 &#x3D; Utf8               I</span><br><span class="line">  #17 &#x3D; Utf8               j</span><br><span class="line">  #18 &#x3D; Utf8               k</span><br><span class="line">  #19 &#x3D; Utf8               SourceFile</span><br><span class="line">  #20 &#x3D; Utf8               StackStruTest.java</span><br><span class="line">  #21 &#x3D; NameAndType        #4:#5          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #22 &#x3D; Utf8               com&#x2F;github&#x2F;jvm&#x2F;StackStruTest</span><br><span class="line">  #23 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">&#123;</span><br><span class="line">  public com.github.jvm.StackStruTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom&#x2F;github&#x2F;jvm&#x2F;StackStruTest;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;4, args_size&#x3D;1</span><br><span class="line">         0: iconst_2 &#x2F;&#x2F;常量2入栈</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: iconst_3 &#x2F;&#x2F;常量3入栈</span><br><span class="line">         3: istore_2</span><br><span class="line">         4: iload_1</span><br><span class="line">         5: iload_2</span><br><span class="line">         6: iadd	&#x2F;&#x2F;常量2、3出栈，执行相加</span><br><span class="line">         7: istore_3</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 11: 2</span><br><span class="line">        line 12: 4</span><br><span class="line">        line 13: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">            2       7     1     i   I</span><br><span class="line">            4       5     2     j   I</span><br><span class="line">            8       1     3     k   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;StackStruTest.java&quot;</span><br></pre></td></tr></table></figure>

<p>而基于寄存器的计算流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,2 &#x2F;&#x2F;将eax寄存器的值设为2</span><br><span class="line">add eax,3 &#x2F;&#x2F;将eax计算器的值加3</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong></p>
<p>由于跨平台性的设计，Java的指令都是依据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。有点是跨平台，指令集小，编译器更容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确的来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p>
<p>栈：跨平台性、指令集小、指令多，执行性能比寄存器差</p>
<h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><p><strong>启动</strong></p>
<p>Java虚拟机的启动是通过引导类加载器（bootstap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的</p>
<p><strong>执行</strong></p>
<ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li>
<li>程序开始执行时他才运行，程序结束时他就停止</li>
<li><strong>执行一个所谓的Java程序的时候，真正在执行的是一个叫做Java虚拟机的进程</strong></li>
</ul>
<p><strong>退出</strong></p>
<p>有如下几种情况：</p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或者错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
<li>某线程调用Runtime类或者System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或者halt操作</li>
<li>除此之外，JNI（Java Native Interface）规范了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况</li>
</ul>
<p>还是上面的程序，我们睡眠30s，通过jps可以查看当前进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackStruTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">30</span> * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>D:\workspace\Github\jvm_study\out\production\jvm_study\com\github\jvm&gt;jps<br>11376<br>6016 Launcher<br>10840<br>1192 Jps<br>3612 StackStruTest</p>
</blockquote>
<p>30s之后：</p>
<blockquote>
<p>11376<br>6016 Launcher<br>14612 Jps<br>10840</p>
</blockquote>
<h2 id="JVM的发展历程"><a href="#JVM的发展历程" class="headerlink" title="JVM的发展历程"></a>JVM的发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul>
<li>早在1996年Java1.0版本的时候，Sun共发布了一款名为Sun Classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰</li>
<li>这款虚拟机内部只提供解释器</li>
<li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管迅疾执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li>
<li>现在HotSpot内置了此虚拟机</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622183444.png"  alt="解释器与JIT"></p>
<h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ul>
<li>为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机</li>
<li>Exact Memory Management：准确式内存管理<ul>
<li>也可以叫Non-Conservative/Accurate Memory Management</li>
<li>虚拟机可以知道内存中某个位置的数据具体是什么类型</li>
</ul>
</li>
<li>具备现代高性能虚拟机的雏形<ul>
<li>热点探测</li>
<li>编译器与解释器混合工作模式</li>
</ul>
</li>
<li>只在Solaris平台短暂使用，其他平台上还是Classic VM<ul>
<li>英雄气短，终被HotSpot虚拟机替换</li>
</ul>
</li>
</ul>
<h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><ul>
<li>Hots历史<ul>
<li>最初由一家名为“Longview Technologies”的小公司设计</li>
<li>1997年，此公司被Sun收购，2009年，Sun公司被甲骨文收购</li>
<li>JDK1.3时，HotSpot VM成为默认虚拟机</li>
</ul>
</li>
<li>目前<strong>HotSpot占有绝对的市场地位</strong>，称霸武林<ul>
<li>不管是现在仍然广泛使用的JDK6，还是使用比例较多的JDK8中，默认都是HotSpot</li>
<li>Sun/Oracle JDK和 Open JDK的默认虚拟机</li>
</ul>
</li>
<li>从服务器、桌面到移动端、嵌入式都有应用</li>
<li>名称中的HotSpot指的就是它的热点代码探测技术<ul>
<li>通过计数器找到最具编译价值的代码，触发即时编译或栈上替换</li>
<li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li>
</ul>
</li>
</ul>
<h3 id="JRockit-VM"><a href="#JRockit-VM" class="headerlink" title="JRockit VM"></a>JRockit VM</h3><ul>
<li><p><strong>专注于服务器端应用</strong></p>
<ul>
<li>它可以不太关注程序启动速度，隐藏JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行</li>
</ul>
</li>
<li><p>大量的行业基准测试显示，<strong>JRockit VM是世界上最快的JVM</strong></p>
<ul>
<li>使用JRockit产品，客户已经体验到了显著的性能提高</li>
</ul>
</li>
<li><p>优势：全面的Java运行时解决方案组合</p>
<ul>
<li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微妙级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li>
<li>MissionController服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具</li>
</ul>
</li>
<li><p>2008年，BEA被Oracle收购</p>
</li>
<li><p>Oracle表达了整合两大优势虚拟机工作，大致在JDK 8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性</p>
</li>
</ul>
<h3 id="J9-VM"><a href="#J9-VM" class="headerlink" title="J9 VM"></a>J9 VM</h3><ul>
<li>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</li>
<li>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多种用途VM</li>
<li>广泛用于IBM的各种Java产品</li>
<li>目前，<strong>最有影响力的三大商用虚拟机之一</strong>，也号称世界上最快的Java虚拟机（HotSpot、JRockit、J9）</li>
<li>2017年左右，IBM发布了开源J9 VM，命名为OpenJ9，交给Eclipse基金会管理，也成为Eclipse OpenJ9</li>
</ul>
<h3 id="KVM、CDC、CLDC"><a href="#KVM、CDC、CLDC" class="headerlink" title="KVM、CDC、CLDC"></a>KVM、CDC、CLDC</h3><ul>
<li><p>Oracle在Java ME产品线上的两款虚拟机为：CDD/CLDC HotSpot Implementation VM</p>
</li>
<li><p>KVM（Kilobyte）是CLDC-HI早起产品</p>
</li>
<li><p>目前移动领域地位尴尬，智能手机被Android和iOS二分天下</p>
</li>
<li><p>KVM简单、清凉、高度可移植，面向更低端的设备上还维持自己的一篇市场</p>
<ul>
<li>智能控制器、传感器</li>
<li>老人手机、经济欠发达地区的功能手机</li>
</ul>
</li>
<li><p>所有虚拟机原则：一次编译，到处运行</p>
</li>
</ul>
<h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><ul>
<li>Azul Vm和BEA Liquid VM是与<strong>特定硬件平台绑定、软硬件配合的专有虚拟机</strong><ul>
<li>高性能JAva虚拟机中的战斗机</li>
</ul>
</li>
<li>Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司专有的硬件Vega系统上的Java虚拟机</li>
<li><strong>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性</strong></li>
<li>2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性</li>
</ul>
<h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><ul>
<li>高性能JAva虚拟机中的战斗机</li>
<li>BEA公司开发的，直接运行在自家Hypervisor系统上</li>
<li>Liquid VM即是现在的JRockit VE（Virtual Edition），Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用的操作系统的必要功能，如线程调度、文件系统、网络支持等</li>
<li>随着JRockit虚拟机终止开发，Liquid VM项目也停止了</li>
</ul>
<h3 id="Apache-Harmony"><a href="#Apache-Harmony" class="headerlink" title="Apache Harmony"></a>Apache Harmony</h3><ul>
<li>Apache也曾经推出过JDK 1.5和JDK 1.6兼容的Java运行平台 Apache Harmony</li>
<li>它是IBM和Intel联合开发的开源JVM，受到同样开源的OpenJDK的压榨，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</li>
<li>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK</li>
</ul>
<h3 id="Microsoft-JVM"><a href="#Microsoft-JVM" class="headerlink" title="Microsoft JVM"></a>Microsoft JVM</h3><ul>
<li>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM</li>
<li>只能在Windows平台下运行，的确是当时Windows下性能最好的Java VM</li>
<li>1997年，Sun以侵权商标、不正当竞争罪名指控微软成功。微软在WindowsXP SP3中抹掉了其VM，现在Windows上安装的jdk都是HotSpot</li>
</ul>
<h3 id="TaobaoJVM"><a href="#TaobaoJVM" class="headerlink" title="TaobaoJVM"></a>TaobaoJVM</h3><ul>
<li>由AliJVM团队发布</li>
<li><strong>基于OpenJDK开发了自己的定制版AlibabaJDK</strong>，简称AJDK，是整个阿里Java体系的基石</li>
<li>基于OpenJDK HotSpot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机<ul>
<li><strong>创新的GCIH（GC invisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收率的目的</strong></li>
<li><strong>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</strong></li>
<li>使用crc32指令实现JVM intrinsic 降低JNI的调用开销</li>
<li>PMU hardware的Java profiling tool和诊断协助给你</li>
<li>针对大数据场景的ZenGC</li>
</ul>
</li>
<li>taobao vm应用在阿里产品上的性能搞，硬件依赖intel的cpu，损失了兼容性，但是提高了性能<ul>
<li>目前已经在淘宝、天猫上，把Oracle官方的JVM版本全部替换了</li>
</ul>
</li>
</ul>
<h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><ul>
<li>谷歌开发的，应用于Android系统，并在Android 2.2中提供了JIT，发展迅猛</li>
<li>Dalvik VM只能称作虚拟机，而不能称作“Java 虚拟机”，它没遵循Java 虚拟机规范</li>
<li>不能直接执行Java的Class文件</li>
<li>基于寄存器架构，而不是jvm的栈架构</li>
<li>执行的是编译后的dex（Dalvik Executable）文件，执行效率高<ul>
<li>它执行的dex（Dalvik Executable）文件可以通过Class文件转化而来，它使用Java语法编写应用程序，可以直接使用大部分的Java API等</li>
</ul>
</li>
<li>Android 5.0使用支持提前编译（Ahead Of Time Compilation，AOT）的ARM VM替换Dalvik VM</li>
</ul>
<h3 id="其他JVM"><a href="#其他JVM" class="headerlink" title="其他JVM"></a>其他JVM</h3><p> Java Card VM、Squawk VM、JavaInJava、Maxine VM、Jikes RVM、IKVM.NET、Jam VM、Cacao VM、Sable VM、Kaffe、Jelatine JVM、Nano VM、MRP、Moxie JVM</p>
<blockquote>
<p>具体JVM内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定的差异。后续将以Oracle HotSpot VM为默认虚拟机进行讲解。</p>
</blockquote>
<h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><ul>
<li><p>2018年4月，Oracle Labs公开了Graal VM，号称“<strong>Run Programs Faster Anywhere</strong>”，野心勃勃。与1995年的java的“write once，run anywhere”遥相呼应</p>
</li>
<li><p>Graal VM在HotSpot VM基础上增强而成的跨语言全栈迅疾，可以<strong>作为“任何语言”的运行平台使用</strong>。语言包括：Java、Scala、Groovy、Kotlin；C、C++、JavaScript、Ruby、Python、R等</p>
</li>
<li><p>支持不同语言的源代码或者源代码编译后的中间格式，通过解释器转换成能被Graal VM接受的中间表示。Graal VM提供了Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率</p>
</li>
<li><p><strong>如果说HotSpot有一天真的被取代，Graal VM希望最大</strong>，但是Java的软件生态没有丝毫变化。</p>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200622203503.png"  alt="Graal VM"></p>
<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h2><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200623202157.jpg"  alt="JVM架构"></p>
<h2 id="类加载器与类的加载过程"><a href="#类加载器与类的加载过程" class="headerlink" title="类加载器与类的加载过程"></a>类加载器与类的加载过程</h2><p><strong>类加载子系统作用</strong></p>
<ul>
<li>类加载子系统赋值从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识</li>
<li>ClassLoader只负责class文件的加载，至于它能否可以运行，则有Execution Engine决定</li>
<li>加载的类信息存放于一块称为<strong>方法区</strong>的内存空间。除了类的信息外，方法区还有存放<strong>运行时常量池</strong>信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li>
</ul>
<p>运行时常量池在Class字节码中的体现，通过反编译class文件：javap -v StackStruTest.class得到如下内容：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200623203204.png"  alt="反编译StackStruTest.class"></p>
<p><strong>类加载器ClassLoder角色</strong></p>
<ul>
<li>class file存在于本地硬盘或者网络上的文件，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是需要加载到JVM当中来，根据这个文件实例化n个一模一样的实例</li>
<li>class file加载到JVM中，被称为DNA元数据模板，放在方法区</li>
<li>在.class文件—&gt;JVM—&gt;最终成为元数据模板，此过程就要一个运输工具（类装在器Class Loder），扮演一个快递员的角色</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200623203704.png"  alt="Class Loader角色"></p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><ul>
<li>加载（Loading）</li>
<li>链接（Linking）<ul>
<li>验证（Verification）</li>
<li>准备（Preparetion）</li>
<li>解析（Resolution）</li>
</ul>
</li>
<li>初始化（Initialization）</li>
</ul>
<h4 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h4><ol>
<li>通过类的全限定名获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>补充：加载.class文件的方式</p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络获取，典型场景：Web Applet</li>
<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>
<li>运行时计算生成，使用最多的是：动态代理技术</li>
<li>由其他文件生成，典型场景：JSP应用</li>
<li>从专有的数据库中提取.class文件，比较少见</li>
<li>从加密文件中获取，典型的防止Class文件被反编译的保护措施</li>
</ul>
<h4 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a>链接（Linking）</h4><ul>
<li>验证（Verification）<ul>
<li>目的在于确保Class文件的字节流包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li>
<li>主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证，比如使用工具Binary Viewer查看class文件，会发现有<code>CAFEBABE</code>开头</li>
</ul>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200623211624.png"  alt="cafe babe"></p>
<ul>
<li>准备（Preparetion）<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值，<strong>类变量分配位置是在方法区中</strong></li>
<li>这里<strong>不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化</strong></li>
<li>这里不会为实例变量分配初始值，类变量会分配在方法区中，而<strong>实例变量是会随着对象一起分配到Java堆</strong>中</li>
</ul>
</li>
<li>解析（Resolution）<ul>
<li><strong>将常量池内的符号引用转换成为直接引用的过程</strong></li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化操作之后再执行</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个艰巨定位到目标的句柄</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodred_info等</li>
</ul>
</li>
</ul>
<h4 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h4><ul>
<li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li>
<li>此方法不需要定义，是javac编译器自动收集<strong>类中的所有类变量的赋值动作和静态代码块中的语句合并而来</strong></li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行</li>
<li><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li>
<li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行之前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li>
<li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li>
</ul>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>关于类变量初始化说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//Prepare：a = 0 ---&gt; Initialization : a = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类变量a在链接的准备阶段被初始化为0，到了第三个阶段初始化就被赋值为1了</p>
</blockquote>
<p>这一过程可以通过<code>jclasslib bytecode viewer</code>工具进行查看，在初始化阶段（Initialization）会执行类构造器方法<code>&lt;clinit&gt;()</code>会对变量a进行初始化：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624124116.png"  alt="Initialization阶段"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624124420.png"  alt="Initialization阶段"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624124916.png"  alt="Initialization阶段"></p>
<p>假如一个类中没有静态变量和静态方法块，则不会出现<code>&lt;clinit&gt;()</code>方法：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624125254.png"  alt="无类变量和静态方法块"></p>
<blockquote>
<p>注：任何一个类声明之后，内部至少存在一个类的构造器<code>&lt;init&gt;</code></p>
</blockquote>
<ul>
<li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行之前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624134444.png"  alt="加载子类前，先加载父类"></p>
<ul>
<li><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p>
<blockquote>
<p>就是一个类的字节码在加载进方法区（JDK8以后叫做元空间），也就是说虚拟机执行类加载过程中，只会调用一次<code>&lt;clinit&gt;()</code>方法，保证这个类只被初始化一次。</p>
</blockquote>
<p>代码演示：两个线程同时初始化一个类</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始"</span>);</span><br><span class="line">            DeadThread dead = <span class="keyword">new</span> DeadThread();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r, <span class="string">"线程1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r, <span class="string">"线程2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"初始化当前类"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>线程1开始<br>线程2开始<br>线程1初始化当前类</p>
</blockquote>
<p>或者：</p>
<blockquote>
<p>线程2开始<br>线程1开始<br>线程2初始化当前类</p>
</blockquote>
<p>然后程序没有停止，得出结论多线程情况下，初始一个类，<code>&lt;clinit&gt;()</code>只会被调用一次。</p>
<h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><ul>
<li>JVM支持两种类型的类加载器，分别为<strong>引导类加载器（Bootstrap ClassLoader）</strong>和<strong>自定义加载器（User-Defined ClassLoader）</strong></li>
<li>从概念上来讲，自定义加载器一般指的是程序中由开发人员自定义的一类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></li>
<li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624142154.png"  alt="类加载器分类"></p>
<blockquote>
<p>注：这里的四者之间的关系是包含关系，不是上层下层，也不是子父类继承关系</p>
</blockquote>
<p><strong>关于ClassLoader这个类</strong></p>
<p>java.lang.ClassLoader是一个抽象类</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624142654.png"  alt="ClassLoader类的继承关系"></p>
<h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul>
<li>这个类加载器使用C/C++语言实现的，嵌套在JVM内部</li>
<li>它用来加载Java的核心库（Java_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>
<li>并不继承java.lang.ClassLoader，没有父加载器</li>
<li>加载扩展类和应用程序类加载器，并指定他们的父类加载器</li>
</ul>
<h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ul>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统熟悉所指定的目录中加载类库，或从JDK的安装目录jre/lib/ext子目录下加载类库。如果用户创建的jar放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
<h4 id="应用程序类加载器（AppClassLoader）"><a href="#应用程序类加载器（AppClassLoader）" class="headerlink" title="应用程序类加载器（AppClassLoader）"></a>应用程序类加载器（AppClassLoader）</h4><ul>
<li>Java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统熟悉java.class.path指定路径下的类库</li>
<li>该类加载是程序中默认的类加载器，一般来说，Java语言的类都是由它来完成加载</li>
<li>通过ClassLoader#getSystemClassLoader()方法可以获取该类加载器</li>
</ul>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><ul>
<li>在Java的日常语言程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式</li>
<li>为什么要自定义类加载器？<ul>
<li>隔离加载类</li>
<li>修改类的加载方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ul>
</li>
<li>用户自定义类加载器实现步骤<ol>
<li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在JDK1.2之前，在自定义类加载器时，总会继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载器，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass方法中</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器更加简洁</li>
</ol>
</li>
</ul>
<h2 id="ClassLoader的使用说明"><a href="#ClassLoader的使用说明" class="headerlink" title="ClassLoader的使用说明"></a>ClassLoader的使用说明</h2><h3 id="虚拟机自带类加载器演示"><a href="#虚拟机自带类加载器演示" class="headerlink" title="虚拟机自带类加载器演示"></a>虚拟机自带类加载器演示</h3><p>关于ClassLoder的使用我们用一个程序来演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">        ClassLoader extensionClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extensionClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：获取不到引导类加载器</span></span><br><span class="line">        ClassLoader bootStrapClassLoader = extensionClassLoader.getParent();</span><br><span class="line">        System.out.println(bootStrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        ClassLoader userClassLoader = ClassLoaderTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(userClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        ClassLoader stringClassLoader = String<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(stringClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"************启动类加载器能够加载的api路径************"</span>);</span><br><span class="line">        <span class="comment">//获取Bootstrap ClassLoader能够加载的api路径</span></span><br><span class="line">        URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL url : urLs) &#123;</span><br><span class="line">            System.out.println(url.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// /jre/lib/rt.jar下面有一个类叫做AccessController，我们来验证一下他的类加载器是什么</span></span><br><span class="line">        ClassLoader acClassLoader = AccessController<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(<span class="string">"AccessController的类加载器为："</span> + acClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"************拓展类加载器能够加载的api路径************"</span>);</span><br><span class="line">        String extDirs = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">        System.out.println(extDirs);<span class="comment">//D:\develop\Java\jdk1.8.0_131\jre\lib\ext; C:\WINDOWS\Sun\Java\lib\ext</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// jre\lib\ext 目录下有一个sunec.jar文件，里面有一个类叫CurveDB，我们来验证一下这个类的加载器是什么</span></span><br><span class="line">        ClassLoader curveDBclassLoader = CurveDB<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(curveDBclassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">null</span><br><span class="line">************启动类加载器能够加载的api路径************</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;resources.jar</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;rt.jar</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;sunrsasign.jar</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;jsse.jar</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;jce.jar</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;charsets.jar</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;lib&#x2F;jfr.jar</span><br><span class="line">file:&#x2F;D:&#x2F;develop&#x2F;Java&#x2F;jdk1.8.0_131&#x2F;jre&#x2F;classes</span><br><span class="line">AccessController的类加载器为：null</span><br><span class="line">************拓展类加载器能够加载的api路径************</span><br><span class="line">D:\develop\Java\jdk1.8.0_131\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1540e19d</span><br></pre></td></tr></table></figure>



<blockquote>
<p>sun.misc.Launcher它是一个java虚拟机的入口程序</p>
</blockquote>
<p>可以发现：</p>
<ul>
<li>Java的核心类库都是使用<strong>引导类加载器(BootStrap ClassLoader)</strong>进行加载的</li>
<li>对于用户自定义类来说，默认使用<strong>系统类加载器(App ClassLoader)</strong>进行加载</li>
</ul>
<h3 id="用户自定义加载类演示"><a href="#用户自定义加载类演示" class="headerlink" title="用户自定义加载类演示"></a>用户自定义加载类演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义用户类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassFromCustomPath(String name) &#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">"One"</span>, <span class="keyword">true</span>, customClassLoader);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取ClassLoader的几种途径"><a href="#获取ClassLoader的几种途径" class="headerlink" title="获取ClassLoader的几种途径"></a>获取ClassLoader的几种途径</h3><ul>
<li>方式一：获取当前类的ClassLoader<ul>
<li>clazz.getClassLoader()</li>
</ul>
</li>
<li>方式二：获取当前线程上线文的ClassLoader<ul>
<li>Thread.currentThread().getContextClassLoader()</li>
</ul>
</li>
<li>方式三：获取系统的ClassLoader<ul>
<li>ClassLoader.getSystemClassLoader</li>
</ul>
</li>
<li>方式四：获取调用者的ClassLoader<ul>
<li>DriverManager.getClasserLoader()</li>
</ul>
</li>
</ul>
<p>演示前三种获取方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1：获取当前类的ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = GetClassLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        ClassLoader stringClassLoader = Class.forName(<span class="string">"java.lang.String"</span>).getClassLoader();</span><br><span class="line">        System.out.println(stringClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2：获取当前线程上线文的ClassLoader</span></span><br><span class="line">        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(contextClassLoader);</span><br><span class="line">        <span class="comment">//3：获取系统的ClassLoader</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<blockquote>
<p>sun.misc.Launcher$AppClassLoader@18b4aac2<br>null<br>sun.misc.Launcher$AppClassLoader@18b4aac2<br>sun.misc.Launcher$AppClassLoader@18b4aac2</p>
</blockquote>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而加载某个类的class文件时，Java虚拟机是采用的<strong>双亲委派模式</strong>，即把请求交由父类处理，他是一种任务委派模式。</p>
<p>演示：自定义一个类java.lang.String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"我是自定义的String类中的静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//尝试加载自己写的String类，看静态代码块是否执行</span></span><br><span class="line">        String s = <span class="keyword">new</span> java.lang.String();</span><br><span class="line">        System.out.println(<span class="string">"测试自定义String类是否执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出：</p>
<blockquote>
<p>测试自定义String类是否执行</p>
</blockquote>
<p>可以发现自定义的String类中的静态代码块并没有被执行。</p>
<h3 id="双亲委派工作原理"><a href="#双亲委派工作原理" class="headerlink" title="双亲委派工作原理"></a>双亲委派工作原理</h3><ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己去加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终会到达顶层的启动类加载器</li>
<li>如果父类加载器可以完成类加载任务，就成功返回；倘若父类加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624160825.png"  alt="双亲委派机制"></p>
<p>思考：自定义的java.lang.String类是否能被正确加载和执行？</p>
<p>我们可以在此类中加入一个main方法进行测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"我是自定义的String类中的静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello String"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行报错：</p>
<blockquote>
<p>错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:<br>   public static void main(String[] args)<br>否则 JavaFX 应用程序类必须扩展javafx.application.Application</p>
</blockquote>
<p><strong>沙箱安全机制</strong></p>
<p>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p>
<h3 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h3><ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API随意篡改<ul>
<li>自定义类：java.lang.String</li>
<li>自定义类：java.lang.Hack</li>
</ul>
</li>
</ul>
<p>比如我自定义了一个java.lang.Hack的类，这个类因为是java.lang包下的按道理是应该会被启动类加载器进行加载的，经过测试我们发现程序不能执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"我是自定义的Hack类中的静态代码块,有可能包含这威胁JVM代码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HackTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//尝试加载自己写的Hack类，看静态代码块是否执行</span></span><br><span class="line">        Hack hack = <span class="keyword">new</span> Hack();</span><br><span class="line">        System.out.println(<span class="string">"测试自定义Hack类是否执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错信息：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624161529.png"  alt="报错信息"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="判断两个class对象是否为同一个类"><a href="#判断两个class对象是否为同一个类" class="headerlink" title="判断两个class对象是否为同一个类"></a>判断两个class对象是否为同一个类</h3><ul>
<li>在JVM中表示两个class对象是否为同一个类存在的两个必要条件<ul>
<li>类的全类名必须一致</li>
<li>加载这个类的ClassLoader（指ClassLoder实例对象）必须相同</li>
</ul>
</li>
<li>换句话说，在JVM中，即使两个类对象来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</li>
</ul>
<h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><p>JVM必须知道一个类是由启动加载器加载还是由用户类加载器加载的。如果一个类是由用户加载类加载的，那么JVM会<strong>将这个类加载器的一个引用作为类信息的一部分保存在方法区中（JDK8之后称为元数据区）</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
<h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为：主动使用和被动使用</p>
<ul>
<li>主动使用：分为7种情况<ul>
<li>创建类的实例</li>
<li>访问摸个类或者接口的静态变量</li>
<li>调用类的静态方法</li>
<li>反射(如：Class.forName)</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK 7开始提供动态语言支持：java.lang.invoke.MethodHandler实习的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化则初始化</li>
</ul>
</li>
<li>除了以上7种情况，其他使用Java类的方式都被看作是<strong>对类的被动使用，都不会导致类的初始化</strong></li>
</ul>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>回顾一下JVM的架构图：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200623202157.jpg"  alt="JVM架构"></p>
<p>上一章节讲完了类加载子系统(Class Loader SubSystem)，回顾一下，简单的流程步骤：</p>
<ul>
<li>加载</li>
<li>链接<ul>
<li>准备</li>
<li>校验</li>
<li>解析</li>
</ul>
</li>
<li>初始化</li>
</ul>
<p>接下来讲一下运行时数据区(Runtime Data Areas)的引入：</p>
<blockquote>
<p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高些稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着差异</strong>，结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>
</blockquote>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624164723.png"  alt="运行时数据区"></p>
<p>详细图：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200624164825.png"  alt="经典的JVM内存模型"></p>
<p>总结一下运行时数据区的划分如下：</p>
<ul>
<li>运行时数据区(Runtime Data Areas)<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>堆</li>
<li>方法区（JDK8之后为元数据区）</li>
<li>本地方法栈</li>
</ul>
</li>
</ul>
<p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁，具体而言：</p>
<ul>
<li>线程私有部分：各自包含程序计数器、栈、本地栈</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
<p><strong>JVM中的线程说明：</strong></p>
<ul>
<li>线程是一个程序里的运行单元。JVM运行一个应用有多个线程并行的执行</li>
<li>在HotSpot JVM里，每个线程都与操作系统的本地线程直接映射<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止之后，本地线程也会被回收</li>
</ul>
</li>
<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上，一旦本地线程初始化成功，它就会调用Java线程中的run方法</li>
</ul>
<p><strong>JVM系统线程</strong></p>
<ul>
<li>虚拟机线程</li>
<li>周期任务线程</li>
<li>GC线程</li>
<li>编译线程</li>
<li>信号调度线程</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎取下一条指令。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li>
<li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，声明周期与线程的生命周期保持一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者。如果是在执行native方法，则是未指定值(undefined)</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>
<li>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况区域</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200628160252.png"  alt="PC寄存器"></p>
<p>演示PC寄存器的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line"></span><br><span class="line">        String s = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200628161515.png"  alt="PCRegisterTest"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200628161554.png"  alt="PC寄存器工作原理图"></p>
<h3 id="关于PC寄存器的两个常见问题"><a href="#关于PC寄存器的两个常见问题" class="headerlink" title="关于PC寄存器的两个常见问题"></a>关于PC寄存器的两个常见问题</h3><ul>
<li><p>使用PC寄存器存储字节码指令地址有什么用呢？</p>
<p>这道题目的变形是：为什么使用PC寄存器记录当前线程的执行地址呢？</p>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
</li>
<li><p>PC寄存器为什么会被设定为线程私有？</p>
<p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常的中断或恢复，如何保证分毫无差呢？为了准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在线程之间互不影响。</p>
</li>
</ul>
<h3 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h3><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，成为它的时间片。</p>
<p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>
<p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>虚拟机栈出现的背景</strong></p>
<blockquote>
<p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台的CPU架构不同，所以不能设计为基于寄存器的。</p>
<p>基于栈的设计，优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
</blockquote>
<p><strong>内存中的栈和堆</strong></p>
<p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；–》栈管运行</p>
<p>堆是解决数据存储问题，即数据怎么放、放在哪儿。–》堆管存储</p>
<p><strong>虚拟机栈基本内容</strong></p>
<ul>
<li><p>Java虚拟机栈是什么？</p>
<p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧（Stack Frame），对应着一次次的Java方法调用，是线程私有的</p>
</li>
<li><p>生命周期</p>
<p>生命周期和线程一致</p>
</li>
<li><p>作用</p>
<p>主管Java程序的运行，它保存方法的<strong>局部变量</strong>（8中基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回</p>
</li>
<li><p>栈的特点（优点）</p>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li>JVM直接对Java栈的操作只有两个<ul>
<li>每个方法执行，伴随着进栈（入栈、压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
</li>
<li>对于栈来说不存在垃圾回收问题（GC）</li>
<li>回顾：<ul>
<li>pc寄存器：不存在gc和oom</li>
<li>虚拟机栈：存在oom，不存在gc</li>
</ul>
</li>
</ul>
</li>
<li><p>栈中可能存在的异常</p>
<ul>
<li>Java虚拟机规范允许Java栈的大小是<strong>动态的或者固定的</strong><ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机栈将会抛出一个<strong>StackOverflowError</strong>异常</li>
</ul>
</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机会抛出一个<strong>OutOfMemomoryError</strong>异常</li>
</ul>
</li>
<li><p>如何设置栈内存大小</p>
<ul>
<li>通过参数 <code>-Xss</code> 来进行设置，比如-Xss256k表示分配了256k的栈内存大小，栈的大小直接决定了函数调用的最大可达深度</li>
</ul>
</li>
</ul>
<p>这里我们通过配置来演示一下StackOverflowError的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);<span class="comment">//Exception in thread "main" java.lang.StackOverflowError</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在默认情况下，我们看到在控制台输出异常前最后一次count输出为11408，我们通过参数设置限制栈内存大小为256k，然后重新运行得到count最大为2457</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630154401.png"  alt="-Xss配置栈大小"></p>
<h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><p><strong>栈中存储什么</strong>？</p>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧(Stack Fragme)</strong>的格式存在</li>
<li>在这个线程上正在执行的每个方法都各自对应一个栈帧</li>
<li>栈帧是一块内存区域，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
<p><strong>栈运行原理</strong></p>
<ul>
<li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循“<strong>先进后出</strong>”的原则</li>
<li>在一条活动线程中，一个时间点上，只有有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类</li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧就会被创建出来，放在栈的顶端，成为新的当前帧</li>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
<li>Java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return指令</strong>；另外一种是<strong>抛出异常</strong>。不管使用哪种方式，都会导致栈帧被弹出</li>
</ul>
<p><strong>栈的内存结构</strong></p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）（或表达式栈）</li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630160503.png"  alt="栈帧结构"></p>
<h3 id="栈帧-局部变量表（local-variables）"><a href="#栈帧-局部变量表（local-variables）" class="headerlink" title="栈帧-局部变量表（local variables）"></a>栈帧-局部变量表（local variables）</h3><ul>
<li>局部变量表也被称为局部变量数组或者本地变量表</li>
<li>定义为一个数字数组，主要用于存储<strong>方法参数和定义在方法内部的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用，以及returnAddress类型</li>
<li>由于局部变量表是建立在线程上，是线程私有数据，因此<strong>不存在数据安全问题</strong></li>
<li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性maximum local variables数据项中。在方法运行期间是不会改变局部变量表大小的</li>
</ul>
<p>通过代码我们来看局部变量表的具体表示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariablesTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test1...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>javap -v LocalVariablesTest.class</code> 命令进行反编译</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630162117.png"  alt="反编译LocalVariablesTest"></p>
<p>可以发现通过反编译得到main方法的局部变量表数量为3，分别是参数args、局部变量test和num。</p>
<p>通过jclasslib也可以看到main方法的局部变量表数量：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630162428.png"  alt="jclasslib"></p>
<ul>
<li><strong>方法嵌套调用的次数由栈的大小决定。</strong>一般来说，栈越大，方法嵌套调用次数越多。对于一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用会占用更多的栈空间，导致其嵌套次数会减少</li>
<li><strong>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数列表的过程。</strong>当方法调用结束之后，随着方法栈帧的销毁，局部变量表也会随之销毁</li>
</ul>
<h4 id="变量槽Slot"><a href="#变量槽Slot" class="headerlink" title="变量槽Slot"></a>变量槽Slot</h4><ul>
<li><p>参数值存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</p>
</li>
<li><p>局部变了表，最基本的存储单元是slot（变量槽）</p>
</li>
<li><p>局部变量表中存放编译器可知的各种基本数据类型（8种），引用类型，returnAddress类型的变量</p>
</li>
<li><p>在局部变量表里，32位以内的类型只占一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot</p>
<ul>
<li>byte、short、char在存储前被专为int，boolean也被转成int，0表示false，非0表示true</li>
<li>long和double则占据两个slot</li>
</ul>
</li>
<li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
</li>
<li><p>当一个实例方法被调用的时候，它的方法参数和方法内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上</p>
</li>
<li><p>如果需要访问局部变量表中一个64bit的局部变量时，只需要使用前一个索引即可，比如long和double的访问（图中就分别使用索引1和4即可）</p>
</li>
<li><p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用的this将会存放在index为0的slot处，其余的按顺序继续排列</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630170329.png"  alt="Slot变量槽"></p>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630171159.png"  alt="Slot变量槽"></p>
<p><strong>变量槽Slot的重复利用</strong></p>
<blockquote>
<p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后声明的局部变量就很有可能会重复过期局部变量的槽位，从而达到节省资源的目的。</p>
</blockquote>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630172128.png"  alt="变量槽Slot复用"></p>
<p>下图可以发现变量b和变量c的index索引都为2</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200630172257.png"  alt="变量槽Slot复用"></p>
<h4 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h4><ul>
<li><p>参数表分配完毕之后，再根据方法内定义的变量的顺序和作用域分配</p>
</li>
<li><p>类变量表有两次初始化的机会，第一次是在“<strong>准备阶段</strong>”，执行系统初始化，对类变量设置零值，另一次则是在“<strong>初始化</strong>”阶段，赋予程序员在代码中定义的初始值</p>
</li>
<li><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用</p>
</li>
<li><p>补充</p>
<ul>
<li>在栈帧中，与性能调优关系最为米钱的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li>
</ul>
</li>
</ul>
<p>回顾变量的分类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">变量的分类：按照数据类型分：① 基本数据类型  ② 引用数据类型</span><br><span class="line">          按照在类中声明的位置分：</span><br><span class="line">          ① 成员变量：在使用前，都经历过默认初始化赋值</span><br><span class="line">                    类变量： linking的prepare阶段：给类变量默认赋值  ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><br><span class="line">                    实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><br><span class="line">          ② 局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过</span><br></pre></td></tr></table></figure>



<h3 id="栈帧-操作数栈-Operand-Stack"><a href="#栈帧-操作数栈-Operand-Stack" class="headerlink" title="栈帧-操作数栈(Operand Stack)"></a>栈帧-操作数栈(Operand Stack)</h3><p>JVM中是操作树栈就是用数组实现的</p>
<h4 id="操作数栈说明"><a href="#操作数栈说明" class="headerlink" title="操作数栈说明"></a>操作数栈说明</h4><ul>
<li>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以称之为栈</li>
<li><strong>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop)</strong><ul>
<li>某些字节码指令将值压入操作数栈，其余字节码指令将操作数取出栈，使用它们后再把结果压入栈</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701172114.png"  alt="操作数栈"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701172332.png"  alt="代码举例"></p>
<ul>
<li><strong>如果被调用的方法有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令</li>
<li>操作数栈中元素的数据类型必须与自己吗指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类验证夹断的数据流分析阶段再次验证</li>
<li>另外，我们说<strong>Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong></li>
<li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间</strong></li>
<li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</li>
<li>每个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值</li>
<li>栈中的任何一个元素都可以是任意Java数据类型<ul>
<li>32bit的类型占用一个栈单位的深度</li>
<li>64bit的类型占用两个栈单位的深度</li>
</ul>
</li>
<li>操作数栈<strong>并非采用访问索引的方式来进行数据访问的</strong>，而是只能通过标准的入栈和出栈操作来完成一次数据的访问</li>
</ul>
<h4 id="操作数栈的字节码指令执行分析"><a href="#操作数栈的字节码指令执行分析" class="headerlink" title="操作数栈的字节码指令执行分析"></a>操作数栈的字节码指令执行分析</h4><p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701175557.png"  alt="追踪操作数栈字节码指令"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">        <span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>bipush ：表示往操作数栈中压入数据</p>
<p>istore_1：表示将操作数栈中数据<strong>转存</strong>到局部变量表中</p>
<p> iload_1：将局部变量表中的数据<strong>读入</strong>到操作数栈中，此时局部变量表中依旧有该值</p>
</blockquote>
<p>下面放一张代码追踪的图</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701182405.png"  alt="操作数栈的字节码指令追踪"></p>
<p>面试题：i++和++i的区别，放到字节码篇章时结束，这里先简单看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">        <span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = m + n;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span></span><br><span class="line">        <span class="keyword">int</span> i = getSum();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    程序员面试过程中， 常见的i++和++i 的区别，放到字节码篇章时再介绍。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第1类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">10</span>;</span><br><span class="line">        i1++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">10</span>;</span><br><span class="line">        ++i2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第2类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i4 = i3++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i5 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i6 = ++i5;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第3类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i7 = <span class="number">10</span>;</span><br><span class="line">        i7 = i7++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i8 = <span class="number">10</span>;</span><br><span class="line">        i8 = ++i8;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第4类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i9 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i10 = i9++ + ++i9;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法add对应的字节码指令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> 0 bipush 10</span><br><span class="line"> 2 istore_1</span><br><span class="line"> 3 iinc 1 by 1</span><br><span class="line"> 6 bipush 10</span><br><span class="line"> 8 istore_2</span><br><span class="line"> 9 iinc 2 by 1</span><br><span class="line">12 bipush 10</span><br><span class="line">14 istore_3</span><br><span class="line">15 iload_3</span><br><span class="line">16 iinc 3 by 1</span><br><span class="line">19 istore 4</span><br><span class="line">21 bipush 10</span><br><span class="line">23 istore 5</span><br><span class="line">25 iinc 5 by 1</span><br><span class="line">28 iload 5</span><br><span class="line">30 istore 6</span><br><span class="line">32 bipush 10</span><br><span class="line">34 istore 7</span><br><span class="line">36 iload 7</span><br><span class="line">38 iinc 7 by 1</span><br><span class="line">41 istore 7</span><br><span class="line">43 bipush 10</span><br><span class="line">45 istore 8</span><br><span class="line">47 iinc 8 by 1</span><br><span class="line">50 iload 8</span><br><span class="line">52 istore 8</span><br><span class="line">54 bipush 10</span><br><span class="line">56 istore 9</span><br><span class="line">58 iload 9</span><br><span class="line">60 iinc 9 by 1</span><br><span class="line">63 iinc 9 by 1</span><br><span class="line">66 iload 9</span><br><span class="line">68 iadd</span><br><span class="line">69 istore 10</span><br><span class="line">71 return</span><br></pre></td></tr></table></figure>



<h4 id="栈顶缓存（Top-Of-Stack-Cashing）技术"><a href="#栈顶缓存（Top-Of-Stack-Cashing）技术" class="headerlink" title="栈顶缓存（Top-Of-Stack Cashing）技术"></a>栈顶缓存（Top-Of-Stack Cashing）技术</h4><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数</p>
<p>由于操作数是查重在内存中的，隐藏频繁地执行内存读写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos,Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率</strong></p>
<h3 id="栈帧-动态链接-Dynamic-Linking"><a href="#栈帧-动态链接-Dynamic-Linking" class="headerlink" title="栈帧-动态链接(Dynamic Linking)"></a>栈帧-动态链接(Dynamic Linking)</h3><ul>
<li>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态链接（Dynamic Linking）</strong>，比如invokedynamic指令</li>
<li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicLinkingTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"methodA()...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"methodB()...."</span>);</span><br><span class="line">        methodA();</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701192501.png"  alt="动态链接"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701192542.png"  alt="动态链接"></p>
<p>指向运行时常量池的方法引用我们称为动态链接。</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701192635.png"  alt="动态链接"></p>
<p>为什么需要常量池呢？</p>
<blockquote>
<p>常量池的作用，就是为了提供一些符号和常量，便于指令的识别</p>
</blockquote>
<h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><p>在JVM中，将符号引用转换成为调用方法的直接引用与方法的绑定机制相关。</p>
<ul>
<li>静态链接<ul>
<li>当一个字节码文件被装载进JVM内部时，如果被<strong>调用的目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称为静态链接</li>
</ul>
</li>
<li>动态链接<ul>
<li>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此称为动态链接</li>
</ul>
</li>
</ul>
<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<ul>
<li>早期绑定<ul>
<li>早期绑定就是指被调用的目<strong>标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用</li>
</ul>
</li>
<li>晚期绑定<ul>
<li>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称为晚期绑定</li>
</ul>
</li>
</ul>
<p>演示早期绑定和晚期绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"动物进食"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗吃骨头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"捕食耗子，多管闲事"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eat();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"捕食耗子，天经地义"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAnimal</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHunt</span><span class="params">(Huntable h)</span> </span>&#123;</span><br><span class="line">        h.hunt();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701194425.png"  alt="动态绑定"></p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701194456.png"  alt="静态绑定"></p>
<p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显示定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p>
<p><strong>虚方法与非虚方法</strong></p>
<ul>
<li>非虚方法<ul>
<li>如果方法在编译期就能确定了具体的调用版本，这个版本在运行时不可变的，这样的方法称为非虚方法</li>
<li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</li>
<li>其他放称为虚方法</li>
</ul>
</li>
</ul>
<p>虚拟机提供了以下几条方法调用指令：</p>
<ul>
<li>普通调用指令<ol>
<li><strong>invokestatic：调用静态方法，解析阶段确定唯一方法版本</strong></li>
<li><strong>invokespecial：调用<init>方法、私有方法以及父类放，解析阶段确定唯一方法版本</strong></li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ol>
</li>
<li>动态调用指令<ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法</p>
<p><strong>关于invokedynamic指令</strong></p>
<ul>
<li>JVM字节码指令集一直比较稳定，一直到Java7中财增加了invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进</li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具类生成invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方法</li>
<li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规范的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器</li>
</ul>
<p><strong>动态语言类型和静态语言类型</strong></p>
<p>​    两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之就是动态类型语言。</p>
<p>​    <strong>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</strong>，这是动态语言的一个重要特性</p>
<p><strong>方法重写的本质</strong></p>
<p>​    Java语言中方法重写的本质：</p>
<pre><code>1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C
 2. 如果在类型C中找到与常量中的描述符合简单名称都符合的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常
 3. 否则按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程
 4. 如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError异常</code></pre><p>IllegalAccessError介绍：</p>
<p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明了一个类发生了不兼容的改变</p>
<p><strong>虚方法表</strong></p>
<ul>
<li>在面向对象的编程中，会很频繁的使用到动态分配，如果每次动态分配的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（Virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来替代查找</li>
<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</li>
<li>那么虚方法表什么时候被创建呢？<ul>
<li>虚方法表会在类加载的<strong>链接阶段</strong>创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕</li>
</ul>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200701201830.png"  alt="类的链接过程"></p>
<blockquote>
<p>后续再补充虚方法表相关知识</p>
</blockquote>
<h3 id="栈帧-返回地址-return-address"><a href="#栈帧-返回地址-return-address" class="headerlink" title="栈帧-返回地址(return address)"></a>栈帧-返回地址(return address)</h3><ul>
<li>存放调用该方法的pc寄存器的值</li>
<li>一个方法的结束有两种方式<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论通过哪一种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧一般不会保存这些信息</li>
</ul>
<p>​    本质上，方法的返回就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p>​    <strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p>
<p><strong>正常完成出口</strong></p>
<p>​    在字节码指令中，返回指令包含ireturn(当返回值手机boolean、byte、char、short和int类型时使用)、lreturn、freturn、dreturn以及areturn，另外还有一个return指令提供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</p>
<p><strong>异常完成出口</strong></p>
<p>​    在方法执行过程中遇到了异常，并且这个异常没有在方法内部进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p>
<p>​    方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在放生 异常的时候找到处理异常的代码。</p>
<h3 id="栈帧-一些附加信息"><a href="#栈帧-一些附加信息" class="headerlink" title="栈帧-一些附加信息"></a>栈帧-一些附加信息</h3><blockquote>
<p>栈帧中还运行携带与Java虚拟机实现相关的一些附加信息，例如，对程序调试提供支持的信息。</p>
</blockquote>
<h3 id="关于栈的一些面试题"><a href="#关于栈的一些面试题" class="headerlink" title="关于栈的一些面试题"></a>关于栈的一些面试题</h3><ul>
<li>举例栈溢出的情况（StackOverflowError）</li>
<li>通过-Xss设置栈的大小；OOM</li>
<li>调整栈大小，就能保住不出现溢出吗？不能</li>
<li>分配的栈内存越大越好吗？不是</li>
<li>垃圾回收是否涉及到虚拟机栈？不会</li>
<li>方法中定义的局部变量是否是线程安全？具体问题具体分析</li>
</ul>
<p>何为线程安全？</p>
<ul>
<li>如果只有一个线程才可以操作此数据，则必是线程安全的</li>
<li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder本身是线程不安全</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(StringBuilder sBuilder)</span></span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">        sBuilder.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">"a"</span>);</span><br><span class="line">            s.append(<span class="string">"b"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        method2(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="本地方法接口-不属于运行时数据区"><a href="#本地方法接口-不属于运行时数据区" class="headerlink" title="本地方法接口(不属于运行时数据区)"></a>本地方法接口(不属于运行时数据区)</h2><p>本地方法接口本身是不属于运行时数据区的，但为了讲解本地方法栈，我们先讲解本地方法接口，先看下它在JVM中的位置。</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200702100946.png"  alt="本地方法接口"></p>
<h3 id="什么是本地方法接口"><a href="#什么是本地方法接口" class="headerlink" title="什么是本地方法接口"></a>什么是本地方法接口</h3><p>简单地讲，<strong>一个Native Method就是一个Java调用非Java代码的接囗</strong>。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如<br>c。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在c++中，你可以用extern “C” 告知c++编译器去调用一个c的函数。</p>
<p>“A native mehod is a Java method whose implementation is provided by non-java code.”</p>
<p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface)，因为其实现体是由非java语言在外面实现的。</p>
<p>本地接囗的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200702102055.png"  alt="Thread中的native方法"></p>
<p>注：java层面上的线程都会转化成操作系统的本地线程。</p>
<p>标识符native可以与其他所有java表示符连用，但是abstract除外：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IHaveNatives</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native4</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//abstract native void Native5(int[] ary) throws Exception;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="为什么要使用Native-Method"><a href="#为什么要使用Native-Method" class="headerlink" title="为什么要使用Native Method"></a>为什么要使用Native Method</h3><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<ul>
<li>与Java环境外交互<br><strong>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。</strong>你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li>
<li>与操作系统交互<br>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。<strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</strong>。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
<li>Sun’SJava<br><strong>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互</strong>。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java．lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用c实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Winn32 setPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library)提供，然后被JVM调用。</li>
</ul>
<h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印或者Java系统管理生产设备，在企业级应用中己经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>
<h2 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈(Native Method Stack)"></a>本地方法栈(Native Method Stack)</h2><p>本地方法栈的位置：</p>
<p><img src="/" class="lazyload" data-src="https://gitee.com/vxo/img/raw/master/blog/20200702104125.png"  alt="本地方法栈的位置"></p>
<ul>
<li><p><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong></p>
</li>
<li><p>本地方法栈也是线程私有的</p>
</li>
<li><p>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面是相同的）</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li>
<li>如果本地方法栈可以<strong>动态拓展</strong>，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个 <strong>OutOfMemoryError</strong> 异常</li>
</ul>
</li>
<li><p>本地方法是使用C语言实现的</p>
</li>
<li><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库</p>
</li>
<li><p>当某个线程调用了一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有同样的权限</p>
<ul>
<li>本地方法可以通过本地方法接口<strong>来访问虚拟机内部的运行时数据区</strong></li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ul>
</li>
<li><p>并不是所有JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈</p>
</li>
<li><p>在HotSpot JVM中，直接将本地方法栈和虚拟机栈合二为一</p>
</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>this.</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h2 id="对象的实例化、内存布局与访问定位"><a href="#对象的实例化、内存布局与访问定位" class="headerlink" title="对象的实例化、内存布局与访问定位"></a>对象的实例化、内存布局与访问定位</h2><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收</a></div><div class="post_share"><div class="social-share" data-image="https://coding.imooc.com/static/module/class/content/img/308/section1-2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/23/%E4%BD%9C%E4%B8%9A%EF%BC%9AAndroid%20so%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">作业：Android so文件的解析</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/11/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><img class="next_cover lazyload" data-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1591889310669&amp;di=be6eb09cee916539f259689f061f7862&amp;imgtype=0&amp;src=http%3A%2F%2Fimg14.360buyimg.com%2Fn0%2Fjfs%2Ft9730%2F40%2F847174291%2F365589%2F2c1c4949%2F59d88418N7ab46c0e.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《深入理解计算机系统》读书笔记</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Kai</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>